<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title>李岩的博客 - tcp</title>
    <subtitle>努力做个程序员</subtitle>
    <link rel="self" type="application/atom+xml" href="https://liyan-ah.github.io/tags/tcp/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://liyan-ah.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-02-24T15:55:00+08:00</updated>
    <id>https://liyan-ah.github.io/tags/tcp/atom.xml</id>
    <entry xml:lang="zh-CN">
        <title>TCP close 过程分析</title>
        <published>2024-02-24T15:55:00+08:00</published>
        <updated>2024-02-24T15:55:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/tcp-close-guo-cheng-fen-xi/"/>
        <id>https://liyan-ah.github.io/tcp-close-guo-cheng-fen-xi/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近做了一些 TCP 连接观测相关的项目，又到了一个节奏点上了。这里趁着这个机会，做一些总结，同时描述一下 tcp close 过程中的一些疑惑。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;在一些场景下，对服务的调用观测是很有价值的。笔者最近实践了使用&lt;code&gt;tcp_close&lt;&#x2F;code&gt;对服务主被调信息的观测，在这里作一下记录。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>BPF 获取 LVS FullNat 模式下的 Client IP</title>
        <published>2024-01-03T16:15:00+08:00</published>
        <updated>2024-01-03T16:15:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/bpf-huo-qu-lvs-fullnet-mo-shi-xia-de-client-ip/"/>
        <id>https://liyan-ah.github.io/bpf-huo-qu-lvs-fullnet-mo-shi-xia-de-client-ip/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;搞项目。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;观测服务的请求调用需求是客观存在的。一般是需要观测服务的主动发起的调用信息，但是偶尔也会遇到需要观测服务被调用信息的需求。但是一般待采集的服务都是挂载在&lt;code&gt;LVS&lt;&#x2F;code&gt;下面的。这就势必涉及到&lt;code&gt;LVS&lt;&#x2F;code&gt;预设的工作模式下，一般都是&lt;code&gt;FULLNET&lt;&#x2F;code&gt;，需要的&lt;code&gt;real client ip&lt;&#x2F;code&gt;的信息获取方式。&lt;br &#x2F;&gt;
笔者通过调研，实现了一种通过&lt;code&gt;BPF&lt;&#x2F;code&gt;来观测挂载在&lt;code&gt;LVS&lt;&#x2F;code&gt;下的&lt;code&gt;RS&lt;&#x2F;code&gt;被调用&lt;code&gt;TCP&lt;&#x2F;code&gt;连接信息的方式。本文中关于&lt;code&gt;toa&lt;&#x2F;code&gt;的操作及代码定义均引用自&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Huawei&#x2F;TCP_option_address&#x2F;tree&#x2F;master&quot;&gt;Huawei&#x2F;TCP_option_address&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>ebpf 采集ebpf 采集tag+tcp五元组</title>
        <published>2023-02-24T21:44:49+08:00</published>
        <updated>2023-02-24T21:44:49+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/ebpf-cai-ji-caller-func/"/>
        <id>https://liyan-ah.github.io/ebpf-cai-ji-caller-func/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在这里对文章题目作一些说明。笔者想了很长时间也无法给这篇文章想个恰当的表意题目。实际上使用&lt;code&gt;ebpf&lt;&#x2F;code&gt;来进行服务观测是有在进行的，比如获取目前&lt;code&gt;l1s&lt;&#x2F;code&gt;上的常见的四元组。但是本文不是介绍这部分可观测实践的。文章希望阐述的场景是：采集请求触发里的一些信息（诸如&lt;code&gt;trace&lt;&#x2F;code&gt;及其他&lt;code&gt;header&lt;&#x2F;code&gt;等）并和服务请求下游的传输层五元组(protocol, src-ip, src-port, dst-ip, dst-port)进行关联。这也是最近工作中实际遇到的问题。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;基于&lt;code&gt;ebpf&lt;&#x2F;code&gt;的丰富的特性能够获取服务很多的信息，不同特性的组合更是可以达到极强的数据整合能力。比如通过&lt;code&gt;uprobe&lt;&#x2F;code&gt;便捷的获取业务信息后，结合&lt;code&gt;kprobe&lt;&#x2F;code&gt;来获取系统调用里的内容，可以获取一般侵入式可观测代码无法获取的内容。笔者最近遇到的一个实际问题是：获取服务&lt;code&gt;A&lt;&#x2F;code&gt;的接口&lt;code&gt;&#x2F;a&lt;&#x2F;code&gt;响应后，向下游&lt;code&gt;B&lt;&#x2F;code&gt;发起的请求时，所使用的传输层五元组，同时带上结合一些&lt;code&gt;&#x2F;a&lt;&#x2F;code&gt;触发时的一些内容，比如&lt;code&gt;caller_fun&lt;&#x2F;code&gt;或者&lt;code&gt;traceId&lt;&#x2F;code&gt;。&lt;br &#x2F;&gt;
这里值得说明的是，用户态请求的是一个域名。域名的解析是在&lt;code&gt;golang&lt;&#x2F;code&gt;的&lt;code&gt;http&lt;&#x2F;code&gt;里完成的。但是请注意，&lt;code&gt;golang&lt;&#x2F;code&gt;发起&lt;code&gt;tcp&lt;&#x2F;code&gt;请求时，&lt;code&gt;local port&lt;&#x2F;code&gt;设置的是&lt;code&gt;0&lt;&#x2F;code&gt;，然后由内核态的&lt;code&gt;tpc&lt;&#x2F;code&gt;处理来选择一个空闲的&lt;code&gt;port&lt;&#x2F;code&gt;作为&lt;code&gt;socket&lt;&#x2F;code&gt;里的&lt;code&gt;lport&lt;&#x2F;code&gt;。这部分的信息通过代码的埋点显然是无法获取的（详情可参考&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?__biz=MjM5Njg5NDgwNA==&amp;amp;mid=2247485577&amp;amp;idx=1&amp;amp;sn=24220fcc3782f61b4a691585251f1c27&amp;amp;chksm=a6e309b2919480a4696c8a2944ad887951100b5068050d354eab40cf0c8f1124b6367176a0a6&amp;amp;scene=21#wechat_redirect&quot;&gt;TCP连接中客户端的端口号是如何确定的？&lt;&#x2F;a&gt;）。&lt;br &#x2F;&gt;
下面介绍下实现效果及思路。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于&lt;code&gt;bpftrace&lt;&#x2F;code&gt;使用的介绍，可以参见：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;07&#x2F;22&#x2F;bpfTrace-%E8%BF%BD%E8%B8%AA-uprobe&#x2F;#more&quot;&gt;bpftrace 无侵入遍历golang链表&lt;&#x2F;a&gt;，关于&lt;code&gt;ebpf&lt;&#x2F;code&gt;来进行数据采集的实践，可以参见&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;10&#x2F;21&#x2F;ebpf%E9%87%87%E9%9B%86mysql%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E5%8F%8Aebpf%E5%AF%B9%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E7%9A%84%E6%80%9D%E8%80%83&#x2F;&quot;&gt;ebpf采集mysql请求信息及ebpf对应用安全的思考&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
</feed>
