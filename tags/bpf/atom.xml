<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title>李岩的博客 - BPF</title>
    <subtitle>努力做个程序员</subtitle>
    <link rel="self" type="application/atom+xml" href="https://liyan-ah.github.io/tags/bpf/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://liyan-ah.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-03-12T11:02:00+08:00</updated>
    <id>https://liyan-ah.github.io/tags/bpf/atom.xml</id>
    <entry xml:lang="zh-CN">
        <title>BPF LRU_HASH_MAP 及 HASH_MAP 的使用异常</title>
        <published>2024-03-12T11:02:00+08:00</published>
        <updated>2024-03-12T11:02:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/bpf-lru-hash-map-ji-hash-map-de-shi-yong-yi-chang/"/>
        <id>https://liyan-ah.github.io/bpf-lru-hash-map-ji-hash-map-de-shi-yong-yi-chang/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;BPF 技术看起来还有很多不易察觉的缺陷。最近又踩了一个坑。记录下。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;LRU_HASH_MAP&lt;&#x2F;code&gt; 在实现的时候，出现了不符合预期的数据驱逐问题：设定一个 512 大小的&lt;code&gt;LRU_HASH_MAP&lt;&#x2F;code&gt;，很可能出现在40-50个&lt;code&gt;key&lt;&#x2F;code&gt;的时候，之前的&lt;code&gt;key&lt;&#x2F;code&gt;就被覆盖。在一段时间未更新时，重新更新也可能会出现异常。总结就是，执行了写入操作，很可能没有写入。这个问题在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;75882443&#x2F;elements-incorrectly-evicted-from-ebpf-lru-hash-map&quot;&gt;Elements incorrectly evicted from eBPF LRU hash map&lt;&#x2F;a&gt;有较为详细的描述。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>TCP close 过程分析</title>
        <published>2024-02-24T15:55:00+08:00</published>
        <updated>2024-02-24T15:55:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/tcp-close-guo-cheng-fen-xi/"/>
        <id>https://liyan-ah.github.io/tcp-close-guo-cheng-fen-xi/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近做了一些 TCP 连接观测相关的项目，又到了一个节奏点上了。这里趁着这个机会，做一些总结，同时描述一下 tcp close 过程中的一些疑惑。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;在一些场景下，对服务的调用观测是很有价值的。笔者最近实践了使用&lt;code&gt;tcp_close&lt;&#x2F;code&gt;对服务主被调信息的观测，在这里作一下记录。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>BPF 获取 LVS FullNat 模式下的 Client IP</title>
        <published>2024-01-03T16:15:00+08:00</published>
        <updated>2024-01-03T16:15:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/bpf-huo-qu-lvs-fullnet-mo-shi-xia-de-client-ip/"/>
        <id>https://liyan-ah.github.io/bpf-huo-qu-lvs-fullnet-mo-shi-xia-de-client-ip/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;搞项目。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;观测服务的请求调用需求是客观存在的。一般是需要观测服务的主动发起的调用信息，但是偶尔也会遇到需要观测服务被调用信息的需求。但是一般待采集的服务都是挂载在&lt;code&gt;LVS&lt;&#x2F;code&gt;下面的。这就势必涉及到&lt;code&gt;LVS&lt;&#x2F;code&gt;预设的工作模式下，一般都是&lt;code&gt;FULLNET&lt;&#x2F;code&gt;，需要的&lt;code&gt;real client ip&lt;&#x2F;code&gt;的信息获取方式。&lt;br &#x2F;&gt;
笔者通过调研，实现了一种通过&lt;code&gt;BPF&lt;&#x2F;code&gt;来观测挂载在&lt;code&gt;LVS&lt;&#x2F;code&gt;下的&lt;code&gt;RS&lt;&#x2F;code&gt;被调用&lt;code&gt;TCP&lt;&#x2F;code&gt;连接信息的方式。本文中关于&lt;code&gt;toa&lt;&#x2F;code&gt;的操作及代码定义均引用自&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Huawei&#x2F;TCP_option_address&#x2F;tree&#x2F;master&quot;&gt;Huawei&#x2F;TCP_option_address&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>如何追踪golang channel?</title>
        <published>2023-12-08T19:43:00+08:00</published>
        <updated>2023-12-08T19:43:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/wei-shen-me-wo-men-wu-fa-zhui-zong-golang-channel/"/>
        <id>https://liyan-ah.github.io/wei-shen-me-wo-men-wu-fa-zhui-zong-golang-channel/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2023年就要结束了，算起来距离上一次更新也有很久了。搜肠刮肚，总得在23年结束前再搞两篇总结，算是有始有终。总结今年，总还是绕不过 BPF，golang。既然如此，就对BPF观测golang这个话题再往下挖掘下，先做第一篇文章。下旬如果有时间并且顺利的话，希望能把BPF的原理总结完成。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2023&#x2F;03&#x2F;29&#x2F;cljb83dmh003dkcs61joe1kfh&#x2F;#more&quot;&gt;无侵入观测服务拓扑四元组的一种实现&lt;&#x2F;a&gt;中，笔者有提到追踪&lt;code&gt;golang&lt;&#x2F;code&gt;处理过程的两个无法解决的问题是&lt;code&gt;golang&lt;&#x2F;code&gt;里的&lt;code&gt;channel&lt;&#x2F;code&gt;处理以及&lt;code&gt;goroutine pool&lt;&#x2F;code&gt;。再深究下，这两个问题实际上都可以归纳到对&lt;code&gt;channel&lt;&#x2F;code&gt;的处理，因为很多&lt;code&gt;goroutine pool&lt;&#x2F;code&gt;都离不了&lt;code&gt;channel&lt;&#x2F;code&gt;的使用，比如&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Jeffail&#x2F;tunny&quot;&gt;Jeffail&#x2F;tunny&lt;&#x2F;a&gt;这个库。&lt;br &#x2F;&gt;
本文将会构建一个&lt;code&gt;channel&lt;&#x2F;code&gt;的追踪的方案。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>bpftrace 遍历 golang 链表（go17+）</title>
        <published>2023-11-18T15:36:00+08:00</published>
        <updated>2023-11-18T15:36:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/bpftrace-bian-li-golang-lian-biao-go17/"/>
        <id>https://liyan-ah.github.io/bpftrace-bian-li-golang-lian-biao-go17/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;不出意外的，之前提到的 ELF 文件解析内容又拖延了。目前还不知道什么时候有时间能够把希望完成的几篇文章给搞完。翻一翻目前的博客，已经有很久没有更新了。那就水一篇文章吧。目前算是项目里的低谷期，希望能够重拾程序员的意义。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;07&#x2F;22&#x2F;cljb83dlm000ckcs6bp7thrf9&#x2F;#more&quot;&gt;bpftrace 无侵入遍历golang链表&lt;&#x2F;a&gt;里，笔者展示了使用&lt;code&gt;bpftrace&lt;&#x2F;code&gt;来遍历&lt;code&gt;golang&lt;&#x2F;code&gt;链表的方法。由于&lt;code&gt;go-17&lt;&#x2F;code&gt;和&lt;code&gt;go-16&lt;&#x2F;code&gt;的函数调用规约存在不同，因此&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;07&#x2F;22&#x2F;cljb83dlm000ckcs6bp7thrf9&#x2F;#more&quot;&gt;bpftrace 无侵入遍历golang链表&lt;&#x2F;a&gt;并不适用于&lt;code&gt;go-17&lt;&#x2F;code&gt;。其实这个问题在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2023&#x2F;03&#x2F;03&#x2F;cljb83dm2001mkcs68hgf9o2s&#x2F;#more&quot;&gt;go-1.17+ 调用规约&lt;&#x2F;a&gt;已经提到了解决方案。本文给一个实例，算是更进一步的延伸这个话题，希望能够起到一些效果。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>eBPF tail-calls示例</title>
        <published>2023-08-26T12:30:00+08:00</published>
        <updated>2023-08-26T12:30:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/ebpf-tail-calls/"/>
        <id>https://liyan-ah.github.io/ebpf-tail-calls/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近在整理一些技术文章。本来希望把涉及ELF的内容整理出来，结果发现太难了。ELF涉及的内容要多很多，如果要把希望整理的内容表述清楚，还需要做一些准备的工作。刚好最近完成了tail-calls 的调研，先把关于eBPF的tail-calls的功能整理下吧。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;eBPF&lt;&#x2F;code&gt;程序是事件驱动的，这就意味着当目标事件触发后，程序才能执行。考虑这样一个场景：有几个不同的&lt;code&gt;BPF&lt;&#x2F;code&gt;程序均挂载在相同的&lt;code&gt;hook&lt;&#x2F;code&gt;点上，而执行需要保持一定的顺序。这时就需要借助&lt;code&gt;tail calls&lt;&#x2F;code&gt;的功能来实现。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>BPF追踪Go程序的挑战</title>
        <published>2023-06-25T17:08:00+08:00</published>
        <updated>2023-06-25T17:08:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/golang/"/>
        <id>https://liyan-ah.github.io/golang/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文地址&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.0x74696d.com&#x2F;posts&#x2F;challenges-of-bpf-tracing-go&#x2F;&quot;&gt;Challenges of BPF Tracing Go&lt;&#x2F;a&gt;。翻译不尽如人意，继续努力。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;bpfzhui-zong-gocheng-xu-de-tiao-zhan&quot;&gt;BPF追踪Go程序的挑战&lt;&#x2F;h1&gt;
&lt;p&gt;当大家对&lt;code&gt;Go 1.17&lt;&#x2F;code&gt;语言调用规约(&lt;code&gt;function calling convention&lt;&#x2F;code&gt;)调整带来的性能优化感到兴奋时，我却遗憾的看到&lt;code&gt;Go 1.17&lt;&#x2F;code&gt;并没有让&lt;code&gt;BPF uretprobe&lt;&#x2F;code&gt;变得可行。事实证明，我还没有完全意识到&lt;code&gt;Go&lt;&#x2F;code&gt;的可调整的栈空间会让事情变得多复杂。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>无侵入观测服务拓扑四元组的一种实现</title>
        <published>2023-03-29T19:42:00+08:00</published>
        <updated>2023-03-29T19:42:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/wu-qin-ru-guan-ce-fu-wu-si-yuan-zu/"/>
        <id>https://liyan-ah.github.io/wu-qin-ru-guan-ce-fu-wu-si-yuan-zu/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近有了些时间，继续整理下之前的项目。服务四元组的信息对于故障处置、根因定位等都有重要意义。使用eBPF可以做到无侵入用户代码获取服务四元组信息的功能。这一点在工程应用上很有意义。笔者在这方面投入了一些精力，这里做一下简单的总结。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;服务四元组指的是[caller, caller_func, callee, callee_func]四元组。如下图是一个调用示例，站在服务&lt;code&gt;A&lt;&#x2F;code&gt;的角度，就存在如下两个四元组: [A, &#x2F;a, B, &#x2F;b]，[A, &#x2F;a, C, &#x2F;c]。站在服务&lt;code&gt;B&lt;&#x2F;code&gt;, &lt;code&gt;C&lt;&#x2F;code&gt;的角度，也存在两个四元组（可能有不同的理解）: [B, &#x2F;b, none, none], [C, &#x2F;c, none, none]。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;                       service call                  
                                                     
     ,-------.          ,-.          ,-.          ,-.
     |outisde|          |A|          |B|          |C|
     `---+---&amp;#39;          `+&amp;#39;          `+&amp;#39;          `+&amp;#39;
         |      &#x2F;a       |            |            | 
         |--------------&amp;gt;|            |            | 
         |               |            |            | 
         |               |    &#x2F;b      |            | 
         |               |-----------&amp;gt;|            | 
         |               |            |            | 
         |               |           &#x2F;c            | 
         |               |------------------------&amp;gt;| 
     ,---+---.          ,+.          ,+.          ,+.
     |outisde|          |A|          |B|          |C|
     `-------&amp;#39;          `-&amp;#39;          `-&amp;#39;          `-&amp;#39;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在弄清楚四元组是什么之后，下面进入今天的话题：如何使用&lt;code&gt;BPF&lt;&#x2F;code&gt;来采集四元组。需要说明的是，笔者这里的语言使用的是&lt;code&gt;golang-1.16&lt;&#x2F;code&gt;。&lt;code&gt;golang&lt;&#x2F;code&gt;不同语言版本间的区别，见：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2023&#x2F;03&#x2F;03&#x2F;golang-1-17-%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E7%BA%A6&#x2F;#more&quot;&gt;golang-1.17+调用规约&lt;&#x2F;a&gt;。&lt;br &#x2F;&gt;
值得注意的是，关于观测服务数据，是有很多解决方案的。本文仅是笔者实践的一种解决方案，在文末会简单提到这种方案的优缺点。&lt;br &#x2F;&gt;
按照惯例，先看下效果吧：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# 启动采集
bpftrace .&#x2F;http.bt
Attaching 2 probes...  # 未触发请求前，停止在这里
caller:                # 触发请求后，输出
  	caller_path: &#x2F;handle
callee:
  	method: GET
  	host: 0.0.0.0:9932
  	url: &#x2F;echo
  
caller:
  	caller_path: &#x2F;echo
callee: none
  
# 开始服务
.&#x2F;http_demo &amp;amp;
# 触发请求
curl http:&#x2F;&#x2F;0.0.0.0:9932&#x2F;handle
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>ebpf 采集ebpf 采集tag+tcp五元组</title>
        <published>2023-02-24T21:44:49+08:00</published>
        <updated>2023-02-24T21:44:49+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/ebpf-cai-ji-caller-func/"/>
        <id>https://liyan-ah.github.io/ebpf-cai-ji-caller-func/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在这里对文章题目作一些说明。笔者想了很长时间也无法给这篇文章想个恰当的表意题目。实际上使用&lt;code&gt;ebpf&lt;&#x2F;code&gt;来进行服务观测是有在进行的，比如获取目前&lt;code&gt;l1s&lt;&#x2F;code&gt;上的常见的四元组。但是本文不是介绍这部分可观测实践的。文章希望阐述的场景是：采集请求触发里的一些信息（诸如&lt;code&gt;trace&lt;&#x2F;code&gt;及其他&lt;code&gt;header&lt;&#x2F;code&gt;等）并和服务请求下游的传输层五元组(protocol, src-ip, src-port, dst-ip, dst-port)进行关联。这也是最近工作中实际遇到的问题。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;基于&lt;code&gt;ebpf&lt;&#x2F;code&gt;的丰富的特性能够获取服务很多的信息，不同特性的组合更是可以达到极强的数据整合能力。比如通过&lt;code&gt;uprobe&lt;&#x2F;code&gt;便捷的获取业务信息后，结合&lt;code&gt;kprobe&lt;&#x2F;code&gt;来获取系统调用里的内容，可以获取一般侵入式可观测代码无法获取的内容。笔者最近遇到的一个实际问题是：获取服务&lt;code&gt;A&lt;&#x2F;code&gt;的接口&lt;code&gt;&#x2F;a&lt;&#x2F;code&gt;响应后，向下游&lt;code&gt;B&lt;&#x2F;code&gt;发起的请求时，所使用的传输层五元组，同时带上结合一些&lt;code&gt;&#x2F;a&lt;&#x2F;code&gt;触发时的一些内容，比如&lt;code&gt;caller_fun&lt;&#x2F;code&gt;或者&lt;code&gt;traceId&lt;&#x2F;code&gt;。&lt;br &#x2F;&gt;
这里值得说明的是，用户态请求的是一个域名。域名的解析是在&lt;code&gt;golang&lt;&#x2F;code&gt;的&lt;code&gt;http&lt;&#x2F;code&gt;里完成的。但是请注意，&lt;code&gt;golang&lt;&#x2F;code&gt;发起&lt;code&gt;tcp&lt;&#x2F;code&gt;请求时，&lt;code&gt;local port&lt;&#x2F;code&gt;设置的是&lt;code&gt;0&lt;&#x2F;code&gt;，然后由内核态的&lt;code&gt;tpc&lt;&#x2F;code&gt;处理来选择一个空闲的&lt;code&gt;port&lt;&#x2F;code&gt;作为&lt;code&gt;socket&lt;&#x2F;code&gt;里的&lt;code&gt;lport&lt;&#x2F;code&gt;。这部分的信息通过代码的埋点显然是无法获取的（详情可参考&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?__biz=MjM5Njg5NDgwNA==&amp;amp;mid=2247485577&amp;amp;idx=1&amp;amp;sn=24220fcc3782f61b4a691585251f1c27&amp;amp;chksm=a6e309b2919480a4696c8a2944ad887951100b5068050d354eab40cf0c8f1124b6367176a0a6&amp;amp;scene=21#wechat_redirect&quot;&gt;TCP连接中客户端的端口号是如何确定的？&lt;&#x2F;a&gt;）。&lt;br &#x2F;&gt;
下面介绍下实现效果及思路。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于&lt;code&gt;bpftrace&lt;&#x2F;code&gt;使用的介绍，可以参见：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;07&#x2F;22&#x2F;bpfTrace-%E8%BF%BD%E8%B8%AA-uprobe&#x2F;#more&quot;&gt;bpftrace 无侵入遍历golang链表&lt;&#x2F;a&gt;，关于&lt;code&gt;ebpf&lt;&#x2F;code&gt;来进行数据采集的实践，可以参见&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;10&#x2F;21&#x2F;ebpf%E9%87%87%E9%9B%86mysql%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E5%8F%8Aebpf%E5%AF%B9%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E7%9A%84%E6%80%9D%E8%80%83&#x2F;&quot;&gt;ebpf采集mysql请求信息及ebpf对应用安全的思考&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>golang常见类型作为参数的eBPF解析</title>
        <published>2022-12-30T19:24:18+08:00</published>
        <updated>2022-12-30T19:24:18+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/golangchang-jian-lei-xing-jie-xi/"/>
        <id>https://liyan-ah.github.io/golangchang-jian-lei-xing-jie-xi/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;即将过去的2022年，笔者相当比例的精力都投入在了eBPF上。最初的时候，写了一篇&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;06&#x2F;06&#x2F;golang-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E5%AD%97%E8%8A%82%E6%95%B0&#x2F;&quot;&gt;golang 常见类型字节数
&lt;&#x2F;a&gt;，开启了&lt;code&gt;eBPF+golang&lt;&#x2F;code&gt;的总结性工作。此后陆续整理了一些关于&lt;code&gt;ebpf&lt;&#x2F;code&gt;的使用文章，同时项目也在逐步的推进。&lt;code&gt;eBPF&lt;&#x2F;code&gt;的实际落地有很大的挑战，但是最终还是找到了一些落地的场景。年底了，结合最近的调研工作，笔者整理了这篇文章。既算是对之前文章的呼应，也是对今年整理内容的总结。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;eBPF&lt;&#x2F;code&gt;能够提供一种切入服务细节的独特视角。本文即通过实例，对&lt;code&gt;golang&lt;&#x2F;code&gt;常见类型作为函数参数时进行解析，期望读者能够感受这一视角。需要说明的是，本文是基于&lt;code&gt;golang-1.16&lt;&#x2F;code&gt;来整理的。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>基于ebpf实现的gls</title>
        <published>2022-11-25T01:14:00+08:00</published>
        <updated>2022-11-25T01:14:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/ji-yu-ebpfshi-xian-de-gls/"/>
        <id>https://liyan-ah.github.io/ji-yu-ebpfshi-xian-de-gls/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;虽然&lt;code&gt;golang&lt;&#x2F;code&gt;并不推荐使用&lt;code&gt;goid&lt;&#x2F;code&gt;来构建&lt;code&gt;gls&lt;&#x2F;code&gt;(&lt;code&gt;goroutine local storage&lt;&#x2F;code&gt;)，仍然有着很多的实现&lt;code&gt;gls&lt;&#x2F;code&gt;并使用的尝试。&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jtolio&#x2F;gls&quot;&gt;github-gls&lt;&#x2F;a&gt;这里是一个常见的实现，基本表述了&lt;code&gt;golang&lt;&#x2F;code&gt;里&lt;code&gt;gls&lt;&#x2F;code&gt;的实现思路：获取&lt;code&gt;goid&lt;&#x2F;code&gt;，基于&lt;code&gt;goid&lt;&#x2F;code&gt;构建一个存储。本文中笔者尝试基于&lt;code&gt;ebpf&lt;&#x2F;code&gt;来构建一个&lt;code&gt;golang&lt;&#x2F;code&gt;的&lt;code&gt;gls&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;ji-ben-gong-neng&quot;&gt;基本功能&lt;&#x2F;h1&gt;
&lt;p&gt;本文中基于&lt;code&gt;ebpf&lt;&#x2F;code&gt;实现的&lt;code&gt;gls&lt;&#x2F;code&gt;具有如下功能：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;基于&lt;code&gt;goid&lt;&#x2F;code&gt;的存储。即&lt;code&gt;map[goid]=value&lt;&#x2F;code&gt;；&lt;&#x2F;li&gt;
&lt;li&gt;基于&lt;code&gt;goroutine&lt;&#x2F;code&gt;派生关系设置的&lt;code&gt;value&lt;&#x2F;code&gt;缺省值。即&lt;code&gt;map[goid=1]=121&lt;&#x2F;code&gt;，且&lt;code&gt;goid=1&lt;&#x2F;code&gt;派生&lt;code&gt;goid=2&lt;&#x2F;code&gt;，则&lt;code&gt;map[goid=2]=map[goid=1]=121&lt;&#x2F;code&gt;；&lt;br &#x2F;&gt;
本文建议参照&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;11&#x2F;04&#x2F;%E9%BB%91%E9%AD%94%E6%B3%95-ebpf-%E5%AF%B9%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%86%99%E5%85%A5&#x2F;#more&quot;&gt;黑魔法-ebpf-对用户空间数据的写入&lt;&#x2F;a&gt;进行理解。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>黑魔法--用 ebpf 构建用户空间数据的桥梁</title>
        <published>2022-11-04T18:00:00+08:00</published>
        <updated>2022-11-04T18:00:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/hei-mo-fa-ebpf-dui-yong-hu-kong-jian-shu-ju-de-xie-ru/"/>
        <id>https://liyan-ah.github.io/hei-mo-fa-ebpf-dui-yong-hu-kong-jian-shu-ju-de-xie-ru/</id>
        
        <summary type="html">&lt;p&gt;在之前的示例中，仅涉及到&lt;code&gt;ebpf&lt;&#x2F;code&gt;对用户空间数据的读取。工程性较强的如：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;10&#x2F;21&#x2F;ebpf%E9%87%87%E9%9B%86mysql%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E5%8F%8Aebpf%E5%AF%B9%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E7%9A%84%E6%80%9D%E8%80%83&#x2F;&quot;&gt;ebpf采集mysql请求信息及ebpf对应用安全的思考&lt;&#x2F;a&gt;也仅是通过&lt;code&gt;urpobe&lt;&#x2F;code&gt;采集用户空间的数据。本文介绍点&lt;code&gt;ebpf&lt;&#x2F;code&gt;的“黑魔法”：将用户空间数据的读取、用户空间数据的写入结合起来，成为用户空间数据交互的桥梁。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>ebpf采集mysql请求信息及ebpf对应用安全的思考</title>
        <published>2022-10-21T19:48:00+08:00</published>
        <updated>2022-10-21T19:48:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/ebpfcai-ji-mysqlqing-qiu-xin-xi-ji-ebpfdui-ying-yong-an-quan-de-si-kao/"/>
        <id>https://liyan-ah.github.io/ebpfcai-ji-mysqlqing-qiu-xin-xi-ji-ebpfdui-ying-yong-an-quan-de-si-kao/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文笔者继续介绍&lt;code&gt;ebpf&lt;&#x2F;code&gt; 的应用：使用&lt;code&gt;bpftrace&lt;&#x2F;code&gt;采集&lt;code&gt;mysql&lt;&#x2F;code&gt;连接信息，包括数据库地址、&lt;code&gt;db_name&lt;&#x2F;code&gt;、&lt;code&gt;user_name&lt;&#x2F;code&gt;。在展示采集操作的同时，附上对&lt;code&gt;ebpf&lt;&#x2F;code&gt;对云时代应用安全的一些思考。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;mu-biao&quot;&gt;目标&lt;&#x2F;h1&gt;
&lt;p&gt;使用&lt;code&gt;bpftrace&lt;&#x2F;code&gt;对一个运行中进程的&lt;code&gt;mysql&lt;&#x2F;code&gt;请求进行采集，目标采集内容包括数据库地址、&lt;code&gt;db_name&lt;&#x2F;code&gt;、&lt;code&gt;user_name&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>x86_64 寄存器传参方式</title>
        <published>2022-08-31T19:51:00+08:00</published>
        <updated>2022-08-31T19:51:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/x86-64-chuan-can-fang-shi/"/>
        <id>https://liyan-ah.github.io/x86-64-chuan-can-fang-shi/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/x86-64-chuan-can-fang-shi/">&lt;blockquote&gt;
&lt;p&gt;x86_64 架构下，寄存器传参时，仅 arg1-arg6 会通过寄存器进行，arg7+ 的参数，将会放到栈上进行。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;yan-zheng-dai-ma&quot;&gt;验证代码&lt;&#x2F;h1&gt;
&lt;pre&gt;&lt;code&gt;# 环境
├── arg.bt
├── arg_test
└── hello.c
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;&#x2F;&#x2F; hello.c, gcc -o arg_test hello.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void print_arg(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6,
               int arg7, int arg8){
    printf(&amp;quot;%d, %d, %d, %d, %d, %d, %d, %d
&amp;quot;, arg1, arg2, arg3, arg4, arg5,
           arg6, arg7, arg8);
    return;
}

int main(){
    print_arg(1,2,3,4,5,6,7,8);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;&#x2F;&#x2F; arg.bt
#!&#x2F;bin&#x2F;bpftrace

uprobe:.&#x2F;arg_test:print_arg
{
    printf(&amp;quot;== enter print_arg
&amp;quot;);
    printf(&amp;quot;arg1: %d
&amp;quot;, arg0);
    printf(&amp;quot;arg2: %d
&amp;quot;, arg1);
    printf(&amp;quot;arg3: %d
&amp;quot;, arg2);
    printf(&amp;quot;arg4: %d
&amp;quot;, arg3);
    printf(&amp;quot;arg5: %d
&amp;quot;, arg4);
    printf(&amp;quot;arg6: %d
&amp;quot;, arg5);
    printf(&amp;quot;arg7: %d
&amp;quot;, sarg0);
    printf(&amp;quot;arg8: %d
&amp;quot;, sarg1);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;zhi-xing-jie-guo&quot;&gt;执行结果&lt;&#x2F;h1&gt;
&lt;pre&gt;&lt;code&gt;sudo bpftrace arg.bt
Attaching 1 probe...
== enter print_arg
arg1: 1
arg2: 2
arg3: 3
arg4: 4
arg5: 5
arg6: 6
arg7: 7
arg8: 8

.&#x2F;arg_test
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;can-zhao&quot;&gt;参照&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;wiki.cdot.senecacollege.ca&#x2F;wiki&#x2F;X86_64_Register_and_Instruction_Quick_Start&quot;&gt;X86 64 Register and Instruction Quick Start&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>bpftrace 无侵入遍历golang链表</title>
        <published>2022-07-22T21:48:00+08:00</published>
        <updated>2022-07-22T21:48:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/bpftrace-zhui-zong-uprobe/"/>
        <id>https://liyan-ah.github.io/bpftrace-zhui-zong-uprobe/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;bpftrace&lt;&#x2F;code&gt; 基于 &lt;code&gt;bcc&lt;&#x2F;code&gt; 进行开发的工具，语法简洁、功能强大。用其分析&lt;code&gt;Linux&lt;&#x2F;code&gt; 环境下的程序会很方便。本文构造了一个入参为链表头节点的函数使用场景，通过使用&lt;code&gt;bpftrace&lt;&#x2F;code&gt;无侵入遍历链表成员的方式，介绍&lt;code&gt;bpftrace&lt;&#x2F;code&gt; &lt;code&gt;attach uprobe&lt;&#x2F;code&gt; 的使用。更多使用说明见:&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bpftrace&#x2F;blob&#x2F;master&#x2F;docs&#x2F;reference_guide.md&quot;&gt;bpftrace官网使用文档&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>golang 常见类型字节数</title>
        <published>2022-06-06T14:36:00+08:00</published>
        <updated>2022-06-06T14:36:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/golang-chang-jian-lei-xing-zi-jie-shu/"/>
        <id>https://liyan-ah.github.io/golang-chang-jian-lei-xing-zi-jie-shu/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ebpf&lt;&#x2F;code&gt; 分析&lt;code&gt;golang&lt;&#x2F;code&gt;程序时，离不开对参数大小的判断。这里列出来一些基本类型的大小，并通过汇编对应验证函数的方式来肯定判断结果。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;xin-xi&quot;&gt;信息&lt;&#x2F;h1&gt;
&lt;p&gt;这里列出基本类型及其作为参数传递时，占用的空间大小如下表。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;&#x2F;th&gt;&lt;th&gt;长度&lt;&#x2F;th&gt;&lt;th&gt;说明&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;指针&lt;&#x2F;td&gt;&lt;td&gt;8B&lt;&#x2F;td&gt;&lt;td&gt;64位机为 8Byte, 32位机位4Byte&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;context&lt;&#x2F;td&gt;&lt;td&gt;16B&lt;&#x2F;td&gt;&lt;td&gt;interface 类型。其中，前8B是类型信息，后8B是对象的指针信息&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;interface&lt;&#x2F;td&gt;&lt;td&gt;16B&lt;&#x2F;td&gt;&lt;td&gt;2 个指针，详见&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;draveness.me&#x2F;golang&#x2F;docs&#x2F;part2-foundation&#x2F;ch04-basic&#x2F;golang-interface&#x2F;&quot;&gt;draveness-go-interface&lt;&#x2F;a&gt;，或者 runtime&#x2F;runtime2.go iface&#x2F;eface 定义&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;int64&lt;&#x2F;td&gt;&lt;td&gt;8B&lt;&#x2F;td&gt;&lt;td&gt;-&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;int&lt;&#x2F;td&gt;&lt;td&gt;8B&lt;&#x2F;td&gt;&lt;td&gt;64位机为 8Byte, 32位机位4Byte&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;string&lt;&#x2F;td&gt;&lt;td&gt;16B&lt;&#x2F;td&gt;&lt;td&gt;8B 地址 + 8B string长度&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;slice&lt;&#x2F;td&gt;&lt;td&gt;24B&lt;&#x2F;td&gt;&lt;td&gt;8B地址 + 8B slice 成员数量 + 8B slice capability&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;func&lt;&#x2F;td&gt;&lt;td&gt;8B&lt;&#x2F;td&gt;&lt;td&gt;func 作为函数参数时，传递的是 func 的地址&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;需要注意的是，作为函数参数传递时，golang会对参数按照 8B 进行对齐。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>challenges of bpf tracing go</title>
        <published>2022-04-19T14:33:00+08:00</published>
        <updated>2022-04-19T14:33:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/challenges-of-bpf-tracing-go/"/>
        <id>https://liyan-ah.github.io/challenges-of-bpf-tracing-go/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/challenges-of-bpf-tracing-go/">&lt;blockquote&gt;
&lt;p&gt;goroutine 开销为 2KB（最少），对比线程 2MB 的开销，有明显的优势。当goroutine 栈资源不足时，runtime 会将整个 goroutine stack 拷贝、重新分配空间。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Instead of using a thread for every goroutine, Go multiplexes goroutines across multiple threads (&quot;M:N scheduling&quot;). So instead of each thread having a default 2MB stack, each goroutine has a tiny 2KB stack that&#x27;s managed by the runtime instead of the operating system. When the program needs to grow the stack for a goroutine and there&#x27;s not enough room, the runtime copies the entire goroutine&#x27;s stack to another place in memory where it has enough room to expand.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.0x74696d.com&#x2F;posts&#x2F;challenges-of-bpf-tracing-go&#x2F;&quot;&gt;Challenges of BPF Tracing Go&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>centos 安装docker并构建golang镜像</title>
        <published>2022-03-04T15:00:00+08:00</published>
        <updated>2022-03-04T15:00:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/centos-an-zhuang-dockerbing-gou-jian-golangjing-xiang/"/>
        <id>https://liyan-ah.github.io/centos-an-zhuang-dockerbing-gou-jian-golangjing-xiang/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;工作需要（抛弃了kubectl搞一套环境的方法），需要在centos8上构建一套docker镜像并运行golang程序。这里记录下docker安装及golang程序打包镜像的过程。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>eBPF及其对可观测的意义【译文】</title>
        <published>2022-03-02T16:34:00+08:00</published>
        <updated>2022-03-02T16:34:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/ebpfji-qi-dui-ke-guan-ce-de-yi-yi-yi-wen/"/>
        <id>https://liyan-ah.github.io/ebpfji-qi-dui-ke-guan-ce-de-yi-yi-yi-wen/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近在做 eBPF 的技术调研。看到很多对 eBPF 的介绍。为了加强对内容的理解，笔者选择了其中的一篇尝试翻译。本着便于笔者自己理解的角度，很多内容加入了自己的一些理解，因此并不能算是严格意义上的“翻译”。文章涉及了 eBPF 的介绍、优势、不足，算是一篇 eBPF 的很好的介绍。现在把它贴上来，算是纪念自己的第一篇“译文”。&lt;br &#x2F;&gt;
原文地址：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;newrelic.com&#x2F;blog&#x2F;best-practices&#x2F;what-is-ebpf&quot;&gt;What Is eBPF and Why Does It Matter for Observability?&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>centos 构建 local-k8s</title>
        <published>2022-02-24T17:27:00+08:00</published>
        <updated>2022-02-24T17:27:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/centos-gou-jian-k8s-ji-qun/"/>
        <id>https://liyan-ah.github.io/centos-gou-jian-k8s-ji-qun/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;工作原因，需要安装一个 local-k8s。中间碰了很多坑，做个记录。
环境：Linux test 4.18.0-193.el8.x86_64&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
</feed>
