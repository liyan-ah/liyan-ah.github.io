<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title>李岩的博客 - effective-rust</title>
    <subtitle>努力做个程序员</subtitle>
    <link rel="self" type="application/atom+xml" href="https://liyan-ah.github.io/tags/effective-rust/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://liyan-ah.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-09-08T16:35:05+08:00</updated>
    <id>https://liyan-ah.github.io/tags/effective-rust/atom.xml</id>
    <entry xml:lang="zh-CN">
        <title>【译文&#x2F;effective-rust】第 30 条：不仅仅是单测</title>
        <published>2024-09-08T16:35:05+08:00</published>
        <updated>2024-09-08T16:35:05+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/write-more-than-unit-tests/"/>
        <id>https://liyan-ah.github.io/write-more-than-unit-tests/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/write-more-than-unit-tests/">&lt;blockquote&gt;
&lt;p&gt;“所有的公司都拥有测试环境。但只有那些幸运的公司拥有独立于测试环境的生产环境。” —— @FearlessSon&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;和大多数其他的现代编程语言一样，Rust 也包含一些便于&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch11-00-testing.html&quot;&gt;编写测试&lt;&#x2F;a&gt;的特性。借助这些特性，你可以将单测和代码共存。而通过测试，可以提升代码运行准确性的信心。&lt;&#x2F;p&gt;
&lt;p&gt;这并非是兜售测试重要性的文章。从测试最基本功能来说，如果代码缺少了测试，它很可能并非如我们所希望的那样运行。本条目是在你已经建立了&lt;strong&gt;为代码编写测试&lt;&#x2F;strong&gt;这一信念的基础上展开的。&lt;&#x2F;p&gt;
&lt;p&gt;单元测试（unit tests）以及集成测试（integration tests）是测试领域内的两大重要成员。在接下来的两节内将会介绍。但是，Rust 工具链，也包括它的扩展，允许多种多样的测试形式。本条目将会介绍它们的基本使用流程及应用场景。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dan-yuan-ce-shi&quot;&gt;单元测试&lt;&#x2F;h2&gt;
&lt;p&gt;Rust 代码中最常见的测试类型是单元测试：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F; ... (code defining `nat_subtract*` functions for natural
&#x2F;&#x2F;      number subtraction)

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_nat_subtract() {
        assert_eq!(nat_subtract(4, 3).unwrap(), 1);
        assert_eq!(nat_subtract(4, 5), None);
    }

    #[should_panic]
    #[test]
    fn test_something_that_panics() {
        nat_subtract_unchecked(4, 5);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这段单测示例体现了 Rust 所有单测都会有的形式：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;使用模块对单测函数进行封装。&lt;&#x2F;li&gt;
&lt;li&gt;每个单测都会使用&lt;code&gt;#[test]&lt;&#x2F;code&gt;属性来进行标志。&lt;&#x2F;li&gt;
&lt;li&gt;用来测试的模块使用&lt;code&gt;#[cfg(test)]&lt;&#x2F;code&gt;进行声明，所以单测的代码仅会在测试时生效。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;示例也展示了一些仅在特定测试中才会出现的形式：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;这里的测试代码放置在单独的模块里，模块名一般为&lt;code&gt;tests&lt;&#x2F;code&gt;或者&lt;code&gt;test&lt;&#x2F;code&gt;。这个模块可以和逻辑代码放置在一起，或者放置在单独的&lt;em&gt;tests.rs&lt;&#x2F;em&gt;文件里。放置在单独的文件里可以让人更加便捷的区分代码是用来测试的，还是用于一般的功能逻辑。&lt;&#x2F;li&gt;
&lt;li&gt;测试的模块可以使用一个通配符&lt;code&gt;use super::*&lt;&#x2F;code&gt;来将父模块的所有依赖都声明到测试模块里。这种操作可以让编写测试代码更加方便（同时依据&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_4&#x2F;item23-wildcard.html&quot;&gt;第 23 条&lt;&#x2F;a&gt;来说，通配符的引入是一种要规避的操作）。&lt;&#x2F;li&gt;
&lt;li&gt;在模块的一般可达性规则下，单测可以使用所有父模块里包含的内容，无论是否声明为公共的。基于单测对内部功能可访问的特点，可以对代码进行“开箱”测试。&lt;&#x2F;li&gt;
&lt;li&gt;测试代码使用&lt;code&gt;expect()&lt;&#x2F;code&gt;或者&lt;code&gt;unwrap()&lt;&#x2F;code&gt;来标志其希望的结果。显然，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_3&#x2F;item18-panic.html&quot;&gt;第 18 条&lt;&#x2F;a&gt;中声明的规则并不适用这些单测的代码。单测中需要使用&lt;code&gt;panic!&lt;&#x2F;code&gt;来标注失败的结果。同样的，测试的代码中也会使用&lt;code&gt;assert_eq!&lt;&#x2F;code&gt;来校验期待的值，并且会在失败时抛出&lt;code&gt;panic&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;测试代码中使用了一个函数，该函数在一些非法的输入下会造成&lt;code&gt;panic&lt;&#x2F;code&gt;。为了校验该函数的这一功能是否生效，单测的函数中使用了&lt;code&gt;#[should_panic]&lt;&#x2F;code&gt;特性。这一特性在需要测试一个内部函数且希望保持这个函数的各校验规则不发生改变，或者测试一个公共的函数且由于一些原因需要忽略&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_3&#x2F;item18-panic.html&quot;&gt;第 18 条&lt;&#x2F;a&gt;中的建议。（这样的函数需要在它的注释文档中有“Panics”小节，就像&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_5&#x2F;item27-document-public-interfaces.html&quot;&gt;第 27 条&lt;&#x2F;a&gt;中描述的。）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_5&#x2F;item27-document-public-interfaces.html&quot;&gt;第 27 条&lt;&#x2F;a&gt;中建议不要对已经通过类型表述出的内容。同样的，也不需要对已经由类型进行约束的内容进行测试。如果你的&lt;code&gt;enum&lt;&#x2F;code&gt;类型派生出了不在声明列表中罗列的变量，你可能遇到了比单测失败更加严重的问题。&lt;&#x2F;p&gt;
&lt;p&gt;然而，如果你的代码依赖了一些依赖库中的独特功能，对这些功能准备基础的单测会很有用。这里的单测目的并非是重复依赖中已经具备的功能测试，而是尽量早地暴露依赖的包依赖的这些功能发生了变更的风险 —— 尤其是公共的接口约定发生了变化，通常应当通过版本号来表明（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;semver.html&quot;&gt;第 21 条&lt;&#x2F;a&gt;）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ji-cheng-ce-shi&quot;&gt;集成测试&lt;&#x2F;h2&gt;
&lt;p&gt;Rust 项目中另一种常用到的测试模式是：&lt;em&gt;集成测试&lt;&#x2F;em&gt;（integration tests），测试通常被放置在&lt;code&gt;tests&#x2F;&lt;&#x2F;code&gt;目录下。这个目录下的每个文件都会作为一个单独的测试程序运行，每个测试程序都会执行其包含的所有以&lt;code&gt;#[test]&lt;&#x2F;code&gt;标志的测试函数。&lt;&#x2F;p&gt;
&lt;p&gt;集成测试没有访问包内部内容的权限，因此集成测试仅能覆盖包的公共 API。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-dang-ce-shi&quot;&gt;文档测试&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_5&#x2F;item27-document-public-interfaces.html&quot;&gt;第 27 条&lt;&#x2F;a&gt;描述了在注释中包含一小段代码的示例，通常是为了说明特定的公共 API 的使用方式。每段这样的代码都包含在一个隐式的&lt;code&gt;fn main() { ... }&lt;&#x2F;code&gt;函数中，并且可以在&lt;code&gt;cargo test&lt;&#x2F;code&gt;时被执行。这是一种高效的代码添加测试用例的方法，一般被称为&lt;em&gt;文档测试&lt;&#x2F;em&gt;（doc tests）。每个类似的测试都可以通过&lt;code&gt;cargo test --doc &amp;lt;item-name&amp;gt;&lt;&#x2F;code&gt;的方式来选择性的执行。&lt;&#x2F;p&gt;
&lt;p&gt;定期的通过 CI 系统（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;ci.html&quot;&gt;第 32 条&lt;&#x2F;a&gt;）来执行这些测试可以确保代码不会离包中期望提供的 API 太远。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dai-ma-shi-li&quot;&gt;代码示例&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_5&#x2F;item27-document-public-interfaces.html&quot;&gt;第 27 条&lt;&#x2F;a&gt;也描述了为公共接口提供示例代码的实践。在&lt;code&gt;examples&#x2F;&lt;&#x2F;code&gt;目录下的每个 Rust 文件（或者&lt;code&gt;examples&lt;&#x2F;code&gt;目录下每个子目录中的&lt;code&gt;main.rs&lt;&#x2F;code&gt;文件）都可以通过&lt;code&gt;cargo run --example &amp;lt;name&amp;gt;&lt;&#x2F;code&gt;或者&lt;code&gt;cargo test --example &amp;lt;name&amp;gt;&lt;&#x2F;code&gt;的方式来作为独立的可执行文件运行。&lt;&#x2F;p&gt;
&lt;p&gt;这些程序仅能访问包中的公共接口，并且可以说明这些公共接口的使用方式。示例代码并非被设计为测试代码（没有&lt;code&gt;#[test]&lt;&#x2F;code&gt;，没有&lt;code&gt;[cfg(test)]&lt;&#x2F;code&gt;的标注），而且由于处于一些不起眼的角落，它们并不适合放置代码 —— 尤其是，它们并不在&lt;code&gt;cargo test&lt;&#x2F;code&gt;时默认执行。&lt;&#x2F;p&gt;
&lt;p&gt;尽管如此，CI 系统（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;ci.html&quot;&gt;第 32 条&lt;&#x2F;a&gt;）构建并且运行这些示例代码（通过&lt;code&gt;cargo test --examples&lt;&#x2F;code&gt;）仍然是一个很好的实践。通过执行这些代码，可以为那些会影响大多数用户的接口提供一个很好的回归校验机制。特别地，如果你的示例揭示了接口使用的一般方式，那么示例运行的失败往往意味着存在如下的错误：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;如果这是个高超的错误，它可能会影响很多用户 —— 示例中的代码将会被很多用户复制、粘贴或者参照。&lt;&#x2F;li&gt;
&lt;li&gt;如果公共接口发生了变更，那么这些示例也需要参照最新的接口定义来实现。接口的改变往往意味着不兼容。所以当包被发布时，版本号需要随着调整以说明这是个不兼容的升级（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;semver.html&quot;&gt;第 21 条&lt;&#x2F;a&gt;）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;用户复制、粘贴测试代码的行为意味着示例代码和测试代码的形式有很大的不同。如&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_3&#x2F;item18-panic.html&quot;&gt;第 18 条&lt;&#x2F;a&gt;中描述的一样，你可以避免对 Results 进行 unwrap() 使用，从而为用户提供一个很好的参照。同样的，在每个示例代码的&lt;code&gt;main()&lt;&#x2F;code&gt;函数中返回类似&lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;&#x2F;code&gt;的结果，并且在内部使用&lt;code&gt;?&lt;&#x2F;code&gt;符号来组织代码（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item3-transform.html&quot;&gt;第 3 条&lt;&#x2F;a&gt;）也是一种很好的行为。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ji-zhun-ce-shi&quot;&gt;基准测试&lt;&#x2F;h2&gt;
&lt;p&gt;[第 20 条]试图说明极致的代码性能优化并非总是必要的。尽管如此，有时性能肯定时很关键的，并且在这种情况下，衡量以及追踪代码的性能变化是很好的实践。具备定期运行的&lt;em&gt;基准测试&lt;&#x2F;em&gt;（benchmarks）（比如，作为 CI 系统的一部分，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;ci.html&quot;&gt;第 32 条&lt;&#x2F;a&gt;）允许你发觉代码或者工具链的变更可以如何影响代码的性能。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;[cargo bench]&lt;&#x2F;code&gt;命令可以运行重复执行特定操作的测试代码，并且计算出这个操作的平均耗时。在撰写本文时，Rust 对基准测试的支持还不太稳定，所以基准测试相关的指令需要通过&lt;code&gt;cargo +nightly bench&lt;&#x2F;code&gt;的方式来执行。（Rust 不稳定的特性，包括本文中使用的&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;unstable-book&#x2F;library-features&#x2F;test.html&quot;&gt;test&lt;&#x2F;a&gt;特性，都描述在 Rust &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;unstable-book&#x2F;the-unstable-book.html&quot;&gt;Unstable Book&lt;&#x2F;a&gt;中。）&lt;&#x2F;p&gt;
&lt;p&gt;然而，这里存在着编译器给出错误结果的风险，尤其是当你将操作约束在很简单的代码时。考虑如下一个简单的算数函数：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;pub fn factorial(n: u128) -&amp;gt; u128 {
    match n {
        0 =&amp;gt; 1,
        n =&amp;gt; n * factorial(n - 1),
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这段代码的一个简单的基准测试实现是：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;#![feature(test)]
extern crate test;

#[bench]
fn bench_factorial(b: &amp;amp;mut test::Bencher) {
    b.iter(|| {
        let result = factorial(15);
        assert_eq!(result, 1_307_674_368_000);
    });
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出了一段奇妙的结果：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;test bench_factorial             ... bench:           0 ns&#x2F;iter (+&#x2F;- 0)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于在测试过程中使用固定的输入以及很少的代码指令，编译器可能会对迭代进行优化并且直接输出计算结果。这就将会导致不切实际的测试结论。&lt;&#x2F;p&gt;
&lt;p&gt;使用 &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;hint&#x2F;fn.black_box.html&quot;&gt;std::hint::black_box&lt;&#x2F;a&gt; 可以解决这一问题。这是一个标志函数，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rfcs&#x2F;2360-bench-black-box.html&quot;&gt;编辑器识别后将不&lt;&#x2F;a&gt;对其进行优化。&lt;&#x2F;p&gt;
&lt;p&gt;上述基准测试可以变更为如下形式：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;#[bench]
fn bench_factorial(b: &amp;amp;mut test::Bencher) {
    b.iter(|| {
        let result = factorial(std::hint::black_box(15));
        assert_eq!(result, 1_307_674_368_000);
    });
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;给出了如下更加接近实际的结果：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;test blackboxed::bench_factorial ... bench:          16 ns&#x2F;iter (+&#x2F;- 3)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust.godbolt.org&#x2F;&quot;&gt;Godbolt 编辑资源管理器&lt;&#x2F;a&gt;也可以通过展示实际的机器码的方式来辅助测试，这样就能让实际执行的优化后的字节码变得清晰以确认是否过度优化而不能得到实际的结果。&lt;&#x2F;p&gt;
&lt;p&gt;最后，如果你为 Rust 代码准备了基准测试，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;criterion&quot;&gt;criterion&lt;&#x2F;a&gt;包可能提供了&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;test&#x2F;bench&#x2F;struct.Bencher.html&quot;&gt;test::bench::Bencher&lt;&#x2F;a&gt;的替代品，而且使用起来更加便捷（可以在稳定的 Rust 工具链上运行），功能也更多（支持结果的数据统计及图表）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mo-hu-ce-shi&quot;&gt;模糊测试&lt;&#x2F;h2&gt;
&lt;p&gt;模糊测试（fuzzy testing）是将代码暴露在随机输入中以期能够发现错误，尤其导致异常的场景，的测试方法。从技术校验的角度来说它已经很重要了，而当你的输入会被其他人填充或者攻击时，它将会显得更加重要 —— &lt;strong&gt;所以如果你的代码输入可能暴露给潜在的攻击者时，你应当使用模糊测试&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;从历史上来看，C&#x2F;C++ 代码通过模糊测试发现的往往时内存安全问题，通常会通过结合模糊测试与内存访问模式的运行时结合来检测（比如&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;AddressSanitizer.html&quot;&gt;AddressSanitizer&lt;&#x2F;a&gt;或者&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;ThreadSanitizer.html&quot;&gt;ThreadSanitizer&lt;&#x2F;a&gt;）。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 对其中的一些（但并非全部）内存安全问题免疫，尤其是未引入&lt;code&gt;unsafe&lt;&#x2F;code&gt;的代码时（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_3&#x2F;item16-unsafe.html&quot;&gt;第 16 条&lt;&#x2F;a&gt;）。然而，Rust 并不能杜绝全部的错误，触发&lt;code&gt;panic!&lt;&#x2F;code&gt;（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_3&#x2F;item18-panic.html&quot;&gt;第 18 条&lt;&#x2F;a&gt;）的代码仍可能引发导致拒绝服务攻击（denial-of-service，DOS）。&lt;&#x2F;p&gt;
&lt;p&gt;模糊测试的最佳实践是以&lt;em&gt;覆盖率引导&lt;&#x2F;em&gt;：测试的基础设施监控代码的哪些部分被执行，随机更改输入直至能够触发新的代码路径。“&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lcamtuf.coredump.cx&#x2F;afl&#x2F;&quot;&gt;American fuzzy lop&lt;&#x2F;a&gt;”（AFL）是其中的佼佼者。但是近些年来，类似的功能已经被引入了 LLVM 的工具链，比如&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LibFuzzer.html&quot;&gt;libFuzzer&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 编译器是在 LLVM 的基础上构建的，因此&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-fuzz&#x2F;cargo-fuzz&quot;&gt;cargo-fuzz&lt;&#x2F;a&gt;自然地为 Rust 引入了&lt;code&gt;libFuzzer&lt;&#x2F;code&gt;（仅在部分平台上可用）。&lt;&#x2F;p&gt;
&lt;p&gt;模糊测试的首要要求是确定代码的入口点，该入口点需要采用（或者可以适应）任意字节的数据作为输入：&lt;&#x2F;p&gt;
&lt;div class=&quot;ferris&quot;&gt;&lt;img src=&quot;..&#x2F;images&#x2F;ferris&#x2F;not_desired_behavior.svg&quot; width=&quot;75&quot; height=&quot;75&quot; &#x2F;&gt;&lt;&#x2F;div&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Determine if the input starts with &amp;quot;FUZZ&amp;quot;.
pub fn is_fuzz(data: &amp;amp;[u8]) -&amp;gt; bool {
    if data.len() &amp;gt;= 3 &#x2F;* oops *&#x2F;
    &amp;amp;&amp;amp; data[0] == b&amp;#39;F&amp;#39;
    &amp;amp;&amp;amp; data[1] == b&amp;#39;U&amp;#39;
    &amp;amp;&amp;amp; data[2] == b&amp;#39;Z&amp;#39;
    &amp;amp;&amp;amp; data[3] == b&amp;#39;Z&amp;#39;
    {
        true
    } else {
        false
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当目标入口点确定后，Rust &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-fuzz.github.io&#x2F;book&#x2F;&quot;&gt;Fuzz Book&lt;&#x2F;a&gt;给出了如何启动测试的说明。它的核心是一个小型的驱动程序，会将目标入口点连接到模糊测试的基础设施上：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F; fuzz&#x2F;fuzz_targets&#x2F;target1.rs file
#![no_main]
use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &amp;amp;[u8]| {
    let _ = somecrate::is_fuzz(data);
});
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;运行&lt;code&gt;cargo +nightly fuzz run target1&lt;&#x2F;code&gt;将会持续使用随机数据来执行模糊测试的目标函数，直至异常出现。上述示例中，错误将被立即发现：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1607525774
INFO: Loaded 1 modules: 1624 [0x108219fa0, 0x10821a5f8),
INFO: Loaded 1 PC tables (1624 PCs): 1624 [0x10821a5f8,0x108220b78),
INFO:        9 files found in fuzz&#x2F;corpus&#x2F;target1
INFO: seed corpus: files: 9 min: 1b max: 8b total: 46b rss: 38Mb
#10	INITED cov: 26 ft: 26 corp: 6&#x2F;22b exec&#x2F;s: 0 rss: 39Mb
thread panicked at &amp;#39;index out of bounds: the len is 3 but the index is 3&amp;#39;,
     testing&#x2F;src&#x2F;lib.rs:77:12
stack backtrace:
   0: rust_begin_unwind
             at &#x2F;rustc&#x2F;f77bfb7336f2&#x2F;library&#x2F;std&#x2F;src&#x2F;panicking.rs:579:5
   1: core::panicking::panic_fmt
             at &#x2F;rustc&#x2F;f77bfb7336f2&#x2F;library&#x2F;core&#x2F;src&#x2F;panicking.rs:64:14
   2: core::panicking::panic_bounds_check
             at &#x2F;rustc&#x2F;f77bfb7336f2&#x2F;library&#x2F;core&#x2F;src&#x2F;panicking.rs:159:5
   3: somecrate::is_fuzz
   4: _rust_fuzzer_test_input
   5: ___rust_try
   6: _LLVMFuzzerTestOneInput
   7: __ZN6fuzzer6Fuzzer15ExecuteCallbackEPKhm
   8: __ZN6fuzzer6Fuzzer6RunOneEPKhmbPNS_9InputInfoEbPb
   9: __ZN6fuzzer6Fuzzer16MutateAndTestOneEv
  10: __ZN6fuzzer6Fuzzer4LoopERNSt3__16vectorINS_9SizedFileENS_
      16fuzzer_allocatorIS3_EEEE
  11: __ZN6fuzzer12FuzzerDriverEPiPPPcPFiPKhmE
  12: _main
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;导致上述错误的测试数据也给出了。&lt;&#x2F;p&gt;
&lt;p&gt;一般来说，模糊测试并不能如此快地发现错误，因此将模糊测试作为 CI 流程中的一部分也是没有意义的。模糊测试的不确定性及随之而来的计算成本意味着你需要考虑如何开展以及何时开展模糊测试 —— 可能仅需要在新的发布版本或者主要变更发生时才运行，或者仅运行确定性的时间&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;你也可以通过存储和重用先前模糊测试程序已找到用来触发新的代码路径的语料库的方式来加速模糊测试的执行。这将有助于后续的模糊测试过程将时间放在尝试新的输入上，而非重新测试以前访问过的代码路径。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ce-shi-de-jian-yi&quot;&gt;测试的建议&lt;&#x2F;h2&gt;
&lt;p&gt;一般性的建议也适用于 Rust 项目中：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;由于测试是需要持续进行的，&lt;strong&gt;每次变更后都需要在 CI 中执行单测&lt;&#x2F;strong&gt;（除了模糊测试）。&lt;&#x2F;li&gt;
&lt;li&gt;当你在修复一个错误时，&lt;strong&gt;在修复前，准备一个能反映错误的测试用例&lt;&#x2F;strong&gt;。这样当你完成错误的修复时，就可以通过测试用例的执行来说名修复效果。并且在未来不会重新引入。&lt;&#x2F;li&gt;
&lt;li&gt;如果你的包中包含了某些功能（[第 26 条]），&lt;strong&gt;对所有可能的功能组合都要进行测试&lt;&#x2F;strong&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;更一般性的，如果你的包中包含了任何特殊的配置，（比如，&lt;code&gt;#[cfg(target_os=&quot;windows&quot;)]&lt;&#x2F;code&gt;），&lt;strong&gt;每种包含了独特配置的平台上的测试都需要运行&lt;&#x2F;strong&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这些建议包含了很多不同类型的测试，在项目中应当选择那些最有价值的测试。&lt;&#x2F;p&gt;
&lt;p&gt;如果你有很多测试的代码并且会将你的包推送到&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;&quot;&gt;crates.io&lt;&#x2F;a&gt;中，那么就需要考虑下哪些测试项发布后是有意义的。一般地，&lt;code&gt;cargo&lt;&#x2F;code&gt;项目中会包含单元测试、集成测试、基准测试以及代码示例（但是并没有包含模糊测试，因为&lt;code&gt;cargo-fuzz&lt;&#x2F;code&gt;工具会将模糊测试的内容放置在包的子目录中）等等远超一般用户使用所需要的测试项。如果某些测试项并非是必须的，你可以&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;manifest.html#the-exclude-and-include-fields&quot;&gt;移除&lt;&#x2F;a&gt;一些测试项或者将这些测试项（尤其是行为性的测试）移入单独的测试包中。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xu-yao-zhu-yi-de-dian&quot;&gt;需要注意的点&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;编写单元测试来达到全面测试的目的，包括仅包含内部代码的测试。通过&lt;code&gt;cargo test&lt;&#x2F;code&gt;来运行它们。&lt;&#x2F;li&gt;
&lt;li&gt;编写集成测试代码来测试公共的接口。通过&lt;code&gt;cargo test&lt;&#x2F;code&gt;来运行它们。&lt;&#x2F;li&gt;
&lt;li&gt;编写文档测试来校验公共接口的调用方式。通过&lt;code&gt;cargo test&lt;&#x2F;code&gt;来调用它们。&lt;&#x2F;li&gt;
&lt;li&gt;编写示例代码来完整的说明如何使用包中的公共 API。通过&lt;code&gt;cargo test --exmaples&lt;&#x2F;code&gt;或者&lt;code&gt;cargo run --example &amp;lt;name&amp;gt;&lt;&#x2F;code&gt;的方式来运行它们。&lt;&#x2F;li&gt;
&lt;li&gt;如果代码对性能有很明确的要求，编写基准测试来确认代码的性能表现。通过&lt;code&gt;cargo bench&lt;&#x2F;code&gt;来执行它们。&lt;&#x2F;li&gt;
&lt;li&gt;如果代码会暴露在未被信任的输入中，编写模糊测试来确认对输入的参数的约束。通过&lt;code&gt;cargo fuzz&lt;&#x2F;code&gt;来（持续地）运行它们。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;zhu-shi&quot;&gt;注释&lt;&#x2F;h3&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;如果你的代码是一个被广泛运用的开源包，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;google.github.io&#x2F;oss-fuzz&#x2F;getting-started&#x2F;accepting-new-projects&#x2F;&quot;&gt;Google OSS-Fuzz program&lt;&#x2F;a&gt;可以为你的项目进行模糊测试。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;原文&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;testing.html&quot;&gt;点这里&lt;&#x2F;a&gt;查看&lt;&#x2F;p&gt;
&lt;!-- 参考链接 --&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>【译文&#x2F;effective-rust】第 29 条：遵循 Clippy 的建议</title>
        <published>2024-09-08T16:30:36+08:00</published>
        <updated>2024-09-08T16:30:36+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/listen-to-clippy/"/>
        <id>https://liyan-ah.github.io/listen-to-clippy/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/listen-to-clippy/">&lt;blockquote&gt;
&lt;p&gt;“看起来你在写信。需要什么帮助么？” —— &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Office_Assistant&quot;&gt;Microsoft Clippit&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;use-tools.html&quot;&gt;第 31 条&lt;&#x2F;a&gt;会描述了 Rust 工具箱中一些很有用的工具。但是其中一个特别有用且重要的工具值的在这里进行进行单独的介绍：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust-clippy#clippy&quot;&gt;Clippy&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;Clippy 是 Cargo 的一个附加模块（通过&lt;code&gt;cargo clippy&lt;&#x2F;code&gt;的方式调用）。它可以生成涵盖多种类别的&lt;code&gt;warining&lt;&#x2F;code&gt;信息：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;正确性：提示常见的编程错误。&lt;&#x2F;li&gt;
&lt;li&gt;风格：提示不完全符合 Rust 标准风格的代码结构。&lt;&#x2F;li&gt;
&lt;li&gt;简洁性：指出能让代码更加简洁的可行变更。&lt;&#x2F;li&gt;
&lt;li&gt;性能：提示能避免无效处理或者内存分配的可选项。&lt;&#x2F;li&gt;
&lt;li&gt;可读性：给出能让代码更易读或者更易懂的建议。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;比如，如下这段代码编译是正常的：&lt;&#x2F;p&gt;
&lt;div class=&quot;ferris&quot;&gt;&lt;img src=&quot;..&#x2F;images&#x2F;ferris&#x2F;not_desired_behavior.svg&quot; width=&quot;75&quot; height=&quot;75&quot; &#x2F;&gt;&lt;&#x2F;div&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;pub fn circle_area(radius: f64) -&amp;gt; f64 {
    let pi = 3.14;
    pi * radius * radius
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是 Clippy 会指出这里对 π 的近似赋值是没必要且不准确的：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;error: approximate value of `f{32, 64}::consts::PI` found
 --&amp;gt; src&#x2F;main.rs:5:18
  |
5 |         let pi = 3.14;
  |                  ^^^^
  |
  = help: consider using the constant directly
  = help: for further information visit
    https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;master&#x2F;index.html#approx_constant
  = note: `#[deny(clippy::approx_constant)]` on by default
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;链接中的文档解释了问题并且给出了优化代码的方式。上述示例可调整为：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;pub fn circle_area(radius: f64) -&amp;gt; f64 {
    std::f64::consts::PI * radius * radius
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;正如示例中所展示的，每个 Clippy 警告都会伴随着一个网页的链接来描述问题。链接的网页中会说明为什么目标代码会被认为是不恰当的。这些说明很重要：它们的存在使得你可以自行判断采纳这些建议或者由于特殊的原因而忽略它们。有的时候，说明文本中还会描述一些校验器的已知问题，这些描述会解释一些令人困惑的误报。&lt;&#x2F;p&gt;
&lt;p&gt;如果你认定一些警告信息和自己的代码没有关系，你可以通过添加(#[allow(clippy::some_line)])来忽略关联代码的报错，或者在包的顶层（top level）添加(#![allow(clipy::some_lint)])来忽略整个包中的警告信息。通常情况下，建议调整目标代码而非花费很多时间来确认警告关联的代码是否是一个罕见的误报。&lt;&#x2F;p&gt;
&lt;p&gt;无论你选择了修复或者忽略掉这些警告信息，请&lt;strong&gt;确保你的代码中没有 Clippy-warning 的信息&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;这样，当新的警告信息出现时 —— 无论是由于代码发生了调整还是 Clippy 升级后包含了新的校验信息 —— 我们就能够及时的关注到。Clippy 也应当被纳入你的持续集成系统中（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;ci.html&quot;&gt;第 32 条&lt;&#x2F;a&gt;）。&lt;&#x2F;p&gt;
&lt;p&gt;Clippy 的警告信息在你学习 Rust 时特别重要，因为它们可以揭示那些被你忽略的细节，并帮助你熟悉 Rust 的风格。&lt;&#x2F;p&gt;
&lt;p&gt;本书中提到的很多建议，在 Clippy 中均存在相关的警告信息：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item1-use-types.html&quot;&gt;第 1 条&lt;&#x2F;a&gt;建议使用更具表现力的类型，而非一般的&lt;code&gt;bool&lt;&#x2F;code&gt;类型。Clippy 也指出了在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;fn_params_excessive_bools&quot;&gt;函数参数&lt;&#x2F;a&gt;以及&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;struct_excessive_bools&quot;&gt;结构体&lt;&#x2F;a&gt;中使用多个&lt;code&gt;bool&lt;&#x2F;code&gt;类型的问题。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item3-transform.html&quot;&gt;第 3 条&lt;&#x2F;a&gt;包括了一些&lt;code&gt;Option&lt;&#x2F;code&gt;及&lt;code&gt;Result&lt;&#x2F;code&gt;类型的操作。Clippy 指出了一些可行的精简行为，比如：
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;ok_expect&quot;&gt;Unnecessarily converting &lt;code&gt;Result&lt;&#x2F;code&gt; to &lt;code&gt;Option&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;unwrap_or_else_default&quot;&gt;Opportunities to use &lt;code&gt;unwrap_or_default&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item3-transform.html&quot;&gt;第 3 条&lt;&#x2F;a&gt;同样建议了应当将错误返回给调用方。Clippy [指出了应当返回的地方]。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;from_over_into&quot;&gt;第 5 条&lt;&#x2F;a&gt;应当实现&lt;code&gt;From&lt;&#x2F;code&gt;特征而非&lt;code&gt;Into&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item5-casts.html&quot;&gt;第 5 条&lt;&#x2F;a&gt;还描述了一些强制转换，而 Clippy 给出了如下的警告（对应的检查项默认是关掉的）：
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;cast_lossless&quot;&gt;&lt;code&gt;as&lt;&#x2F;code&gt; casts that could be from instead&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;cast_possible_truncation&quot;&gt;&lt;code&gt;as&lt;&#x2F;code&gt; casts that might truncate&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;cast_possible_wrap&quot;&gt;&lt;code&gt;as&lt;&#x2F;code&gt; casts that might wrap&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;cast_precision_loss&quot;&gt;&lt;code&gt;as&lt;&#x2F;code&gt; casts that lose precision&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;cast_sign_loss&quot;&gt;&lt;code&gt;as&lt;&#x2F;code&gt; casts that might convert signed negative numbers to large positive numbers&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;as_conversions&quot;&gt;any use of &lt;code&gt;as&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item8-references&amp;amp;pointer.html&quot;&gt;第 8 条&lt;&#x2F;a&gt;描述了胖指针类型，并且很多 Clippy 的校验器指出了一些非必要的额外的指针间接访问：
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;box_collection&quot;&gt;Holding a heap-allocated collection in a &lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;vec_box&quot;&gt;Holding a heap-allocated collection of &lt;code&gt;Box&lt;&#x2F;code&gt; items&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;borrowed_box&quot;&gt;Taking a reference to a &lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item9-iterators.html&quot;&gt;第 9 条&lt;&#x2F;a&gt;描述了操作&lt;code&gt;Iterator&lt;&#x2F;code&gt;实例的诸多方法。Clippy 包含了诸多的可以简化迭代器方法使用的校验器&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_2&#x2F;item10-std-traits.html&quot;&gt;第 10 条&lt;&#x2F;a&gt;描述了 Rust 的标准特性，并且包含了很多 Clippy 会校验到的实现时的要求：
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;derive_ord_xor_partial_ord&quot;&gt;&lt;code&gt;Ord&lt;&#x2F;code&gt; must agree with &lt;code&gt;PartialOrd&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;partialeq_ne_impl&quot;&gt;&lt;code&gt;PartialEq::ne&lt;&#x2F;code&gt; should not need a nondefault implementation&lt;&#x2F;a&gt;（参照 &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_2&#x2F;item13-use-default-impl.html&quot;&gt;第 13 条&lt;&#x2F;a&gt;）。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;derived_hash_with_manual_eq&quot;&gt;&lt;code&gt;Hash&lt;&#x2F;code&gt; and &lt;code&gt;Eq&lt;&#x2F;code&gt; must be consistent&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;expl_impl_clone_on_copy&quot;&gt;&lt;code&gt;Clone&lt;&#x2F;code&gt; for &lt;code&gt;Copy&lt;&#x2F;code&gt; types should match&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_3&#x2F;item18-panic.html&quot;&gt;第 18 条&lt;&#x2F;a&gt;提供了一些关于减少&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;panic&quot;&gt;&lt;code&gt;panic!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;或类似&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;expect_used&quot;&gt;&lt;code&gt;expect&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;的方法，这些建议也会在 Clippy 的校验器中检查到。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;semver.html&quot;&gt;第 21 条&lt;&#x2F;a&gt;表述了引入通过通配符限定的包是不明智的。Clippy 同样对此&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;wildcard_dependencies&quot;&gt;进行了校验&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_4&#x2F;item23-wildcard.html&quot;&gt;第 23 条&lt;&#x2F;a&gt;及&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;dep-graph.html&quot;&gt;第 25 条&lt;&#x2F;a&gt;涉及到一种不同版本的包出现在同一个项目的依赖中。Clippy 可以通过配置，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;multiple_crate_versions&quot;&gt;在问题出现时给出警告信息&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;features.html&quot;&gt;第 26 条&lt;&#x2F;a&gt;叙述了 Cargo 特性的一些相加性，而 Clippy 会将与此原则相违背特性提示为&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;negative_feature_names&quot;&gt;“否定”的特性&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;features.html&quot;&gt;第 26 条&lt;&#x2F;a&gt;同样表述了一个包的可选依赖项同样是其特征集的一部分。如果存在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;redundant_feature_names&quot;&gt;需要明确的特性名（如：&quot;use-crate-x&quot;形式的命名）&lt;&#x2F;a&gt;时，Clippy 将会提示直接应当使用明确的特性名，而非模糊的。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_5&#x2F;item27-document-public-interfaces.html&quot;&gt;第 27 条&lt;&#x2F;a&gt;描述了文档注释的约束，Clippy 同时有如下的提示：
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;missing_panics_doc&quot;&gt;Missing descriptions of &lt;code&gt;panic!&lt;&#x2F;code&gt;s&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;missing_safety_doc&quot;&gt;Missing descriptions&lt;&#x2F;a&gt; of &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;undocumented_unsafe_blocks&quot;&gt;&lt;code&gt;unsafe&lt;&#x2F;code&gt; concerns&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;上述的信息无疑说明了&lt;strong&gt;阅读 &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html&quot;&gt;Clippy 的警告信息&lt;&#x2F;a&gt;列表&lt;&#x2F;strong&gt;同样是一种有意义的学习方式 —— 包括那些默认被关掉校验的原因，是由于它们太严苛了还是由于它们会产生虚警？尽管你可能并不希望代码中出现这么多的警告信息，领悟这些校验规则出现的原因将会提升你对 Rust 及其风格的理解。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhu-shi&quot;&gt;注释&lt;&#x2F;h3&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;部分校验器列举如下。&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;explicit_counter_loop&quot;&gt;explicit_counter_loop&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;explicit_iter_loop&quot;&gt;explicit_iter_loop&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;explicit_into_iter_loop&quot;&gt;explicit_into_iter_loop&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;filter_map_identity&quot;&gt;filter_map_identity&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;from_iter_instead_of_collect&quot;&gt;from_iter_instead_of_collect&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;into_iter_on_ref&quot;&gt;into_iter_on_ref&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;iter_count&quot;&gt;iter_count&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;iter_next_loop&quot;&gt;iter_next_loop&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;iter_not_returning_iterator&quot;&gt;iter_not_returning_iterator&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;manual_filter_map&quot;&gt;manual_filter_map&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;manual_find_map&quot;&gt;manual_find_map&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;map_clone&quot;&gt;map_clone&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;needless_range_loop&quot;&gt;needless_range_loop&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;search_is_some&quot;&gt;search_is_some&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;skip_while_next&quot;&gt;skip_while_next&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;suspicious_map&quot;&gt;suspicious_map&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;unnecessary_filter_map&quot;&gt;unnecessary_filter_map&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;unnecessary_fold&quot;&gt;unnecessary_fold&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;原文&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;clippy.html&quot;&gt;点这里&lt;&#x2F;a&gt;查看&lt;&#x2F;p&gt;
&lt;!-- 参考链接 --&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>【译文&#x2F;effective-rust】第 28 条：在合适的时候使用宏</title>
        <published>2024-07-29T14:59:31+08:00</published>
        <updated>2024-07-29T14:59:31+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/use-macros-judiciously/"/>
        <id>https://liyan-ah.github.io/use-macros-judiciously/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/use-macros-judiciously/">&lt;blockquote&gt;
&lt;p&gt;原文由笔者翻译并提交至 [rustx-labs&#x2F;effective-rust-cn&#x2F;item28]，同步转载到此处。最近一直在搞翻译了，从中看到了很多自己的不足。比如本文关于宏的内容，实际上还有很多没有弄明白的。过了这段时间再看看是否能整理下。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“在一些场景下，我们会很容易来决定应该使用宏（macro）而非函数（function），因为只有宏才能满足我们的需求。” - Paul Graham，“&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.paulgraham.com&#x2F;onlisp.html&quot;&gt;On Lisp (Prentice Hall)&lt;&#x2F;a&gt;”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Rust 的宏能够让你实现元编程（metaprogramming）：在项目中使用代码来生成代码。这一特性在需要编写很多确定性、重复性都很强的“样板代码”时会很有用，不借助宏的话我们就只能手动维护这些代码了。&lt;&#x2F;p&gt;
&lt;p&gt;程序员接触 Rust 之前可能已经预先了解了 C&#x2F;C++ 中通过预处理（preprocessor）来实现的宏，这种方式是在预处理阶段通过文本替换来展开宏定义。而 Rust 的宏则有一些不同，它是在符号流（parsed tokens of the program）或者在抽象语法树（abstract syntax tree, AST）的基础上实现的宏，而非在文本处理阶段。&lt;&#x2F;p&gt;
&lt;p&gt;这就意味着 Rust 的宏是能够理解代码结构并且规避掉一系列的文本替换方式实现的宏所存在的意外情况。比如说，在接下来的内容中，我们可以看到 Rust 所声明的宏是&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hygienic_macro&quot;&gt;卫生的&lt;&#x2F;a&gt; —— 在宏里不会意外引用（或者捕获）宏所嵌入代码中的变量信息。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;c&quot;&gt;&#x2F;* 这段内容较为晦涩。引用一段维基百科上的内容来说明文本替换方式实现的宏所带来的问题。*&#x2F;
#define INCI(i) { int a=0; ++i; }
int main(void)
{
  int a = 4, b = 8;
  INCI(a);
  INCI(b);
  printf(&amp;quot;a is now %d, b is now %d\n&amp;quot;, a, b);
  return 0;
}

&#x2F;* 以上代码中的 INCI 宏期望分别对 a, b 进行加一操作。文本替换后的结果如下所示。*&#x2F;

int main(void)
{
    int a = 4, b = 8;
    { int a = 0; ++a; }; &#x2F;&#x2F; 注意这里对 a 进行了重新声明，实际上是对声明的这个 a 进行了自增。
    { int a = 0; ++b; }; 
    printf(&amp;quot;a is now %d, b is now %d\n&amp;quot;, a, b);
    return 0;
}

&#x2F;* 最终的结果会输出如下。 
 *
 * a is now 4, b is now 9
 *
 * 这显然是不符合预期的。产生这一结果的原因是由于文本替换过于粗暴，而无法进行实际语意上的理解。
 *
 * 本注释内容为译者添加。
 *&#x2F;

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;一种理解宏的方法是将其视为代码的不同抽象方式。函数也是代码的一种简单抽象：它将同一类型的不同值的不同抽象出来，实现了针对这一类型，而非特定的值，会做的操作及方法。而宏中的生成则是另外一个层面的抽象：宏是对符合同一特性的不同类型进行抽象，使用针对这些不同类型所具备的相同特性，而非特性的类型，进行代码的实现。&lt;&#x2F;p&gt;
&lt;p&gt;宏可以对不同程序中扮演相同角色（类型、标记、表达式等）的代码抽象出来，然后这些程序就可以以同一种方式来使用抽象出的逻辑。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 提供了两种方式来定义宏：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;声明宏，也被成为“示例宏”。声明宏允许将输入到宏中任意的 Rust 程序，基于抽象语法树中的结果，集成到代码中。&lt;&#x2F;li&gt;
&lt;li&gt;过程宏。过程宏同样可以将任意的 Rust 程序集成到代码中，不过是基于源码中的解析符号。&lt;code&gt;derive&lt;&#x2F;code&gt;宏就是常见的过程宏。&lt;code&gt;derive&lt;&#x2F;code&gt;宏可以基于代码的结构定义来展开代码。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;sheng-ming-hong&quot;&gt;声明宏&lt;&#x2F;h2&gt;
&lt;p&gt;虽然这篇文章不是为了重复&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;macros-by-example.html&quot;&gt;声明宏&lt;&#x2F;a&gt;的内容，但还是有必要来提醒下声明宏中需要关注的内容。&lt;&#x2F;p&gt;
&lt;p&gt;首先，需要注意的是声明宏的作用域范围和直觉上的理解的是不同的（对比 C 里的预处理宏）。如果一个声明宏在源代码中被定义了，就只有&lt;em&gt;跟在&lt;&#x2F;em&gt;宏里的代码能够使用：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;fn before() {
    println!(&amp;quot;[before] square {} is {}&amp;quot;, 2, square!(2));
}

&#x2F;&#x2F;&#x2F; Macro that squares its argument.
macro_rules! square {
    { $e:expr } =&amp;gt; { $e * $e }
}

fn after() {
    println!(&amp;quot;[after] square {} is {}&amp;quot;, 2, square!(2));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;error: cannot find macro `square` in this scope
 --&amp;gt; src&#x2F;main.rs:4:45
  |
4 |     println!(&amp;quot;[before] square {} is {}&amp;quot;, 2, square!(2));
  |                                             ^^^^^^
  |
  = help: have you added the `#[macro_use]` on the module&#x2F;import?

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;#[macro_export]&lt;&#x2F;code&gt;特性让宏可以访问更多的数据，但是也存在一些奇怪的事情：尽管宏并没有在模块中定义，它还是出现在了模块的顶层。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;mod submod {
    #[macro_export]
    macro_rules! cube {
        { $e:expr } =&amp;gt; { $e * $e * $e }
    }
}

mod user {
    pub fn use_macro() {
        &#x2F;&#x2F; Note: *not* `crate::submod::cube!`
        let cubed = crate::cube!(3);
        println!(&amp;quot;cube {} is {}&amp;quot;, 3, cubed);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Rust 的声明宏是卫生（hygienic）的：宏内部展开的代码无法使用所在作用域的局部变量。比如，宏内部使用了局部变量 x 时：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F; Create a macro that assumes the existence of a local `x`.
macro_rules! increment_x {
    {} =&amp;gt; { x += 1; };
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样的用法将会造成编译错误：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let mut x = 2;
increment_x!();
println!(&amp;quot;x = {}&amp;quot;, x);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;error[E0425]: cannot find value `x` in this scope
   --&amp;gt; src&#x2F;main.rs:55:13
    |
55  |     {} =&amp;gt; { x += 1; };
    |             ^ not found in this scope
...
314 |     increment_x!();
    |     -------------- in this macro invocation
    |
    = note: this error originates in the macro `increment_x`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这种“卫生”的特性意味着 Rust 的宏比 C 的基于预处理替换的宏要安全很多。然而，仍有一些需要在使用时注意的内容。&lt;&#x2F;p&gt;
&lt;p&gt;第一，尽管一个宏&lt;em&gt;看起来&lt;&#x2F;em&gt;很像是函数的声明，它并不是。宏将会在调用的地方进行代码展开，而且可以随着传入参数的不同进行不同形式的展开：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;macro_rules! inc_item {
    { $x:ident } =&amp;gt; { $x.contents += 1; }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这就意味着常规意义上的参数被移动（moved）或者 &amp;amp; （被引用）的情形没有发生：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let mut x = Item { contents: 42 }; &#x2F;&#x2F; type is not `Copy`

&#x2F;&#x2F; Item is *not* moved, despite the (x) syntax,
&#x2F;&#x2F; but the body of the macro *can* modify `x`.
inc_item!(x);

println!(&amp;quot;x is {x:?}&amp;quot;);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;x is Item { contents: 43 }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果我们还记得宏只是在调用它的地方进行展开的话，上述示例就会变得清楚了 —— 在这个示例中，调用宏的地方只相当于添加了一行增加&lt;code&gt;x.contents&lt;&#x2F;code&gt;值的代码。借助&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;dtolnay&#x2F;cargo-expand&quot;&gt;cargo-expand&lt;&#x2F;a&gt;可以很清晰地看到编译器将宏进行展开后的代码：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let mut x = Item { contents: 42 };
x.contents += 1;
{
    ::std::io::_print(format_args!(&amp;quot;x is {0:?}\n&amp;quot;, x));
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;展开的代码中可以看到直接使用了变量本身，而非其引用。（一个有意思的事情是，我们可以看到&lt;code&gt;println!&lt;&#x2F;code&gt;的展开中，依赖了&lt;code&gt;format_args!&lt;&#x2F;code&gt;宏&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。）&lt;&#x2F;p&gt;
&lt;p&gt;所以，宏里的&lt;code&gt;!&lt;&#x2F;code&gt;起到了一个警示的作用：展开的代码可能会对参数做一些任性的事情。&lt;&#x2F;p&gt;
&lt;p&gt;展开的代码也可能会包含一些在调用代码中无法访问的控制流，可能包括循环、判断、返回值甚至使用&lt;code&gt;?&lt;&#x2F;code&gt;操作符。显然，这里会和[最小惊讶原则]相冲突，所以在使用宏时，应当考虑封装常规的 Rust 语句。（另一方面，如果使用宏的&lt;em&gt;目的&lt;&#x2F;em&gt;是实现一些奇怪的控制流，请确保这些控制流在文档中都给用户提供了！）&lt;&#x2F;p&gt;
&lt;p&gt;举例来说，考虑这样一个宏（用来校验 HTTP 状态码）包含了一个&lt;code&gt;return&lt;&#x2F;code&gt;语句：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Check that an HTTP status is successful; exit function if not.
macro_rules! check_successful {
    { $e:expr } =&amp;gt; {
        if $e.group() != Group::Successful {
            return Err(MyError(&amp;quot;HTTP operation failed&amp;quot;));
        }
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用这段宏来校验一些 HTTP 行为的代码可能会以一些很晦涩的控制流来结束：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let rc = perform_http_operation();
check_successful!(rc); &#x2F;&#x2F; may silently exit the function

&#x2F;&#x2F; ...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;另一种可以实现上述功能的宏是产生一个&lt;code&gt;Result&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Convert an HTTP status into a `Result&amp;lt;(), MyError&amp;gt;` indicating success.
macro_rules! check_success {
    { $e:expr } =&amp;gt; {
        match $e.group() {
            Group::Successful =&amp;gt; Ok(()),
            _ =&amp;gt; Err(MyError(&amp;quot;HTTP operation failed&amp;quot;)),
        }
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;而这样依赖，代码就很好理解了：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let rc = perform_http_operation();
check_success!(rc)?; &#x2F;&#x2F; error flow is visible via `?`

&#x2F;&#x2F; ...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于声明宏来说，第二件需要注意的事情是和 C 的预编译宏同样的问题：如果宏的参数是一个存在副作用的表达式，当心在宏里多次使用的情况。比如我们在早先定义的&lt;code&gt;square!&lt;&#x2F;code&gt;宏输入了较为随意的表达式来作为参数，然后使用两次，这将会造成奇怪的结果：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let mut x = 1;
let y = square!({
    x += 1;
    x
});
println!(&amp;quot;x = {x}, y = {y}&amp;quot;);
&#x2F;&#x2F; output: x = 3, y = 6
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;假设这种行为并非有意的，一种修复的方法是尝试仅执行给定的表达式一次，然后将结果赋值给一个本地的变量：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;macro_rules! square_once {
    { $e:expr } =&amp;gt; {
        {
            let x = $e;
            x*x &#x2F;&#x2F; Note: there&amp;#39;s a detail here to be explained later...
        }
    }
}
&#x2F;&#x2F; output now: x = 2, y = 4
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;另一种可选的方案是不允许将表达式作为宏的输入。如果将[expr]替换为&lt;code&gt;indent&lt;&#x2F;code&gt;，那么这个宏就仅会接受标志符作为入参，而使用类似任意的表达式将不再能编译通过。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ge-shi-hua-can-shu&quot;&gt;格式化参数&lt;&#x2F;h2&gt;
&lt;p&gt;声明宏的一种常见的使用模式将多个值汇聚成一个消息。比如，标准库中的&lt;code&gt;format!&lt;&#x2F;code&gt;用来拼接一个字符串，&lt;code&gt;println!&lt;&#x2F;code&gt;用来输出到标准输出，&lt;code&gt;eprintln!&lt;&#x2F;code&gt;用来输出到标准错误输出。&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;fmt&#x2F;index.html&quot;&gt;fmt 文档&lt;&#x2F;a&gt;中阐述了&lt;code&gt;format!&lt;&#x2F;code&gt;的语法，和&lt;code&gt;C&lt;&#x2F;code&gt;中的&lt;code&gt;printf&lt;&#x2F;code&gt;使用几乎是相同的。当然，Rust 中的&lt;code&gt;format!&lt;&#x2F;code&gt;参数是类型安全并且会在编译时进行检查的，并且&lt;code&gt;format!&lt;&#x2F;code&gt;宏实现时使用了&lt;code&gt;Display&lt;&#x2F;code&gt;以及&lt;code&gt;Debug&lt;&#x2F;code&gt;特性用来约束宏的参数。&lt;code&gt;Display&lt;&#x2F;code&gt;以及&lt;code&gt;Debug&lt;&#x2F;code&gt;宏的使用参见&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_2&#x2F;item10-std-traits.html&quot;&gt;第 10 条&lt;&#x2F;a&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;你可以（同时也建议）在项目中的宏中使用相同的格式化语法。比如，一个&lt;code&gt;log&lt;&#x2F;code&gt;库中的&lt;code&gt;logging&lt;&#x2F;code&gt;宏就可以使用和&lt;code&gt;format!&lt;&#x2F;code&gt;相同的语法。在实践中，使用&lt;code&gt;format_args!&lt;&#x2F;code&gt;来实现参数的格式化而不是重复造轮子。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Log an error including code location, with `format!`-like arguments.
&#x2F;&#x2F;&#x2F; Real code would probably use the `log` crate.
macro_rules! my_log {
    { $($arg:tt)+ } =&amp;gt; {
        eprintln!(&amp;quot;{}:{}: {}&amp;quot;, file!(), line!(), format_args!($($arg)+));
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let x = 10u8;
&#x2F;&#x2F; Format specifiers:
&#x2F;&#x2F; - `x` says print as hex
&#x2F;&#x2F; - `#` says prefix with &amp;#39;0x&amp;#39;
&#x2F;&#x2F; - `04` says add leading zeroes so width is at least 4
&#x2F;&#x2F;   (this includes the &amp;#39;0x&amp;#39; prefix).
my_log!(&amp;quot;x = {:#04x}&amp;quot;, x);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;src&#x2F;main.rs:331: x = 0x0a
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;guo-cheng-hong&quot;&gt;过程宏&lt;&#x2F;h2&gt;
&lt;p&gt;Rust 也支持了&lt;em&gt;过程宏&lt;&#x2F;em&gt;，也被称为&lt;code&gt;proc macros&lt;&#x2F;code&gt;。和声明宏类似，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;procedural-macros.html&quot;&gt;过程宏&lt;&#x2F;a&gt;能够任意的 Rust 代码插入到程序的源代码中。不同的时，过程宏的输入不再仅限制在特定的传入参数。过程宏可以访问一些源代码中的解析符号（parsed tokens）。这就过程宏一定程度上类似动态语言，比如 Lisp，的非常富有表达力的能力 —— 但是仍然在编译时进行检查。这也帮助缓解了 Rust 中反射的局限，这在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;reflection.html&quot;&gt;第 19 条&lt;&#x2F;a&gt;中讨论了。&lt;&#x2F;p&gt;
&lt;p&gt;过程宏需要和其被使用的代码定义在不同的包中（并且包需要被声明为&lt;code&gt;proc_macro&lt;&#x2F;code&gt;），并且包中往往需要引入[proc-macro]（官方工具链中提供）或者[proc-macro2]（由 David Tolnay 提供）的依赖，这两个依赖可以宏能够操作输入的符号。&lt;&#x2F;p&gt;
&lt;p&gt;实际上，有三种不同的过程宏：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;类函数宏（Function-like macros）：通过传入的参数调用。&lt;&#x2F;li&gt;
&lt;li&gt;类属性宏（Attribute macros）：附加到程序中的某些特定语法的代码中。&lt;&#x2F;li&gt;
&lt;li&gt;派生宏（Derive macros）：附加到特定的数据结构中。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;lei-han-shu-hong&quot;&gt;类函数宏&lt;&#x2F;h3&gt;
&lt;p&gt;函数式的宏会通过传递参数来调用，宏的实现中可以访问参数的解析符号（parsed tokens），并且返回任意的符号。注意在先前的表述中，我们使用的是单数的参数， —— 即使函数式的宏调用的时候看起来传入了很多参数：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;my_func_macro!(15, x + y, f32::consts::PI);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是宏本身只接收到了一个解析后的符号流。一个将符号流输出（在编译时）的宏实现示例如下：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;use proc_macro::TokenStream;

&#x2F;&#x2F; Function-like macro that just prints (at compile time) its input stream.
#[proc_macro]
pub fn my_func_macro(args: TokenStream) -&amp;gt; TokenStream {
    println!(&amp;quot;Input TokenStream is:&amp;quot;);
    for tt in args {
        println!(&amp;quot;  {tt:?}&amp;quot;);
    }
    &#x2F;&#x2F; Return an empty token stream to replace the macro invocation with.
    TokenStream::new()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其运行结果如下：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;Input TokenStream is:
  Literal { kind: Integer, symbol: &amp;quot;15&amp;quot;, suffix: None,
            span: #0 bytes(10976..10978) }
  Punct { ch: &amp;#39;,&amp;#39;, spacing: Alone, span: #0 bytes(10978..10979) }
  Ident { ident: &amp;quot;x&amp;quot;, span: #0 bytes(10980..10981) }
  Punct { ch: &amp;#39;+&amp;#39;, spacing: Alone, span: #0 bytes(10982..10983) }
  Ident { ident: &amp;quot;y&amp;quot;, span: #0 bytes(10984..10985) }
  Punct { ch: &amp;#39;,&amp;#39;, spacing: Alone, span: #0 bytes(10985..10986) }
  Ident { ident: &amp;quot;f32&amp;quot;, span: #0 bytes(10987..10990) }
  Punct { ch: &amp;#39;:&amp;#39;, spacing: Joint, span: #0 bytes(10990..10991) }
  Punct { ch: &amp;#39;:&amp;#39;, spacing: Alone, span: #0 bytes(10991..10992) }
  Ident { ident: &amp;quot;consts&amp;quot;, span: #0 bytes(10992..10998) }
  Punct { ch: &amp;#39;:&amp;#39;, spacing: Joint, span: #0 bytes(10998..10999) }
  Punct { ch: &amp;#39;:&amp;#39;, spacing: Alone, span: #0 bytes(10999..11000) }
  Ident { ident: &amp;quot;PI&amp;quot;, span: #0 bytes(11000..11002) }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于输入流涉及到的底层特性式的这段宏在实现时必须要能够解析所传入的参数。比如，宏中分隔那些需要分隔的参数需要使用&lt;code&gt;TokenTree:Punct&lt;&#x2F;code&gt;。&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;syn&#x2F;latest&#x2F;syn&#x2F;&quot;&gt;syn 包&lt;&#x2F;a&gt;（David Tolnay开发）提供了一个解析的库来辅助这些事情，下一节会进行介绍。&lt;&#x2F;p&gt;
&lt;p&gt;正因为这些解析的工作，使用声明宏往往比函数式的过程宏要简单，因为声明宏所处理的是匹配所定义的结构。&lt;&#x2F;p&gt;
&lt;p&gt;这种需要手动处理繁杂的另一面是函数是的宏可以更加灵活的接受那些无法像一般 Rust 代码解析的输入。这种特性并非经常需要的，所以函数式的宏相对较少出现。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lei-shu-xing-hong&quot;&gt;类属性宏&lt;&#x2F;h3&gt;
&lt;p&gt;类属性宏通过将其放置在程序的一些片段前调用的，而这些片段的解析符号会被传入到宏的内部进行处理。类属性宏也可以将任意的结果作为返回值，但是一般返回值是对输出的一些转换处理。&lt;&#x2F;p&gt;
&lt;p&gt;比如，下面是一个用来封装函数体的类属性宏：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;#[log_invocation]
fn add_three(x: u32) -&amp;gt; u32 {
    x + 3
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;之后，在调用这个被封装的函数时，就会有日志输出：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let x = 2;
let y = add_three(x);
println!(&amp;quot;add_three({x}) = {y}&amp;quot;);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;log: calling function &amp;#39;add_three&amp;#39;
log: called function &amp;#39;add_three&amp;#39; =&amp;gt; 5
add_three(2) = 5
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个宏的实现是极为复杂的，这里并不打算将其细节附上。在实现时，需要校验输入符号的结构以便构建新的输出符号。当然，这一过程仍然可以使用&lt;code&gt;syn&lt;&#x2F;code&gt;包来辅助实现。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pai-sheng-hong&quot;&gt;派生宏&lt;&#x2F;h3&gt;
&lt;p&gt;最后一种过程宏是派生宏。派生宏可以为其修饰的数据（struct, enum 或者 union 均可）自动地生成代码。这一点和类属性宏有些像，但是会多一些派生的操作 —— 请注意理解这里的派生概念。&lt;&#x2F;p&gt;
&lt;p&gt;首先，派生宏会附加到输入的符号中，而非将其替换。这就意味着原始的数据结构的定义会被保留，而派生宏将在原始数据结构的基础上附加代码。&lt;&#x2F;p&gt;
&lt;p&gt;其次，派生宏可以用来声明一些辅助性的特征。当数据需要用作一些特殊的处理时，可以使用派生宏来辅助标注。比如，[serde 库]的&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;serde&#x2F;latest&#x2F;serde&#x2F;derive.Deserialize.html&quot;&gt;Deserialize&lt;&#x2F;a&gt;派生宏有一个&lt;code&gt;serde&lt;&#x2F;code&gt;的辅助特性，用户可以使用派生宏来声明这些结构体符合某种特性：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;fn generate_value() -&amp;gt; String {
    &amp;quot;unknown&amp;quot;.to_string()
}

#[derive(Debug, Deserialize)]
struct MyData {
    &#x2F;&#x2F; If `value` is missing when deserializing, invoke
    &#x2F;&#x2F; `generate_value()` to populate the field instead.
    #[serde(default = &amp;quot;generate_value&amp;quot;)]
    value: String,
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;关于派生宏的最后一个概念是，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;syn&#x2F;latest&#x2F;syn&#x2F;&quot;&gt;syn 包&lt;&#x2F;a&gt;可以完成将输入符号解析到相应的语法树的工作。&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;syn&#x2F;latest&#x2F;syn&#x2F;macro.parse_macro_input.html&quot;&gt;syn::parse_macro_input!&lt;&#x2F;a&gt;宏可以将符号转换成&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;syn&#x2F;latest&#x2F;syn&#x2F;struct.DeriveInput.html&quot;&gt;syn::DeriveInput&lt;&#x2F;a&gt;数据结构，这种结构描述被修饰对象的主要内容，并且&lt;code&gt;DeriveInput&lt;&#x2F;code&gt;操作起来远比原始的符号流要好处理。&lt;&#x2F;p&gt;
&lt;p&gt;特别地，&lt;code&gt;derive&lt;&#x2F;code&gt;宏是所有过程宏中最常使用的宏 —— 这种逐字段或逐变量操作的能力能够让程序员最简单地实现最多的功能 —— 比如，仅通过添加一行类似&lt;code&gt;#[derive(Debug, Clone, PartialEq, Eq)]&lt;&#x2F;code&gt;的代码，即可实现预期的目的。&lt;&#x2F;p&gt;
&lt;p&gt;由于派生宏的代码插入是自动实现地，这也意味着这些插入的代码可以同时和结构体的实现保持一致。比如，如果你向&lt;code&gt;struct&lt;&#x2F;code&gt;中插入了一个新的字段，如果采用手动实现&lt;code&gt;Debug&lt;&#x2F;code&gt;特征的话，你就需要在插入后对结构体进行更新以使其满足特征的需求。而对于自动插入代码的派生宏来说，你并不需要做任何调整（当然了，如果插入的字段不满足派生宏的实现要求，编译时会报错）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shen-me-shi-hou-shi-yong-hong&quot;&gt;什么时候使用宏&lt;&#x2F;h2&gt;
&lt;p&gt;使用宏的首要原因当然是避免重复的代码 —— 尤其是那些需要人工确保和其他代码关联正确性的重复代码。从这一点来说，使用宏仅是编程常用的封装抽象的扩展：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;如果需要重复一段处理同一类型的不同值的代码，将其封装为一个函数并在所有需要这段逻辑的地方使用它。&lt;&#x2F;li&gt;
&lt;li&gt;如果需要重复一段处理不同类型的代码，构建一个&lt;code&gt;trait&lt;&#x2F;code&gt;并且使用该&lt;code&gt;trait&lt;&#x2F;code&gt;来封装逻辑并在所有满足该特性的要求的地方进行使用。&lt;&#x2F;li&gt;
&lt;li&gt;如果需要重复一段结构相同的代码，将其封装成一个宏并且在所有满足类似结构的代码中进行使用。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;举例如下：如果希望规避重复处理不同&lt;code&gt;enum&lt;&#x2F;code&gt;的代码，使用宏即可：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;enum Multi {
    Byte(u8),
    Int(i32),
    Str(String),
}

&#x2F;&#x2F;&#x2F; Extract copies of all the values of a specific enum variant.
#[macro_export]
macro_rules! values_of_type {
    { $values:expr, $variant:ident } =&amp;gt; {
        {
            let mut result = Vec::new();
            for val in $values {
                if let Multi::$variant(v) = val {
                    result.push(v.clone());
                }
            }
            result
        }
    }
}

fn main() {
    let values = vec![
        Multi::Byte(1),
        Multi::Int(1000),
        Multi::Str(&amp;quot;a string&amp;quot;.to_string()),
        Multi::Byte(2),
    ];

    let ints = values_of_type!(&amp;amp;values, Int);
    println!(&amp;quot;Integer values: {ints:?}&amp;quot;);

    let bytes = values_of_type!(&amp;amp;values, Byte);
    println!(&amp;quot;Byte values: {bytes:?}&amp;quot;);

    &#x2F;&#x2F; Output:
    &#x2F;&#x2F;   Integer values: [1000]
    &#x2F;&#x2F;   Byte values: [1, 2]
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;另一个宏的使用场景是，规避同一结构体中的数据被分散在代码的不同区域。&lt;&#x2F;p&gt;
&lt;p&gt;比如，假设一个结构体封装了 HTTP 的状态码。通过宏可以避免实现这些信息时代码的分散：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F; http.rs module

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Group {
    Informational, &#x2F;&#x2F; 1xx
    Successful,    &#x2F;&#x2F; 2xx
    Redirection,   &#x2F;&#x2F; 3xx
    ClientError,   &#x2F;&#x2F; 4xx
    ServerError,   &#x2F;&#x2F; 5xx
}

&#x2F;&#x2F; Information about HTTP response codes.
http_codes! {
    Continue           =&amp;gt; (100, Informational, &amp;quot;Continue&amp;quot;),
    SwitchingProtocols =&amp;gt; (101, Informational, &amp;quot;Switching Protocols&amp;quot;),
    &#x2F;&#x2F; ...
    Ok                 =&amp;gt; (200, Successful, &amp;quot;Ok&amp;quot;),
    Created            =&amp;gt; (201, Successful, &amp;quot;Created&amp;quot;),
    &#x2F;&#x2F; ...
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过使用宏，可以将每个 HTTP 状态码的所有相关联的信息 —— 数值、元组以及描述信息 —— 都聚集起来，看起来就像是使用一种领域特定语言（domain-specifix language, DSL）来保存数据一样。&lt;&#x2F;p&gt;
&lt;p&gt;汇聚之后，宏就可以生成代码。每一行类似&lt;code&gt;$( ... )+&lt;&#x2F;code&gt;中的代码都会被扩展成特定的代码：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;macro_rules! http_codes {
    { $( $name:ident =&amp;gt; ($val:literal, $group:ident, $text:literal), )+ } =&amp;gt; {
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[repr(i32)]
        enum Status {
            $( $name = $val, )+
        }
        impl Status {
            fn group(&amp;amp;self) -&amp;gt; Group {
                match self {
                    $( Self::$name =&amp;gt; Group::$group, )+
                }
            }
            fn text(&amp;amp;self) -&amp;gt; &amp;amp;&amp;#39;static str {
                match self {
                    $( Self::$name =&amp;gt; $text, )+
                }
            }
        }
        impl core::convert::TryFrom&amp;lt;i32&amp;gt; for Status {
            type Error = ();
            fn try_from(v: i32) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
                match v {
                    $( $val =&amp;gt; Ok(Self::$name), )+
                    _ =&amp;gt; Err(())
                }
            }
        }
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样处理后，宏就可以依据输入的参数来派生如下的代码：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个&lt;code&gt;enum&lt;&#x2F;code&gt;枚举用来保存所有的数值。&lt;&#x2F;li&gt;
&lt;li&gt;一个&lt;code&gt;group()&lt;&#x2F;code&gt;方法来返回一个 HTTP 状态码的分组归属。&lt;&#x2F;li&gt;
&lt;li&gt;一个&lt;code&gt;text()&lt;&#x2F;code&gt;方法来将状态码映射到对应的文字描述中。&lt;&#x2F;li&gt;
&lt;li&gt;一个&lt;code&gt;TryFrom&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;的特征实现来将数值转换成&lt;code&gt;enum&lt;&#x2F;code&gt;中的枚举值。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;如果需要新增一个状态码，只需要添加这样的一行代码：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;ImATeapot =&amp;gt; (418, ClientError, &amp;quot;I&amp;#39;m a teapot&amp;quot;),
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果不使用宏的话，就需要对四部分代码分别更新。编译器可能会有一些提示信息（&lt;code&gt;match&lt;&#x2F;code&gt;表达式需要覆盖所有的场景），但是存在一些遗漏 —— &lt;code&gt;TryFrom&amp;lt;i32&lt;&#x2F;code&gt; 就很容易被遗忘。&lt;&#x2F;p&gt;
&lt;p&gt;由于宏可以在调用的地方对代码进行展开，所有它们也可以用来自动生成一些提示信息 —— 尤其是，在使用了标准库中的&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;macro.file.html&quot;&gt;file!()&lt;&#x2F;a&gt;以及&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;macro.line.html&quot;&gt;line!()&lt;&#x2F;a&gt;宏了之后，可以生成代码的位置信息：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;macro_rules! log_failure {
    { $e:expr } =&amp;gt; {
        {
            let result = $e;
            if let Err(err) = &amp;amp;result {
                eprintln!(&amp;quot;{}:{}: operation &amp;#39;{}&amp;#39; failed: {:?}&amp;quot;,
                          file!(),
                          line!(),
                          stringify!($e),
                          err);
            }
            result
        }
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当报错出现时，日志文件中就会自动地包含报错内容、位置等细节：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;use std::convert::TryInto;

let x: Result&amp;lt;u8, _&amp;gt; = log_failure!(512.try_into()); &#x2F;&#x2F; too big for `u8`
let y = log_failure!(std::str::from_utf8(b&amp;quot;\xc3\x28&amp;quot;)); &#x2F;&#x2F; invalid UTF-8
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;hong-de-que-dian&quot;&gt;宏的缺点&lt;&#x2F;h2&gt;
&lt;p&gt;使用宏的最大缺点是引入之后代码的可读性及可维护性。之前在声明宏小结中介绍了宏允许我们创建一个特定的语言来简明地描述代码及数据的关键特性。但是，这也意味着任何阅读这段代码的人将不得不理解这段使用 Rust 实现的特定的语句 —— 而且这还是使用宏来定义的。比如，在&lt;code&gt;http_codes!&lt;&#x2F;code&gt;宏的示例中使用了一个名为&lt;code&gt;Status&lt;&#x2F;code&gt;的 Rust &lt;code&gt;enum&lt;&#x2F;code&gt;，但是在使用的时候并不能察觉到。&lt;&#x2F;p&gt;
&lt;p&gt;这种使用宏而引入的不可知性远超一般程序员所能带来的影响：很多分析或和 Rust 交互的工具无法理解这样晦涩的代码，因为它不在遵循 Rust 代码交互语法。先前展示的&lt;code&gt;square_once!&lt;&#x2F;code&gt;宏就是一个直观的例子：宏的主体并没有按照&lt;code&gt;rustfmt&lt;&#x2F;code&gt;的规则来格式化：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;{
    let x = $e;
    &#x2F;&#x2F; The `rustfmt` tool doesn&amp;#39;t really cope with code in
    &#x2F;&#x2F; macros, so this has not been reformatted to `x * x`.
    x*x
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;另一个例子是已经提到的&lt;code&gt;http_codes!&lt;&#x2F;code&gt;宏，这里使用了&lt;code&gt;Group&lt;&#x2F;code&gt;枚举了诸如&lt;code&gt;Informational&lt;&#x2F;code&gt;的值，而没有使用&lt;code&gt;Group::&lt;&#x2F;code&gt;前缀或&lt;code&gt;use&lt;&#x2F;code&gt;语句。这一点会让代码的补全工具感到混淆。&lt;&#x2F;p&gt;
&lt;p&gt;甚至编译器本身也无法提供更多的帮助：编译器提供的报错信息没有完全符合宏的定义及使用。当然，还是有一些工具（参照&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;use-tools.html&quot;&gt;第 31 条&lt;&#x2F;a&gt;）可以辅助宏的使用，比如早先使用的 David Tolnay 的 &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;dtolnay&#x2F;cargo-expand&quot;&gt;cargo-expand&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;使用宏也可能会导致代码的膨胀 —— 一个简单的宏调用就可能引入数百行的生成代码，并且在进行代码分析时是无法直观看到的。这在代码第一次编写时可能不会成为问题，因为彼时这些代码是需要的，并且帮助开发者节约了大量的代码编写时间。但是，如果这些代码随后不再需要了，考虑实际生成的数百行代码，仅从数行的宏调用中可能并不能看到将其删除的必要性。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jian-yi&quot;&gt;建议&lt;&#x2F;h2&gt;
&lt;p&gt;尽管上节我们列举了很多宏的缺点，但是当我们需要合并存在一些存在一致性的代码，但是没有其他可用的方式时，使用宏仍然是完成这样工作的正确工具：&lt;em&gt;当宏是确保不同代码保持一致的唯一方式时，使用它！&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;当我们需要合并一些模版化的代码时，宏也是可以使用的工具：&lt;em&gt;使用宏来处理模版代码&lt;&#x2F;em&gt;，当它们无法合并为一个函数或者一个特性时。&lt;&#x2F;p&gt;
&lt;p&gt;为了降低宏对可读性的影响，请尽量避免在宏中使用和 Rust 的一般语法规则相冲突的语法。要么让宏在调用时和一般的代码表现的一致；要么让宏在调用时和一般的代码完全不同，这样就没有用户会混淆宏和一般的代码。特别地，可以遵循如下的准则：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;尽可能的避免向宏传递参数的引用&lt;&#x2F;em&gt; —— 类似&lt;code&gt;my_macro!(list)&lt;&#x2F;code&gt;的使用就比&lt;code&gt;my_macro!(&amp;amp;list)&lt;&#x2F;code&gt;要好。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;em&gt;尽量避免在宏中引入非局部的控制流&lt;&#x2F;em&gt;，这样所有阅读这段代码的人都可以在不了解宏的细节的情况下，正确理解上下文中的控制流。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这种倾向于类似 Rust 一般代码的可读性偏好有时会影响声明宏或者过程式宏的选择。如果你需要给一个&lt;code&gt;struct&lt;&#x2F;code&gt;的每一个字段或者&lt;code&gt;enum&lt;&#x2F;code&gt;中的每一个枚举值都生成代码，&lt;em&gt;尽量使用派生宏来处理&lt;&#x2F;em&gt;（暂时忽略在上一节中列举的问题） —— 这样会更加符合语言习惯并且读起来更加简单。&lt;&#x2F;p&gt;
&lt;p&gt;然而，如果要添加的派生宏并非是项目中所独有的功能，可以检查下外部的库中是否已经提供了所需要的宏（参照&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;dep-graph.html&quot;&gt;第 25 条&lt;&#x2F;a&gt;）。比如，类似将数值类型转换为合适的 C 风格的枚举值的需求：在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;enumn&#x2F;latest&#x2F;enumn&#x2F;derive.N.html&quot;&gt;enumn::N&lt;&#x2F;a&gt;、[num_enum::TryFromPrimitive]、&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;num-derive&#x2F;latest&#x2F;num_derive&#x2F;derive.FromPrimitive.html&quot;&gt;num_derive::FromPrimitive&lt;&#x2F;a&gt;以及&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;strum&#x2F;latest&#x2F;strum&#x2F;derive.FromRepr.html&quot;&gt;strum::FromRepr&lt;&#x2F;a&gt;中都一定程度的实现了这个需求。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;zhu-shi&quot;&gt;注释&lt;&#x2F;h3&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;眼神儿好的读者可能已经注意到了&lt;code&gt;format_arg!&lt;&#x2F;code&gt;仍然像是一个宏的调用，尽管它在&lt;code&gt;println!&lt;&#x2F;code&gt;宏的展开代码里。这是因为它是编译器的内建宏。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;fmt&#x2F;index.html&quot;&gt;std::fmt 模块&lt;&#x2F;a&gt;中也包含了很多其他展示特定格式数据是会使用的特性。比如，当需要一个 x 格式的特殊说明符来输出小写的十六进制输出时，就会使用&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;fmt&#x2F;trait.LowerHex.html&quot;&gt;LowerHex&lt;&#x2F;a&gt;特性。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;原文&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;macros.html&quot;&gt;点这里&lt;&#x2F;a&gt;查看。&lt;&#x2F;p&gt;
&lt;!-- 参考链接 --&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>【译文&#x2F;effective-rust】第 27 条：为公共接口撰写文档</title>
        <published>2024-06-17T15:08:08+08:00</published>
        <updated>2024-06-17T15:08:08+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/document-public-interfaces/"/>
        <id>https://liyan-ah.github.io/document-public-interfaces/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/document-public-interfaces/">&lt;blockquote&gt;
&lt;p&gt;原文由笔者翻译并提交至 &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_5&#x2F;item27-document-public-interfaces.html&quot;&gt;rustx-labs&#x2F;effective-rust-cn&#x2F;item27&lt;&#x2F;a&gt;，同步转载到此处。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;如果你的包（crate）会被其他程序员所使用，那么为包中的内容添加文档就是很好的实践，尤其是包中的公共接口。如果你的包不仅仅是随用随丢的代码，那么这个“其他程序员”就包括未来的你，那个已经忘掉了自己代码细节的你。&lt;&#x2F;p&gt;
&lt;p&gt;这个建议并不是 Rust 所独有的，它也并不是一个新的建议 —— 比如，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;effective-java-2nd&#x2F;9780137150021&#x2F;&quot;&gt;Effective Java&lt;&#x2F;a&gt; 第二版（2008年出版）在第 44 条中建议：“为所有导出的 API 元素编写文档注释”。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 文档类型注释的细节 —— 基于 Markdown 格式，以 &#x2F;&#x2F;&#x2F; 或者 &#x2F;&#x2F;! 分割 —— 已经在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments&quot;&gt;Rust book&lt;&#x2F;a&gt;中介绍了，如下为示例：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;Rust&quot;&gt;&#x2F;&#x2F;&#x2F; Calculate the [`BoundingBox`] that exactly encompasses a pair
&#x2F;&#x2F;&#x2F; of [`BoundingBox`] objects.
pub fn union(a: &amp;amp;BoundingBox, b: &amp;amp;BoundingBox) -&amp;gt; BoundingBox {
    &#x2F;&#x2F; ...
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然而，关于文档型注释的格式仍有一些值得关注的细节：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;使用代码格式：对于任何作为源代码的注释，使用反引号来确保在最终的文档中代码会以一种等宽字体来展示，并以此来明确的区分&lt;code&gt;code&lt;&#x2F;code&gt;以及一般的文本。&lt;&#x2F;li&gt;
&lt;li&gt;添加丰富的引用内容：为任何能够给读者提供上下文信息的内容添加 Markdown 链接。特别地，可以使用比较方便的 [&lt;code&gt;SomeThing&lt;&#x2F;code&gt;] 格式的交叉引用标注符语法 —— 括号内的&lt;code&gt;Something&lt;&#x2F;code&gt;将会在最终文档中被添加正确的超链接。&lt;&#x2F;li&gt;
&lt;li&gt;多添加示例代码：如果接口应该如何使用并非一目了然的，那么添加一个使用该接口的&lt;code&gt;# Example&lt;&#x2F;code&gt;段落将会很有用。如在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rustdoc&#x2F;write-documentation&#x2F;documentation-tests.html&quot;&gt;文档注释&lt;&#x2F;a&gt;里的示例代码会在你执行&lt;code&gt;cargo test&lt;&#x2F;code&gt;（详情查看&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;testing.html&quot;&gt;第 13 条&lt;&#x2F;a&gt;）时编译并且运行，这一特性将有助于示例代码和它希望表述的代码保持一致。&lt;&#x2F;li&gt;
&lt;li&gt;为&lt;code&gt;panic&lt;&#x2F;code&gt;和&lt;code&gt;unsafe&lt;&#x2F;code&gt;的代码添加说明文档：如果存在会导致函数&lt;code&gt;panic&lt;&#x2F;code&gt;的输入，在文档（&lt;code&gt;# Panics&lt;&#x2F;code&gt;段落）里说明规避&lt;code&gt;panic!&lt;&#x2F;code&gt;的前置条件。同样地，在文档（&lt;code&gt;# Safety&lt;&#x2F;code&gt;段落）里说明&lt;code&gt;unsafe&lt;&#x2F;code&gt;代码的使用要求。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Rust 的&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;index.html&quot;&gt;标准库&lt;&#x2F;a&gt;是一个能够实践了上述所有细节的优秀示例。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gong-ju&quot;&gt;工具&lt;&#x2F;h2&gt;
&lt;p&gt;在注释文档中使用 Markdown 格式不仅意味着优美的输出，还意味着需要有一个明确的转换步骤（&lt;code&gt;cargo doc&lt;&#x2F;code&gt;）。而转换也就会增加出现问题的可能性。&lt;&#x2F;p&gt;
&lt;p&gt;对于这个问题，最简单的建议是在写完文档后，运行&lt;code&gt;cargo doc --open&lt;&#x2F;code&gt;（或者&lt;code&gt;cargo doc --no-deps --open&lt;&#x2F;code&gt;，这个指令能够严格约束仅产生当前包中的文档）并来&lt;em&gt;仔细阅读生成的结果&lt;&#x2F;em&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;对于所有生成超链接的有效性，你当然可以人工地去校验它们，或者让机器来完成这项工作 —— 通过&lt;code&gt;broken_intra_dock_links&lt;&#x2F;code&gt;的包特性&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;#![deny(broken_intra_doc_links)]

&#x2F;&#x2F;&#x2F; The bounding box for a [`Polygone`].
#[derive(Clone, Debug)]
pub struct BoundingBox {
    &#x2F;&#x2F; ...
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当特性生效的时候，&lt;code&gt;cargo doc&lt;&#x2F;code&gt;将会找出无效的链接：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;error: unresolved link to `Polygone`
 --&amp;gt; docs&#x2F;src&#x2F;main.rs:4:30
  |
4 | &#x2F;&#x2F;&#x2F; The bounding box for a [`Polygone`].
  |                              ^^^^^^^^ no item named `Polygone` in scope
  |
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;你也可以设置要求文档化，通过在包里设置&lt;code&gt;![warn(missing_docs)]&lt;&#x2F;code&gt;属性。当设置生效的时候，编译器将会给每个未配置文档的公开条目生成警告信息。然而，这样设置也存在着为了解决编译器报错而提供低质量注释文档的风险 —— 当然设置引入的问题不仅如此。&lt;&#x2F;p&gt;
&lt;p&gt;同样地，为了能够及时发现潜在风险，这些工具应该被纳入到你的持续集成系统（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;ci.html&quot;&gt;第 32 条&lt;&#x2F;a&gt;）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qi-ta-de-wen-dang-wei-zhi&quot;&gt;其他的文档位置&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;cargo doc&lt;&#x2F;code&gt;的输出是包中文档所在的主要位置，但并不是唯一的地方 —— 在项目中的其他地方添加注释也可以帮助用户理解如何使用你的代码。&lt;&#x2F;p&gt;
&lt;p&gt;在 Cargo 项目的&lt;code&gt;examples&#x2F;&lt;&#x2F;code&gt;子目录下可以添加一些方便使用包的示例代码。这些代码可以构建并运行，和集成测试（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;testing.html&quot;&gt;第 30 条&lt;&#x2F;a&gt;）的运行方式非常类似，不同的是这些代码提供的是便于理解包中接口使用的代码。&lt;&#x2F;p&gt;
&lt;p&gt;需要说明的是，&lt;code&gt;tests&#x2F;&lt;&#x2F;code&gt;子目录下的集成测试代码也可以给用户提供帮助，虽然它们的主要作用是测试包的对外接口。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fa-bu-bao-de-wen-dang&quot;&gt;发布包的文档&lt;&#x2F;h2&gt;
&lt;p&gt;如果你的包会发布到&lt;code&gt;crates.io&lt;&#x2F;code&gt;，项目的文档就可以在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;&quot;&gt;docs.rs&lt;&#x2F;a&gt;中查看到。docs.rs 是为发布的包构建并提供文档的官方 Rust 网站。&lt;&#x2F;p&gt;
&lt;p&gt;注意，&lt;code&gt;crates.io&lt;&#x2F;code&gt;和&lt;code&gt;docs.rs&lt;&#x2F;code&gt;的受众是不同的：&lt;code&gt;crates.io&lt;&#x2F;code&gt;旨在为选择包的用户提供服务，而&lt;code&gt;docs.rs&lt;&#x2F;code&gt;的受众是那些需要弄明白他们已经引用的包该如何使用的人（很明显的，这两种场景有很大的重叠）。&lt;&#x2F;p&gt;
&lt;p&gt;综上，一个包的主页在不同的地方会展示不同的内容：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docs.rs&lt;&#x2F;code&gt;：展示&lt;code&gt;cargo doc&lt;&#x2F;code&gt;产出结果的顶层页面，比如从顶层&lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;文件的&lt;code&gt;&#x2F;&#x2F;!&lt;&#x2F;code&gt;生成的文档。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;crates.io&lt;&#x2F;code&gt;：展示包含在项目仓库中的任何顶层&lt;em&gt;README.md&lt;&#x2F;em&gt; &lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;文件内容。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bu-wen-dang-hua-de-nei-rong&quot;&gt;不文档化的内容&lt;&#x2F;h2&gt;
&lt;p&gt;当一个项目&lt;em&gt;要求&lt;&#x2F;em&gt;公共条目都需要添加注释的时候，很容易就陷入到给无价值的内容也文档化的陷阱中。编译器的缺少注释文档的警告只是提醒你添加真正需要内容 —— 有用的文档 —— 的一种表现，并且仅仅期望程序员添加必要的内容来消除警告。&lt;&#x2F;p&gt;
&lt;p&gt;好的注释文档是一种能够帮助用户了解他们所使用代码的福利；糟糕的注释文档则增加了代码的维护成本并且让用户在它们不再和代码保持一致的时候变得更加困惑。那么好与不好的区别是什么呢？&lt;&#x2F;p&gt;
&lt;p&gt;最重要的建议是&lt;em&gt;避免重复可以从代码中看出的信息&lt;&#x2F;em&gt;。&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item1-use-types.html&quot;&gt;第 1 条&lt;&#x2F;a&gt;建议你的代码尽量的和 Rust 的类型系统保持一致；一旦你做到了这一点，就通过类型系统来说明这些语意。可以假定使用代码的用户对 Rust 已经熟悉了 —— 可能他们已经读了一些描述了如何高效使用语言的建议 —— 并且不需要重复从代码中的参数类型和函数签名中就能读出来的东西。&lt;&#x2F;p&gt;
&lt;p&gt;回到之前的例子，一个冗余的注释文档可能如下面描述的这样：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Return a new [`BoundingBox`] object that exactly encompasses a pair
&#x2F;&#x2F;&#x2F; of [`BoundingBox`] objects.
&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F;&#x2F; Parameters:
&#x2F;&#x2F;&#x2F;  - `a`: an immutable reference to a `BoundingBox`
&#x2F;&#x2F;&#x2F;  - `b`: an immutable reference to a `BoundingBox`
&#x2F;&#x2F;&#x2F; Returns: new `BoundingBox` object.
pub fn union(a: &amp;amp;BoundingBox, b: &amp;amp;BoundingBox) -&amp;gt; BoundingBox {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个注释重复了很多从函数签名中就能读到的信息，注释信息毫无益处。&lt;&#x2F;p&gt;
&lt;p&gt;更糟的是，考虑一种代码重构后，将结果存储到其中一个参数（这是一种不兼容的变更；参照&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;semver.html&quot;&gt;第 21 条&lt;&#x2F;a&gt;）。没有编译器或者工具能够发现注释没有随之更新，结果就产生了一个未能和代码逻辑保持一致的注释：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Return a new [`BoundingBox`] object that exactly encompasses a pair
&#x2F;&#x2F;&#x2F; of [`BoundingBox`] objects.
&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F;&#x2F; Parameters:
&#x2F;&#x2F;&#x2F;  - `a`: an immutable reference to a `BoundingBox`
&#x2F;&#x2F;&#x2F;  - `b`: an immutable reference to a `BoundingBox`
&#x2F;&#x2F;&#x2F; Returns: new `BoundingBox` object.
pub fn union(a: &amp;amp;mut BoundingBox, b: &amp;amp;BoundingBox) {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;相反地，原本恰当的注释在重构中则可以毫发无损地保留下来，因为它的文本描述的是行为，而非语意本身：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Calculate the [`BoundingBox`] that exactly encompasses a pair
&#x2F;&#x2F;&#x2F; of [`BoundingBox`] objects.
pub fn union(a: &amp;amp;mut BoundingBox, b: &amp;amp;BoundingBox) {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;先前的建议也可以帮助提升文档质量：&lt;em&gt;在文档中包含任何从代码中无法了解的内容&lt;&#x2F;em&gt;。这包含前置条件、可变性、异常、报错条件以及任何可能会让用户感到意外的事情；如果你的代码不能遵守&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Principle_of_least_astonishment&quot;&gt;最小惊讶原则&lt;&#x2F;a&gt;，确保这些意外都被记录在文档里，至少你可以说“我已经告诉过你了”。&lt;&#x2F;p&gt;
&lt;p&gt;另一个常见的失败情形是，注释里描述了其他使用这个方法的代码，而非这个方法做了什么：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Return the intersection of two [`BoundingBox`] objects, returning `None`
&#x2F;&#x2F;&#x2F; if there is no intersection. The collision detection code in `hits.rs`
&#x2F;&#x2F;&#x2F; uses this to do an initial check to see whether two objects might overlap,
&#x2F;&#x2F;&#x2F; before performing the more expensive pixel-by-pixel check in
&#x2F;&#x2F;&#x2F; `objects_overlap`.
pub fn intersection(
    a: &amp;amp;BoundingBox,
    b: &amp;amp;BoundingBox,
) -&amp;gt; Option&amp;lt;BoundingBox&amp;gt; {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;像这样的注释几乎不可能和代码保持一致：当使用了这个方法的代码（比如，&lt;code&gt;hits.rs&lt;&#x2F;code&gt;）变更的时候，这段描述了调用行为的注释相隔甚远而无法保持一致。&lt;&#x2F;p&gt;
&lt;p&gt;应当将注释重新组织以聚焦在&lt;em&gt;为什么&lt;&#x2F;em&gt;这样使用，可以让这段注释更好的适应未来的变更。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Return the intersection of two [`BoundingBox`] objects, returning `None`
&#x2F;&#x2F;&#x2F; if there is no intersection.  Note that intersection of bounding boxes
&#x2F;&#x2F;&#x2F; is necessary but not sufficient for object collision -- pixel-by-pixel
&#x2F;&#x2F;&#x2F; checks are still required on overlap.
pub fn intersection(
    a: &amp;amp;BoundingBox,
    b: &amp;amp;BoundingBox,
) -&amp;gt; Option&amp;lt;BoundingBox&amp;gt; {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当编写软件时，“面向未来的编程”&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;是一种很好的实践：调整代码结构以适应未来的变更。同样的原则也适用于文档：聚焦在语意，为什么这样做以及为什么不这样做，会让文本在未来的运行中始终是有意义的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;给公共的 API 内容添加注释文档。&lt;&#x2F;li&gt;
&lt;li&gt;为那些从代码中无法明确看出的内容添加描述 —— 比如&lt;code&gt;panics&lt;&#x2F;code&gt;以及&lt;code&gt;unsafe&lt;&#x2F;code&gt;的条件。&lt;&#x2F;li&gt;
&lt;li&gt;不要给可以从代码中明确看出的内容重复描述。&lt;&#x2F;li&gt;
&lt;li&gt;通过交叉引用及添加标志符来让导航变得明确。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;zhu-shi&quot;&gt;注释&lt;&#x2F;h3&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;这个配置也曾称成为&lt;code&gt;intra_doc_link_resolution_failure&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;包含 &lt;em&gt;README.md&lt;&#x2F;em&gt; 的引用动作可以被&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;manifest.html#the-readme-field&quot;&gt;Cargo.toml 中的 readme 字段&lt;&#x2F;a&gt;覆盖。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;Scott Meyers，More Effective C++ (Addison-Wesley)，第 32 条。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;原文&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;documentation.html&quot;&gt;点这里&lt;&#x2F;a&gt;查看。&lt;&#x2F;p&gt;
&lt;!-- 参考链接 --&gt;
</content>
        
    </entry>
</feed>
