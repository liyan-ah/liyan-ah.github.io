<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title>李岩的博客</title>
    <subtitle>努力做个程序员</subtitle>
    <link rel="self" type="application/atom+xml" href="https://liyan-ah.github.io/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://liyan-ah.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2026-02-25T10:51:14+08:00</updated>
    <id>https://liyan-ah.github.io/atom.xml</id>
    <entry xml:lang="zh-CN">
        <title>从Hugo到Zola——又一次博客迁移</title>
        <published>2026-02-25T10:51:14+08:00</published>
        <updated>2026-02-25T10:51:14+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/migrate-blog-from-hugo-to-zola/"/>
        <id>https://liyan-ah.github.io/migrate-blog-from-hugo-to-zola/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/migrate-blog-from-hugo-to-zola/">&lt;p&gt;又迁移博客了。回顾下最早的博客是使用&lt;code&gt;Hexo&lt;&#x2F;code&gt;写的，当时工作了两年，希望能通过一种方式对工作中的经验进行整理。&lt;code&gt;Hexo&lt;&#x2F;code&gt;的完成度很高，可以直接在&lt;code&gt;Hexo-Admin&lt;&#x2F;code&gt;中对博客进行撰写，同时实时渲染，查看效果。但是每次在使用时，往往会遇到很多依赖的更新，而且往往会有一些不兼容——可能是本地环境和博文框架的不兼容，或者是依赖升级后的不兼容。厌倦了长久的依赖升级等待以及冲突修复后，我从&lt;code&gt;Hexo&lt;&#x2F;code&gt;迁移到了&lt;code&gt;Hugo&lt;&#x2F;code&gt;。&lt;code&gt;Hugo&lt;&#x2F;code&gt;的完成度同样非常高，直接从网络上使用一个公开的模版即可流畅的启动，自己撰写一个简易的迁移脚本即可完成博文主要内容的迁移。&lt;code&gt;Hugo&lt;&#x2F;code&gt;迁移至&lt;code&gt;Zola&lt;&#x2F;code&gt;的契机是26年的2月12日，提交了一篇博客&lt;a href=&quot;&#x2F;handle-chain&#x2F;&quot;&gt;一种责任链模式的实现&lt;&#x2F;a&gt;，2月24日查看时，发现未更新。确认是&lt;code&gt;deploy.yml&lt;&#x2F;code&gt;执行&lt;code&gt;build&lt;&#x2F;code&gt;时出现失败，解决未果，遂弃之。使用&lt;code&gt;Zola&lt;&#x2F;code&gt;来重新启动。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qian-yi-ti-yan&quot;&gt;迁移体验&lt;&#x2F;h2&gt;
&lt;p&gt;总体来看尚可，从三个方面来评价迁移体验。就迁移后至今的使用来看，&lt;code&gt;Zola&lt;&#x2F;code&gt;的使用方式和&lt;code&gt;Hugo&lt;&#x2F;code&gt;相比是很接近的，基本上一个指令即可启动。完成度上，仍然是&lt;code&gt;Hexo&lt;&#x2F;code&gt;最好，&lt;code&gt;Hugo&lt;&#x2F;code&gt;次之，&lt;code&gt;Zola&lt;&#x2F;code&gt;看着完成度欠缺。&lt;code&gt;Hexo&lt;&#x2F;code&gt;支持&lt;code&gt;Admin&lt;&#x2F;code&gt;插件来新建、编辑、发布博客；&lt;code&gt;Hugo&lt;&#x2F;code&gt;支持命令行新建一篇博文；&lt;code&gt;Zola&lt;&#x2F;code&gt;则只能手动操作了。另一个重要的特性是使用的可靠性，这个可能更多的是和博客的主题选择有关。本次迁移后使用的是&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;st1020&#x2F;kita&quot;&gt;Kita&lt;&#x2F;a&gt;主题，主题较为简洁，具备基础性的功能——对应的是一些功能的缺失，如留言功能和全局搜索功能，这两个功能对我而言都可有可无。&lt;&#x2F;p&gt;
&lt;p&gt;迁移后，博客通过&lt;code&gt;Emacs&lt;&#x2F;code&gt;的&lt;code&gt;eww&lt;&#x2F;code&gt;仍然能够较为便捷的访问。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qian-yi-guo-cheng&quot;&gt;迁移过程&lt;&#x2F;h2&gt;
&lt;p&gt;依稀记得此前的&lt;code&gt;Hugo&lt;&#x2F;code&gt;迁移过程还是比较顺利的，主要是对此前博文的一些标签的格式转换。本次迁移在大模型的加持下，一些格式转换是非常容易做的。只是主题使用上有一些繁琐。下面记录下我这里的过程，希望能够提供一些参考。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;主题设置
拷贝一份目标主题的博客，这样就能够省去很多参数的配置的工作。本人这里拷贝的是&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;st1020&#x2F;blog&quot;&gt;st1020&#x2F;blog&lt;&#x2F;a&gt; &lt;code&gt;Kita&lt;&#x2F;code&gt;作者本人的博客参数设置。拷贝后主要做&lt;code&gt;content&#x2F;&lt;&#x2F;code&gt;博文目录的调整和&lt;code&gt;static&#x2F;&lt;&#x2F;code&gt;目录下各种&lt;code&gt;icon&lt;&#x2F;code&gt;的调整。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;拷贝后保留&lt;code&gt;content&#x2F;&lt;&#x2F;code&gt;目录下的&lt;code&gt;_index.md&lt;&#x2F;code&gt;和&lt;code&gt;pages&#x2F;&lt;&#x2F;code&gt;，目录下的其他博文内容删除。调整&lt;code&gt;config.toml&lt;&#x2F;code&gt;中的博文说明内容、博客首页栏目内容，调整&lt;code&gt;content&#x2F;pages&#x2F;about.md&lt;&#x2F;code&gt;中的个人介绍。&lt;&#x2F;li&gt;
&lt;li&gt;将此前&lt;code&gt;Hugo&lt;&#x2F;code&gt;主题下的行走&lt;code&gt;icon&lt;&#x2F;code&gt;拷贝到了&lt;code&gt;static&lt;&#x2F;code&gt;目录下，通过大模型来对目录下原有&lt;code&gt;icon&lt;&#x2F;code&gt;进行替换。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这样一来，主题设置初步完成。&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;博文迁移
将旧博文中的文档迁移到新博文目录的&lt;code&gt;content&#x2F;&lt;&#x2F;code&gt;目录下。&lt;code&gt;Hugo&lt;&#x2F;code&gt;中也是在&lt;code&gt;content&#x2F;&lt;&#x2F;code&gt;目录，我这里是直接进行的拷贝。拷贝后需要对如下内容进行调整：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;博文中的前置变量。此前我的博文前置变量使用的是&lt;code&gt;Yaml&lt;&#x2F;code&gt;格式，这次迁移使用大模型全部转换为了&lt;code&gt;Toml&lt;&#x2F;code&gt;格式。&lt;code&gt;categories&lt;&#x2F;code&gt;和&lt;code&gt;tags&lt;&#x2F;code&gt;需要放置在&lt;code&gt;[taxonomies]&lt;&#x2F;code&gt;配置下。&lt;&#x2F;li&gt;
&lt;li&gt;博文目录文档名。&lt;code&gt;Zola&lt;&#x2F;code&gt;上实践较好的是&lt;code&gt;content&#x2F;{{blog-name}}&#x2F;index.md&lt;&#x2F;code&gt;。此前&lt;code&gt;Hugo&lt;&#x2F;code&gt;中的博文对于博文的文档名没有过多的限制，而&lt;code&gt;Zola&lt;&#x2F;code&gt;上默认是识别&lt;code&gt;index.md&#x2F;_index.md&lt;&#x2F;code&gt;。从实践中看，将旧的博文文档都调整成&lt;code&gt;content&#x2F;{{blog-name}}&#x2F;index.md&lt;&#x2F;code&gt;效果较好。&lt;&#x2F;li&gt;
&lt;li&gt;处理图片。此前&lt;code&gt;Hugo&lt;&#x2F;code&gt;中将图片均放置在&lt;code&gt;public&#x2F;&lt;&#x2F;code&gt;目录下。本次迁移将&lt;code&gt;public&#x2F;&lt;&#x2F;code&gt;下的图片均放置到博文目录中，便于管理。这一步也由大模型进行处理。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;上述内容设置完成后，在本地是可以直接启动并且预览的。如果都没有问题，即可以发起迁移。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;基于旧博文的主分支克隆一个备份的分支。做个备份，留个念想。&lt;&#x2F;li&gt;
&lt;li&gt;使用新博文的文件覆盖博文主分支的文件。由于本人在&lt;code&gt;github&lt;&#x2F;code&gt;上创建了&lt;code&gt;Action&lt;&#x2F;code&gt;，会触发博文内容的编译，因此&lt;code&gt;public&#x2F;&lt;&#x2F;code&gt;目录中的内容对我而言是不需要的。这里覆盖后清理了&lt;code&gt;public&#x2F;&lt;&#x2F;code&gt;下生成的博文页。&lt;&#x2F;li&gt;
&lt;li&gt;更新博文主分支，等待&lt;code&gt;Action&lt;&#x2F;code&gt;执行。这里补充一些细节，我的博文主分支是&lt;code&gt;master&lt;&#x2F;code&gt;，在&lt;code&gt;github&lt;&#x2F;code&gt;个人页上配置的博文分支是&lt;code&gt;gh-pages&lt;&#x2F;code&gt;。我这里的更新指的是更新&lt;code&gt;master&lt;&#x2F;code&gt;分支。更新后，&lt;code&gt;github&lt;&#x2F;code&gt;会依据&lt;code&gt;master&lt;&#x2F;code&gt;分支中的&lt;code&gt;.github&#x2F;workflows&#x2F;deploy.yml&lt;&#x2F;code&gt;配置的&lt;code&gt;Action&lt;&#x2F;code&gt;对&lt;code&gt;master&lt;&#x2F;code&gt;上的内容触发&lt;code&gt;zola build&lt;&#x2F;code&gt;，并将&lt;code&gt;master&lt;&#x2F;code&gt;分支中的&lt;code&gt;public&#x2F;&lt;&#x2F;code&gt;更新到&lt;code&gt;gh-pages&lt;&#x2F;code&gt;分支，从而完成对博文的更新。这样一来，&lt;code&gt;master&lt;&#x2F;code&gt;分支即可无需保存诸多的编译产物，保持&lt;code&gt;master&lt;&#x2F;code&gt;分支的简洁。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;本次迁移相比&lt;code&gt;Hexo&lt;&#x2F;code&gt;迁移到&lt;code&gt;Hugo&lt;&#x2F;code&gt;，迁移的诉求更加明确——只希望能够尽可能稳定的保留博客的基础功能，尽可能多的去除额外的可能会带来维护成本的功能。本次迁移由于大量的使用了大模型，因此很多的程序性工作完成的都很顺利。确实是大模型的时代了。&lt;&#x2F;p&gt;
&lt;p&gt;以上，新春愉快～&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>个人介绍</title>
        <published>2026-02-24T20:00:00+08:00</published>
        <updated>2026-02-24T20:00:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/about/"/>
        <id>https://liyan-ah.github.io/about/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/about/">&lt;!-- markdownlint-disable-file no-inline-html --&gt;
&lt;p style=&quot;text-align: center&quot;&gt;
后之视今，亦犹今之视昔
&lt;&#x2F;p&gt;
&lt;p style=&quot;text-align: right; font-style: italic;&quot;&gt;
王羲之（兰亭集序）
&lt;&#x2F;p&gt;
 &lt;!----&gt;


&lt;div
  class=&quot;my-4 flex flex-col rounded-lg bg-[var(--admonition-bg)]&quot;
  style=&quot;--admonition-bg: rgba(0, 200, 83, 0.1)&quot;
&gt;
  &lt;div class=&quot;flex items-center rounded-t-lg bg-[var(--admonition-bg)] p-1&quot;&gt;
    &lt;div
      class=&quot;mx-2 h-4 w-4 text-[0px] [background:var(--url)_center_center_no-repeat] dark:invert&quot;
      style=&quot;--url: url(.&#x2F;icons&#x2F;success.svg)&quot;
    &gt;
      success
    &lt;&#x2F;div&gt;
    &lt;span&gt;&lt;strong&gt;基础信息&lt;&#x2F;strong&gt;&lt;&#x2F;span&gt;
  &lt;&#x2F;div&gt;
  &lt;div class=&quot;pl-4&quot;&gt;&lt;ul&gt;
&lt;li&gt;后端工程师&lt;&#x2F;li&gt;
&lt;li&gt;混迹于信息科技企业&lt;&#x2F;li&gt;
&lt;li&gt;人菜瘾大&lt;&#x2F;li&gt;
&lt;li&gt;Github：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
 &lt;!----&gt;


&lt;div
  class=&quot;my-4 flex flex-col rounded-lg bg-[var(--admonition-bg)]&quot;
  style=&quot;--admonition-bg: rgba(68, 138, 255, 0.1)&quot;
&gt;
  &lt;div class=&quot;flex items-center rounded-t-lg bg-[var(--admonition-bg)] p-1&quot;&gt;
    &lt;div
      class=&quot;mx-2 h-4 w-4 text-[0px] [background:var(--url)_center_center_no-repeat] dark:invert&quot;
      style=&quot;--url: url(.&#x2F;icons&#x2F;note.svg)&quot;
    &gt;
      note
    &lt;&#x2F;div&gt;
    &lt;span&gt;&lt;strong&gt;专业知识&lt;&#x2F;strong&gt;&lt;&#x2F;span&gt;
  &lt;&#x2F;div&gt;
  &lt;div class=&quot;pl-4&quot;&gt;&lt;details&gt;
&lt;summary&gt;行业知识&lt;&#x2F;summary&gt;
&lt;ul&gt;
&lt;li&gt;科技零售&lt;&#x2F;li&gt;
&lt;li&gt;出行&lt;&#x2F;li&gt;
&lt;li&gt;语音&lt;&#x2F;li&gt;
&lt;li&gt;搜索&lt;&#x2F;li&gt;
&lt;li&gt;职业道德&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;details&gt;
&lt;details&gt;
&lt;summary&gt;领域知识&lt;&#x2F;summary&gt;
&lt;ul&gt;
&lt;li&gt;LSM-Tree 存储
&lt;ul&gt;
&lt;li&gt;日志存储系统&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;可观测
&lt;ul&gt;
&lt;li&gt;MTL融合&lt;&#x2F;li&gt;
&lt;li&gt;OpenTelemetry&lt;&#x2F;li&gt;
&lt;li&gt;无侵入采集&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;搜索引擎
&lt;ul&gt;
&lt;li&gt;一级引擎（精排）&lt;&#x2F;li&gt;
&lt;li&gt;二级引擎（粗排）&lt;&#x2F;li&gt;
&lt;li&gt;排序策略
&lt;ul&gt;
&lt;li&gt;决策树&lt;&#x2F;li&gt;
&lt;li&gt;LTR&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;排序质量
&lt;ul&gt;
&lt;li&gt;召回率&lt;&#x2F;li&gt;
&lt;li&gt;准确率&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;details&gt;
&lt;details&gt;
&lt;summary&gt;技术栈&lt;&#x2F;summary&gt;
&lt;ul&gt;
&lt;li&gt;微服务
&lt;ul&gt;
&lt;li&gt;RPC
&lt;ul&gt;
&lt;li&gt;Thrift&lt;&#x2F;li&gt;
&lt;li&gt;GRPC&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;缓存
&lt;ul&gt;
&lt;li&gt;Redis&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;RDS
&lt;ul&gt;
&lt;li&gt;MySQL&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;BPF
&lt;ul&gt;
&lt;li&gt;观测工具
&lt;ul&gt;
&lt;li&gt;bpftrace&lt;&#x2F;li&gt;
&lt;li&gt;cilium-bpf&lt;&#x2F;li&gt;
&lt;li&gt;Aya&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;应用层观测
&lt;ul&gt;
&lt;li&gt;Golang 调用链路观测&lt;&#x2F;li&gt;
&lt;li&gt;LVS FullNat&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;操作系统观测
&lt;ul&gt;
&lt;li&gt;TCP&#x2F;UDP 调用&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;存储
&lt;ul&gt;
&lt;li&gt;LSM-Tree
&lt;ul&gt;
&lt;li&gt;InfluxDB&lt;&#x2F;li&gt;
&lt;li&gt;LevelDB&lt;&#x2F;li&gt;
&lt;li&gt;RocksDB&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;DataFusion
&lt;ul&gt;
&lt;li&gt;Ballista&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;MemoryDB
&lt;ul&gt;
&lt;li&gt;DuckDB&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;可观测
&lt;ul&gt;
&lt;li&gt;Profilling
&lt;ul&gt;
&lt;li&gt;火焰图&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Metric
&lt;ul&gt;
&lt;li&gt;Prometheus&lt;&#x2F;li&gt;
&lt;li&gt;Grafana&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;details&gt;
&lt;details&gt;
&lt;summary&gt;编程技能&lt;&#x2F;summary&gt;
&lt;ul&gt;
&lt;li&gt;Python&lt;&#x2F;li&gt;
&lt;li&gt;Shell&lt;&#x2F;li&gt;
&lt;li&gt;Go&lt;&#x2F;li&gt;
&lt;li&gt;Rust&lt;&#x2F;li&gt;
&lt;li&gt;Vibe Coding&lt;&#x2F;li&gt;
&lt;li&gt;Learning...&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;details&gt;&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
 &lt;!----&gt;


&lt;div
  class=&quot;my-4 flex flex-col rounded-lg bg-[var(--admonition-bg)]&quot;
  style=&quot;--admonition-bg: rgba(0, 191, 165, 0.1)&quot;
&gt;
  &lt;div class=&quot;flex items-center rounded-t-lg bg-[var(--admonition-bg)] p-1&quot;&gt;
    &lt;div
      class=&quot;mx-2 h-4 w-4 text-[0px] [background:var(--url)_center_center_no-repeat] dark:invert&quot;
      style=&quot;--url: url(.&#x2F;icons&#x2F;tip.svg)&quot;
    &gt;
      tip
    &lt;&#x2F;div&gt;
    &lt;span&gt;&lt;strong&gt;兴趣爱好&lt;&#x2F;strong&gt;&lt;&#x2F;span&gt;
  &lt;&#x2F;div&gt;
  &lt;div class=&quot;pl-4&quot;&gt;&lt;ul&gt;
&lt;li&gt;运动
&lt;ul&gt;
&lt;li&gt;爬山&lt;&#x2F;li&gt;
&lt;li&gt;跑步&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;读书&lt;&#x2F;li&gt;
&lt;li&gt;电影&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>一种责任链模式的实现</title>
        <published>2026-02-12T11:40:14+08:00</published>
        <updated>2026-02-12T11:40:14+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/handle-chain/"/>
        <id>https://liyan-ah.github.io/handle-chain/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/handle-chain/">&lt;blockquote&gt;
&lt;p&gt;许久没有写博客了，25年全年都没有更新。估计26年上半年还会继续占用时间，想写点东西还是比较困难的。今天整理了下遇到的比较优美的代码，发出来赏析下。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;责任链模式的常见使用场景是对目标数据需要进行多个独立规则的校验，如请求参数能否解析、参数中的业务指标是否非法、权限信息是否正常等。这种需求一般可以将校验的过程抽象成一个接口，然后将每个校验操作都封装成一个接口的实现，在校验管理器中维护一个注册、校验函数。但是这种方法并不优美，尤其是对于&lt;code&gt;Rust&lt;&#x2F;code&gt;语言来说，&lt;code&gt;Rust&lt;&#x2F;code&gt;本身的链式操作是很优美的，将这些校验操作进行封装，通过链式操作来生效则会比较优雅。&lt;&#x2F;p&gt;
&lt;p&gt;如下是其中的一个通用实现。这里&lt;code&gt;Handler&lt;&#x2F;code&gt;是抽象出来的处理接口，而&lt;code&gt;HandlerA&lt;&#x2F;code&gt;是其中的一个实现。通过定义&lt;code&gt;HandlerChainExt&lt;&#x2F;code&gt; 接口以及 &lt;code&gt;Chain&lt;&#x2F;code&gt; 结构体，即可实现在不改变&lt;code&gt;Handler&lt;&#x2F;code&gt;定义以及&lt;code&gt;HandlerA&lt;&#x2F;code&gt;实现的前提下完成链式操作。这无疑是非常优雅的。而且通过下面的单测示例可以看到，&lt;code&gt;.and_then&lt;&#x2F;code&gt;的调用方式极其简洁、明了。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;Rust&quot;&gt;#[cfg(test)]
mod tests {
    use std::fmt::Debug;

    use anyhow;
    use tracing::tracing::debug;

    #[async_trait]
    trait Handler: Debug + Send + Sync {
        type WriteInput: Debug + Send + Sync;
        type WriteOutput: Debug + Send + Sync;
        async fn check(&amp;amp;self, input: Self::WriteInput) -&amp;gt; anyhow::Result&amp;lt;Self::WriteOutput&amp;gt;;
    }

    #[derive(Debug)]
    struct HandlerA {
        output: String,
    }

    impl HandlerA {
        fn new(output: String) -&amp;gt; Self {
            Self { output }
        }
    }

    #[async_trait]
    impl Handler for HandlerA {
        type WriteInput = String;
        type WriteOutput = String;

        async fn check(&amp;amp;self, input: String) -&amp;gt; Result&amp;lt;String, anyhow::Error&amp;gt; {
            debug!(&amp;quot;handler A, {input}&amp;quot;);
            println!(&amp;quot;handler A, input: {input}&amp;quot;);
            println!(&amp;quot;hanlder A, output: {input}|{}&amp;quot;, self.output);
            Ok(format!(&amp;quot;{input}|{}&amp;quot;, self.output))
        }
    }

    trait HandlerChainExt: Handler + Sized {
        fn and_then&amp;lt;T&amp;gt;(self, next: T) -&amp;gt; Chain&amp;lt;Self, T&amp;gt;
        where
            T: Handler,
        {
            Chain {
                first: self,
                second: next,
            }
        }
    }

    impl&amp;lt;T&amp;gt; HandlerChainExt for T where T: Handler {}

    #[derive(Debug)]
    struct Chain&amp;lt;T, U&amp;gt; {
        first: T,
        second: U,
    }

    impl&amp;lt;T, U&amp;gt; Chain&amp;lt;T, U&amp;gt; {
        #[allow(dead_code)]
        fn new(first: T, second: U) -&amp;gt; Self {
            Self { first, second }
        }
    }

    #[async_trait]
    impl&amp;lt;T, U&amp;gt; Handler for Chain&amp;lt;T, U&amp;gt;
    where
        T: Handler,
        U: Handler&amp;lt;WriteInput = T::WriteOutput&amp;gt;,
    {
        type WriteInput = T::WriteInput;
        type WriteOutput = U::WriteOutput;

        async fn check(&amp;amp;self, input: Self::WriteInput) -&amp;gt; anyhow::Result&amp;lt;Self::WriteOutput&amp;gt; {
            let output = self.first.check(input).await?;
            self.second.check(output).await
        }
    }

    #[tokio::test]
    async fn test_handler_chain() {
        let handler = HandlerA::new(&amp;quot;aa&amp;quot;.into())
            .and_then(HandlerA::new(&amp;quot;bb&amp;quot;.into()))
            .and_then(HandlerA::new(&amp;quot;cc&amp;quot;.into()));
        assert!(handler
            .check(&amp;quot;raw_input&amp;quot;.into())
            .await
            .is_ok_and(|x| x == &amp;quot;raw_input|aa|bb|cc&amp;quot;));
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Rust&lt;&#x2F;code&gt;语言的特点使得很多代码实现显得非常优雅，后面再找一些。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>翦商</title>
        <published>2026-01-30T14:50:32+08:00</published>
        <updated>2026-01-30T14:50:32+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/jian-shang/"/>
        <id>https://liyan-ah.github.io/jian-shang/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/jian-shang/">&lt;h2 id=&quot;jian-shang-jie-shao&quot;&gt;《翦商》介绍&lt;&#x2F;h2&gt;
&lt;p&gt;《翦商：殷周之变与华夏新生》一书从考古出发，对夏、商、周三代的起源、更替进行了介绍。其中由于夏朝以及早商的文献资料较少，主要以考古内容来展开，晚商，尤其是周代商的这段时间，则结合考古内容，对文献中的记录进行推测、猜想（《尚书》《周易》《诗经》《左传》《史记》等）。如，通过夏遗址中的水稻千粒重占主粮的比例以及同区域更早考古发现中的主粮构成，推测“大禹治水”实际上是改造湿地、开发稻田的活动。稻田的发展提升了夏的生产力，进而推动夏文化的发展，特别地，出现了青铜的使用。而“周”与“商”的交流，则通过“周原”的考古（殉葬坑、生活区的考古等）结合《诗经·大雅·绵》以及《周易》中的需卦&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;的卦辞来推测，“周”是在晚商时，由商朝的军事贵族“崇侯&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;”从更偏僻的羌人处召集到“周原”，从而成为商朝附庸的。周的主要工作是为商王捕获羌人作为祭品。&lt;&#x2F;p&gt;
&lt;p&gt;《翦商》中引用了大量的考古实际报告和内容，晚商时期的内容又结合考古内容，对上古的经典文献进行考证，提供了一种非常有趣的视角。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nei-rong-tao-lun&quot;&gt;内容讨论&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;wei-shen-me-yao-jian-shang&quot;&gt;为什么要翦商&lt;&#x2F;h3&gt;
&lt;p&gt;对于商来说，祭祀是第一生产力。祭祀是商王沟通其祖先的一种方式，万事不决则通过祭祀来向先人询问。商人祭祀的场景有很多，如每到一地，营建时会处决俘虏并将其埋在建筑的地基里，希望通过这种方式，用俘虏的鬼魂来护卫房屋；武丁王的妻子，妇好，在去世时，商王曾多次占卜，确认是否是某个先祖将妇好带走了——相信这里也少不了祭祀的过程。同时，商人认为祭祀的俘虏身份越高，祭祀的效果越好——比如使用羌人的首领。为了获得更多的羌人进行祭祀，商人向周边进行武力扩张、更广泛地使用青铜器，后来的“周”人也是为此才能成为商人附庸的。同时，祭祀行为也可以团结商内部的贵族——考古发现，早商时，商王曾经尝试停止以人来祭祀，而通过掩埋青铜器的方式。但是这种行为仅持续了很短的时间，这个商王可能因此被其他贵族推翻了。由此可知，祭祀是维护商的统治、促使商逐步扩张的主要动力，可谓是商朝的第一生产力。&lt;&#x2F;p&gt;
&lt;p&gt;“周”人却是来自羌人，做了商人的附庸之后，会利用商人带来的青铜器以及马车来讨伐更偏远的羌人以向商人献囚。早些时候，是通过崇侯来进行俘虏奉献的。随着周人地位的提高，可能后来得到了商王的召见，并且得到了商王的认可。纣王将伯邑考的肉酱赐给周文王——通过商人的宗教形式表示对其的认可，而后封文王为周方伯。但是周文王和周武王可能对商王的行为很不认可&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;，由此开始了翦商的筹划。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zen-me-jian-shang-de&quot;&gt;怎么翦商的&lt;&#x2F;h3&gt;
&lt;p&gt;首先是对占卜的学习。由于商时，通过祭祀来沟通先祖被认为是非常灵验的事情，而周人并不掌握占卜的技巧。周文王通过了很长时间的学习才掌握了这种能力，认为是具有了和神灵交流的能力。考古发现在周文王宅院里，有一处地窖中存在很多用来占卜的龟甲碎片。显然，周文王暗地里进行了很长时间的占卜学习，而这种行为在当时是被商王绝对禁止的。周文王通过占卜的学习，并且结合周人自己的经历，给占卜结果做了卜辞的注解，也就是《周易》里卦辞的内容。并且认识到，上帝的意志并非是不变的，上帝也并非是始终偏好商人，这一切都可能会发生变化。这给了周文王以信心。&lt;&#x2F;p&gt;
&lt;p&gt;然后是团结周边的部落，尤其是羌人。而起到连接作用的，则是姜尚（姜是羌人的姓，姬则是源自姜的姓）。姜子牙是在商的都城从事屠宰工作的羌人，可能是作为俘虏到商城的。由于长期在商的都城，姜尚对商的情况比较熟悉，而且又能够团结羌人。周文王、周武王通过姜尚来团结周边的部落，实现“翦商”大业。&lt;&#x2F;p&gt;
&lt;p&gt;作者认为，《周易》中有很多反映“翦商”的内容&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：
艮下、震上：小过卦
&lt;img src=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;jian-shang&#x2F;%E5%B0%8F%E8%BF%87.png&quot; alt=&quot;小过&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;其中，小过卦曰：“亨，利贞。可小事，不可大事。飞鸟遗之音， 不宜上，宜下。大吉。”大意是说，祭祀，占卜结果有利。可以做小事，不可以做大事。飞鸟会向其传送声音。不宜向上，宜向下，大吉。
初六爻的“飞鸟以凶”是说飞鸟带来坏运气；六五爻的“公弋，取彼在穴”是说用“弋”（系着丝线的箭）射鸟，鸟进入了 “穴”中, 但还是被“公”（文王）找到了；上六爻的“弗遇，过之。飞鸟离之， 凶，是谓灾眚（sheng,3。灾祸，目疾）” 则是说，没有遇到，错过了，而遇到飞鸟乃凶险之兆。

文王对于“飞鸟”的奇怪态度，应该和商族人对鸟的崇拜有关。“天命玄鸟，降而生商。”商人认为，鸟是商族的保护神，为上帝传递消息的信使，所以在甲骨卜辞的记载中，商王经常用牲畜及人牲向“鸟” 献祭。而这显然会让心存翦商之念的文王产生疑心和恐慌，把飞鸟视 作凶险的信号，所谓“飞鸟遗之音”，即是担心鸟类会察觉到自己的谋逆行为，并用某种方式传递给商纣王。既然飞鸟会是商王的耳目和帮凶，周昌就要采取禳解法术，比如，射猎飞鸟。除了上文的“公弋，取彼在穴”，《易经》中还有好几处用弓箭射鸟的记载。解卦上六爻曰：“公用射隼于高墉之上，获之，无 不利」意思是说，公在高高的城墙上射隼，成功猎获，一切均顺利。“公”是周人的词，《易经》中的“公”显然是指文王本人或周族先君。 而“射隼”颇有巫术色彩，因为隼是小型猛禽，没有食用价值，一般 不会是捕猎对象。文王从未试图塑造过自己的勇武形象，一直强调的是文德，这从他自定的尊号“文王”就可见一斑。所以，这种在高墙上射隼的表演，很可能是一种用巫术对抗魔法的行为，目的是祛除“飞鸟以凶”的超自然力量。“公用射隼于高墉之上”的“用”字也颇有意义，这里或可译为“用这种法术&amp;quot;。倘若没有这个“用”字,这句爻辞就是一个叙事和陈述句，但有了“用”字，它就不只是一个简单的事实记录，还含有记载巫术的施用方法和功效之意。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;更重要的是，周文王、周武王之后，周公旦接续了翦商的大业——通过将商族迁至不同的区域防止人祀的大规模延续以及推广道德的观念从源头断绝商文化的正统性。尽管在商人的封国——宋——仍旧有某种程度上的暴戾文化，但是相对于殷商来说已经大大的减轻了。&lt;&#x2F;p&gt;
&lt;p&gt;尤记得周公旦的文化翦商部分是我在一个晚上读完的。读到孔子理解了周公的行为并继承其遗志继续推广仁政时，心里久久不能平静，可能这就是一种文化上的传递与共鸣吧。我们的文化之所以有今天的以人为本，有今天的人文关怀，有今天的与众不同，离不开先哲们的矢志不渝。&lt;&#x2F;p&gt;
&lt;p&gt;这里有一个更好的图书介绍，可供参考&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;paper.people.com.cn&#x2F;zgcsb&#x2F;images&#x2F;2022-11&#x2F;21&#x2F;23&#x2F;zgcsb2022112123.pdf&quot;&gt;拨迷雾见微光，探索商周历史真相 ——读李硕《翦商：殷周之变与华夏新生》&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;需卦的卦辞：水天需。上六，入于穴，有不速之客三人来，敬之终吉。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;《封神演义》崇侯虎的原型，商朝西征的先锋队。侯，表示军事贵族。商人向西扩张，在老牛坡建立了崇国，由商人贵族担任首领，首领称为崇侯。商的分封与周的分封一大不同是，商只会分封同族，而周则会分封异族。这可能是周在翦商的时候，有很多其他部族的人参与。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;“周公吐哺”的典故，周公作为周文王的儿子、周武王的弟弟，可能也参与了，事实很可能是因被迫吃长兄的肉酱，周公留下了严重的心理阴影。而且，不只是周公旦，武王周发此后也一直受到噩梦的困扰，“自夜不寐”。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2F;sup&gt;
&lt;p&gt;顾颉刚《周易卦爻辞中的故事》中最早提出了将周易的爻辞和历史事件结合起来的观点。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>海伯利安</title>
        <published>2025-11-27T22:00:53+08:00</published>
        <updated>2025-11-27T22:00:53+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/hyperion/"/>
        <id>https://liyan-ah.github.io/hyperion/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/hyperion/">&lt;h2 id=&quot;hai-bo-li-an-jie-shao&quot;&gt;《海伯利安》介绍&lt;&#x2F;h2&gt;
&lt;p&gt;《海伯利安》是美国作家丹·西蒙斯科幻小说《海伯利安的诗篇》中的第一部作品。这篇小说的想象力丰富，设定奇异。不同于与之齐名的《银河帝国》系列小说在一个世界观下以一系列中短篇小说组织的特点，《海伯利安的诗篇》中的每一部都沿着一个主线展开。《海伯利安》作为第一部，将整个系列的世界观和设定都放置在了六个人的叙述中。由于没有单独的段落来系统性的说明整个世界的架构（《银河帝国》的第一步的第一章则系统性的介绍了银河帝国的组成、危机以及谢顿要做的事情），《海伯利安》的六篇故事看着是稍显晦涩的，但是每一部分又都非常的精彩。将《海伯利安》阅读完成后，会对惊叹于作者的设定，同时对时间、诗人以及机器人（人工智能）都有一些思考。&lt;&#x2F;p&gt;
&lt;p&gt;《海伯利安》，未来的世界（宇宙）由人类和技术内核（人工智能）共同治理。在海伯利安这颗星球，突然出现了一个逆熵场。在逆熵场周围出现了一个被称为“伯劳”的机器人。围绕着“伯劳”崇拜，诞生了本地的宗教。某一天，“霸主”选择了七位朝圣者到海伯利安朝圣，希望为了弄清逆熵场以及“伯劳”的目的。七位朝圣者从靠近海伯利安星球开始，到抵达逆熵场的前几个小时，轮流叙述了自己的故事。&lt;&#x2F;p&gt;
&lt;p&gt;书中的若干设定：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;远距传输器。未来世界的一种科技，由人工智能推动研发、管理。可以让使用者从一个地方瞬间移动到另外一处，实现瞬间的星际旅行。人类借助远距传输器将已知世界的主要部分连接起来。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;时间债。与远距传输器相关的一个概念。在远距传输器无法覆盖的地方，人类仍然需要使用传统的运载器具。运载器通过“霍金驱动器”以接近光速的速度运行，依据相对论效应，运载器上的时间可能只过了几天、几周，但是外界的时间可能已经过了几年、几十年甚至更长的时间。这样，乘坐运载器旅行的人和外部在时间上就会脱节。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;逆熵场。世界是熵增的，正常情况下时间会一直向前、宇宙会逐步无序。但是逆熵场的存在逆转了时间的流向——明天是昨天的重复。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;jie-xuan&quot;&gt;节选&lt;&#x2F;h2&gt;
&lt;p&gt;本部分介绍《海伯利安》的第四个叙述人：学者的故事。我们都希望时间能够走的慢一些，或者回到年轻的时候。但是当时间真的开始回退时，可能并非如此美好。&lt;&#x2F;p&gt;
&lt;p&gt;索尔·温特伯是一位研究犹太文化的学者，与妻子萨莱和女儿瑞秋过着幸福的生活。瑞秋聪明伶俐，在索尔任教的大学从事考古研究。悲剧的种子在一次家庭度假时埋下。他们前往海伯利安星球，在著名的“光阴冢”附近野餐。瑞秋独自一人在时光冢周围探索，不小心进入了“时间潮汐”的范围。回到家园后，瑞秋开始出现异常。她先是忘记了一些小事，然后情况急剧恶化。经过医学检查，他们得到了一个绝望的诊断：逆时症。她的记忆不是变得模糊，而是精确地、一天一天地倒带。今天，她会忘记昨天发生的事情；明天，她会忘记今天和昨天。她的记忆库像一个被从末尾开始擦除的录像带。不仅是记忆，她的生理年龄和心智也在同步倒退。一个27岁的成熟女性，逐渐变回20岁的大学生、16岁的高中生、10岁的孩童……最终将退行至婴儿时期。任何试图向她解释或灌输新知识的努力都是徒劳的。今天教会她的东西，明天她会忘得一干二净。她唯一能保留的，是她在发病前就已经掌握的知识和记忆。每一天，温特伯都要重新向女儿解释发生了什么；每一天，他都要忍受着看着女儿却无法被她以“父亲”的身份完整认知的痛苦。当瑞秋的年龄倒退到不认识他的时候，他不得不雇佣保姆来照顾她，自己则躲在幕后，以“慈祥的叔叔”身份出现。直到有一天，温特伯经历了诡异的梦境，在梦中，一个“燃烧的荆棘”或“声音”与他对话。这个神秘存在（后来暗示可能与技术内核或伯劳本身有关）给了他一个可怕的选择：他必须带着倒退成婴儿的瑞秋前往海伯利安，进入光阴冢，并心甘情愿地让伯劳用一根长长的金属刺刺穿瑞秋的身体。作为交换，瑞秋将在正常的时间流中重生，获得一个没有逆时症的全新人生。&lt;&#x2F;p&gt;
&lt;p&gt;学者的故事是对“时间”这一概念的精彩演绎。不同于遵循基本物理假设的硬科幻，丹·西蒙斯的《海伯利安》完全是以科幻的主题在写抒情故事。也正是这样，会给人更大的触动。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;这些人是谁呵，都去赶祭祀？
这做牺牲的小牛，对天名叫，
你要迁它到哪儿，神秘的祭祀？
花环缀满着它光滑的身腰。
是从哪个傍河傍海的小镇，
或哪个静静地堡寨山村，
来了这些人，在这敬神的清早？
呵，小镇，你的街道永远恬静；
再也不可能回来一个灵魂
告诉人你何以是这么寂寥。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>矛盾论</title>
        <published>2025-10-30T23:33:21+08:00</published>
        <updated>2025-10-30T23:33:21+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/mao-dun-lun/"/>
        <id>https://liyan-ah.github.io/mao-dun-lun/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/mao-dun-lun/">&lt;h2 id=&quot;mao-dun-lun-jie-shao&quot;&gt;《矛盾论》介绍&lt;&#x2F;h2&gt;
&lt;p&gt;《矛盾论》在“两种宇宙观”、“矛盾的普遍性”、“矛盾的特殊性”、“主要的矛盾和主要的矛盾方面”、“矛盾诸方面的同一性和斗争性”、“对抗在矛盾中的地位”六个部分说明了对矛盾的认识，矛盾在发展中的作用以及如何借助矛盾来推动事物的发展。&lt;&#x2F;p&gt;
&lt;p&gt;两种宇宙观中，本书提到“形而上学”和“辩证法”两种认识事物的方式。“形而上学”认为事物的发展只是增加和减少，是重复；而在“辩证法中”，事物的发展是以内部矛盾来推动的。这就阐述了矛盾的重要性。&lt;&#x2F;p&gt;
&lt;p&gt;矛盾的普遍性与特殊性。辩证法说明了事物的发展是以内部矛盾来推动的，而万物又是在运动和发展的。矛盾存在于普遍的运动之中。矛盾具有普遍性。&lt;&#x2F;p&gt;
&lt;p&gt;矛盾的特殊性。矛盾存在于运动中，但是每个运动其实是不同的：如，数学中的正数和负数，机械学中的作用和反作用，物理学中的阴电和阳电。由此可知，矛盾具有其特殊性。&lt;&#x2F;p&gt;
&lt;p&gt;主要的矛盾和主要的矛盾方面。这里，将视角从原子性的矛盾中，上升到了有机的复杂事物的发展中。在复杂的事物的发展过程中，有许多的矛盾存在，其中必有一种是主要的矛盾，由于它的存在和发展规定或影响著其它矛盾的存在和发展。矛盾著的两方面中，必有一方面是主要的，他方面是次要的。其主要的方面，即所谓矛盾起主导作用的方面。事物的性质，主要地是由取得支配地位的矛盾的主要方面所规定的。然而这种情形不是固定的，矛盾的主要和非主要的方面互相转化著，事物的性质也就随著起变化。在矛盾发展的一定过程或一定阶段上，主要方面属于甲方，非主要方面则属于乙方；到了另一发展阶段或另一发展过程时，就互易其位置，这是依靠事物发展中矛盾双方斗争的力量的增减程度来决定的。&lt;&#x2F;p&gt;
&lt;p&gt;矛盾诸方面的同一性和斗争性。第一、事物发展过程中的每一种矛盾的两个方面，各以和它对立著的方面为自己存在的前提，双方共处于一个统一体中；第二、矛盾著的双方，依据一定的条件，各向著其相反的方面转化。这就是所谓同一性。事物总不断地是由第一种状态转化为第二种状态，而矛盾的斗争则存在于两种状态中，并经过第二种状态而达到矛盾的解决。所以说，对立的统一是有条件的、暂时的、相对的，而对立的互相排除的斗争则是绝对的。&lt;&#x2F;p&gt;
&lt;p&gt;对抗在矛盾中的地位。对抗是矛盾斗争的一种形式，而不是矛盾斗争的一切形式。这里，将其理解为矛盾斗争性的一种表现形式。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dui-mao-dun-ji-qi-yun-dong-de-si-kao&quot;&gt;对矛盾及其运动的思考&lt;&#x2F;h2&gt;
&lt;p&gt;这里对“两种宇宙观”、“矛盾的普遍性”、“矛盾的特殊性”进行思考、讨论。&lt;&#x2F;p&gt;
&lt;p&gt;两种宇宙观。文中提到了“形而上学”和“辩证法”两种的见解。这两种的见解可以借助&lt;a href=&quot;&#x2F;li-xiang-guo&#x2F;&quot;&gt;《理想国》&lt;&#x2F;a&gt;中的“床论”来进行讨论。苏格拉底认为，世界上存在三种床：上帝的床，工匠的床和画家的床。这无疑是一种认识事物的方式。但是就这一点来说，上帝是万能的，上帝的床也是完美的、不变的。工匠的床仅是对上帝的床的模仿或者尝试模仿，只是对“床”这一概念的重复。这是一种“形而上学”的认识。如果以“辩证法”的角度来看了，“床”是发展着的。其发展的内因是人对“床”休息的需求，这就需要床的舒适性、柔软性等。而外因，随着材料的发展，越来越多的材料：弹簧、海绵、乳胶等加入到床的构造中来。内因的推动，使得外因参与到床的发展中。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;在人类的认识史中，从来就有关于宇宙发展法则的两种见解，一种是形而上学的见解，一种是辨证法的见解，形成了互相对立的两种宇宙观。列宁说：“对于发
展(进化)所持的两种基本的(或两种可能的？或两种在历史上常见的？)观点是：(一)认为发展是减少和增加，是重复；(二)认为发展是对立的统一(统一物分
成为两个互相排斥的对立，而两个对立又互相关联著)。列宁说的就是这两种不同的宇宙观。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;矛盾的普遍性和特殊性。矛盾存在于运动中。运动可以认为是广义上的变化。由此来理解，变化涉及到从A到B。A和B就是矛盾的两个方面。而运动是普遍的，万物均处于运动，或者变化中。这就意味着，矛盾是普遍存在的。但是，需要注意到，不同的运动往往有着不同的表现，所以矛盾又有着和其运动相符的特殊性。我们再对此进一步的讨论。运动的两个方面构成了运动本身，如果一方面不存在，运动也是不存在的。这和朴素的认识是相同的：有无相生，难易相成，长短相形，高下相倾，音声相和，前后相随。这里，没有长，短也就没有了意义；没有高，下也就无从谈起。矛盾的两个方面是彼此相同的（可以认为是彼此的否定？）。这就构成了矛盾的同一性：同一在运动下的两个表现。&lt;&#x2F;p&gt;
&lt;p&gt;以上是对矛盾和运动的思考。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>征服市场的人</title>
        <published>2025-09-26T17:40:36+08:00</published>
        <updated>2025-09-26T17:40:36+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/zheng-fu-shi-chang-de-ren/"/>
        <id>https://liyan-ah.github.io/zheng-fu-shi-chang-de-ren/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/zheng-fu-shi-chang-de-ren/">&lt;h1 id=&quot;ren-wu-xiao-chuan-ji-ju-chuan-qi-de-yi-sheng&quot;&gt;人物小传：极具传奇的一生&lt;&#x2F;h1&gt;
&lt;p&gt;詹姆斯·西蒙斯（1938年4月25日—2024年5月10日），20岁大学毕业，24岁博士毕业，30岁受邀担任纽约州立大学石溪分校数学系系主任，之间也从事过密码破译工作。在38岁时更是因为和陈省身教授合作的研究成果和其他杰出贡献，获得了代表几何领域最高成就的奥斯瓦尔德·维布伦几何奖。40岁时辞去系主任职务开始投资生涯。&lt;&#x2F;p&gt;
&lt;p&gt;西蒙斯创办的文艺复兴科技公司旗下大奖章基金的真实盈利超越了大部分人的想象——在1988—2018年这30年间获得了费前收益率年化66%左右的惊人收益。这个收益率远远超过了那些相对于西蒙斯更为人所知的投资大师，如做宏观投资的索罗斯和做价值投资的巴菲特：索罗斯在29年间取得的年化投资收益率约30%；而在1965年到2014年50年间,巴菲特的年化收益率是21.97%。如此高的收益率很难不让人心动。&lt;&#x2F;p&gt;
&lt;p&gt;与此同时，西蒙斯又格外的低调，实际上，人们对大奖章基金的投资策略知之甚少。本书的作者，格里高利·祖克曼，通过持续的采访和收集第一手的资料，汇总了西蒙斯和文艺复兴公司的发展。展示了生动而有趣的投资故事。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;tou-zi-an-li&quot;&gt;投资案例&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;zhi-jue-shi-fou-ke-kao&quot;&gt;直觉是否可靠？&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;经历了1984年交易溃败所带来的亏损后，西蒙斯决定放弃列尼·鲍姆依靠智力和直觉的投资方法，开始支持詹姆斯·埃克斯开发计算机交易系统。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;西蒙斯是一位卓有成果的数学家，同时他也雇佣了很多优秀的数学家来参与投资。在他们的投资活动中，出现了很多受情绪影响的交易活动。这些交易有的受益于直觉而减少收益，有的却因直觉而亏损严重。第3章中，作者介绍了西蒙斯的投资活动开始时，在数学家列尼·鲍姆的加盟下，通过模型和直觉的判断，在外汇市场上大赚了一笔。但是紧接着，鲍姆就栽了大跟头，连续在黄金和咖啡期货上都产生了亏损。这些亏损的交易活动中，风险厌恶的本性得到了体现：在咖啡期货中，鲍姆并不愿意及时的止损。这一心理在《海龟交易法则》中有较为详细的描述，同时有通过制定、遵循规则来规避这一心理的介绍。&lt;&#x2F;p&gt;
&lt;p&gt;再理性的人在交易时也无法控制情绪；再聪明的人被情绪裹挟时也会头脑发昏。鲍姆退出后，西蒙斯重启了用计算机做交易的探索。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;鲍姆对投资的嗜好日盛，最终和西蒙斯之间产生了裂痕。紧张关系发端于1979年的秋天，当时他们在金价250美元的时候各自买了一些黄金期货合约。那年年底，紧张的国际形势使金价和银价不断上涨。那时候去拜访文艺复兴科技公司的人，经常能看到原本安静而内敛的鲍姆兴高采烈地谈论金价的走高，而西蒙斯则坐在一旁微笑。时至1980年1月，金银价格依然在快速上涨。经过疯狂的两周时间，金价创下了每克约25美元的历史新高，此时西蒙斯选择了清仓，锁定了每克数十美元的收益。像往常一样，鲍姆依然不愿意卖出。
一天，西蒙斯听一位朋友谈起，他的珠宝商妻子最近翻了他的衣橱，想把金袖扣和领带夹都拿出去卖了。“你们是要破产了吗？”西蒙斯问道。“没有，她只是想去排队把它们卖了。”朋友回答道。西蒙斯又问：“现在卖黄金需要排队？”那位朋友解释道，现在乡下的居民正在排队卖珠宝，
想趁金价在高位时赚上一笔。
西蒙斯震惊了，他认为如果黄金的供给迅速增加，金价会崩盘的。回到办公室，西蒙斯要求鲍姆立即抛出手中的黄金。以下是他们的对话：
“鲍姆，马上卖出黄金。”
“不行，金价还在走高。”
“快点卖出，鲍姆！”
但鲍姆就是固执己见，西蒙斯很生气。鲍姆已经有超过1000万美元的浮盈了，金价也已经超过每克28美元，但他确信还能赚得更多。“西蒙斯对我指手画脚，”鲍姆后来跟家人说，“但是当时没有任何理由或苗头让我卖出，所以我什么都没做。”
最后，1980年1月18日那天，西蒙斯不能忍了，他强行让鲍姆听电话。他对鲍姆说：“告诉交易员你要卖出，鲍姆！”“好吧，好吧！”鲍姆嘟囔道。结果，几个月之内金价涨到了每克30美元，鲍姆一直在抱怨西蒙斯让他错失了很多赚钱机会。然后，泡沫破裂，金价几个月之内就跌到了每克18美元以下。
其后不久，鲍姆又发掘了一个在E. F. Hutton经纪公司(21)工作的哥伦比亚人，他声称自己非常擅长投资咖啡期货。这个哥伦比亚人很看好咖啡期货，于是西蒙斯和鲍姆建立了全市场最大的多头仓位。刚刚建完，咖啡价格就跌了10%，他们的浮亏达到了数百万美元。于是西蒙斯迅速清仓了，但鲍姆依然不愿意卖出。最终，鲍姆亏损严重，甚至都没有勇气自己去清仓卖出，只能求助于西蒙斯。鲍姆后来总是说这是他“职业生涯最愚蠢的一幕”。鲍姆的盲目乐观开始让西蒙斯感到不爽了。“他只有能力做到‘低买’，没办法做到‘高卖’。”西蒙斯后来说。1983年，鲍姆一家搬到了百慕大群岛，他们很享受那边友好的税率和舒适的天气。岛上美丽的景色增强了鲍姆乐观的天性和看涨的倾向。美国的通货膨胀看起来已经得到了控制，时任美联储主席保罗·沃尔克（Paul Volcker）也表示未来利率有下降的空间，于是鲍姆买了几百万美元的美国国债，这看起来是一个恰逢其时的头寸。但是1984年晚春，恐慌性的卖盘(22)主导了债券市场，这一方面是因为里根总统任期内债券发行量激增，另一方面是因为美国经济迅速增长。随着亏损增加，鲍姆依然保持着惯有的平静，但西蒙斯很担心这么下去公司会垮掉。“醒一醒，鲍姆，别这么顽固！”西蒙斯说。鲍姆的亏损仍在继续，而市场对于日元继续升值的预期也让鲍姆的美债头寸雪上加霜。“不能再这么继续下去了。”终于有一天，西蒙斯盯着电脑屏幕说。当鲍姆的账户亏损达到40%的时候，触发了他和西蒙斯之间的协议中的自动条款，西蒙斯必须卖出鲍姆的全部持仓，并与他解约。两位著名数学家之间持续数十年的合作正式告吹了。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;yi-ding-yao-ying-li-cai-neng-jiao-yi&quot;&gt;一定要盈利才能交易？&lt;&#x2F;h2&gt;
&lt;p&gt;西蒙斯创建了大奖章基金，完全投入到交易中。在埃尔文·伯勒坎普的主导下，大奖章基金开始逐步的脱离主观与定性的分析，完全依据数据来推动交易。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;伯勒坎普和同事们希望大奖章基金可以模仿赌场的做法。赌场里每天有那么多场赌局，只要在超过一半的赌局上盈利，赌场整体就赚钱了。大奖章基金也是一样，只要保证每天进行的高频交易大多数都能盈利，大奖章基金就能赚很多钱。只需要拥有一点点优势，高频的重复博弈就会确保大数定律站在他们这边，这跟赌场的盈利模式非常相似。“如果你交易得足够多，那么只要保证其中51%是盈利的就够了。”伯勒坎普告诉一位同事，“我们就不必要为每次交易劳神费力。”
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;tou-zi-ce-lue&quot;&gt;投资策略&lt;&#x2F;h1&gt;
&lt;p&gt;西蒙斯清空了所有大奖章基金的所有外部持有者。现在，大奖章基金仅由文艺复兴公司内部工作人员持有。它的管理规模约为100亿美元，并且在扣除管理费用之前的每年收益率约为65%，实现了几乎创纪录的收益。&lt;&#x2F;p&gt;
&lt;p&gt;文艺复兴科技公司在数千个同步交易中有着微弱的优势，积累起来就是一个足够可观且稳定的、可以创造巨大财富的优势。而获得这些稳定收益的关键是，影响股票和其他投资品种走势的因素，要比任何一个经验最丰富的投资者可以理解的都复杂得多。显然，文艺复兴科技公司践行了高频交易，积少成多的投资理念。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;大奖章基金仍然保持着在债券、大宗商品和外汇上的交易，通过判断趋势和回归预测信号赚钱，包括特别有效的一种被命名为“似曾相识”（Déjà Vu）的信号。但是，相比之前更甚的是，现在的投资策略是基于混合的复杂信号而进行的股票交易，而不是简单的配对交易，例如，做多可乐和做空百事可乐。每笔交易的收益从来不是很可观的，而且基金的判断仅在略多于50%的时间里是正确的，但这已绰绰有余。“我们只在50.75%的情况下是对的……但是在这50.75%的情况下，我们的操作是百分百正确的，”默瑟告诉朋友，“这样就足以赚到数十亿美元。”
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>理想国</title>
        <published>2025-08-28T20:12:14+08:00</published>
        <updated>2025-08-28T20:12:14+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/li-xiang-guo/"/>
        <id>https://liyan-ah.github.io/li-xiang-guo/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/li-xiang-guo/">&lt;h2 id=&quot;li-xiang-guo-jie-shao&quot;&gt;《理想国》介绍&lt;&#x2F;h2&gt;
&lt;p&gt;理想国的介绍截取，数据来源：维基百科&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;《理想国》（古希腊语：Πολιτεία；拉丁语：Res Publica[1]）又译作《国家篇》、《共和国》、《王制》，是古希腊哲学家柏拉图在大约公元前390年所写成的作品，主要谈及了正义、秩序和正义的人及城邦所扮演的角色。[2]它以苏格拉底为主角，采用对话体的形式，共分10卷，其篇幅之长仅次于《法律篇》。《理想国》是柏拉图最著名的著作，也是人类历史上最有影响力的哲学和政治理论著作之一。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;《理想国》的成书时间，依照维基百科介绍，为公元前390年。此时中国处于战国时期，各种思想也在不断演进：向前看，《道德经》、《论语》等已经成书。向后看，稷下学宫也即将成立，诸子百家的思想进一步的碰撞。而在古希腊，柏拉图借助苏格拉底之口，在《理想国》一书中广泛的讨论了优生学问题、节育问题、家庭问题、婚姻自由问题、独身问题、专政问题、独裁问题、共产问题、民主问题、宗教问题、道德问题、文艺问题、教育问题（包括托儿所、幼儿园、小学、中学、大学研究院以及工、农、航海、医学等职业教育）加上男女平权、男女参政、男女参军等等问题。从《理想国》一书中，可以对古希腊的思想略窥门径。&lt;&#x2F;p&gt;
&lt;p&gt;理想国版本较多，这里讨论依据的版本是：理想国／〔古希腊〕柏拉图著；郭斌和，张竹明译．—北京：商务印书馆，2009。图书资源附在文末。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;li-xiang-guo-zhai-lu&quot;&gt;《理想国》摘录&lt;&#x2F;h2&gt;
&lt;p&gt;本文截取了三个片段，希望对“苏格拉底式提问”、“理念与实体”、“洞穴之论”做介绍。截取的片段中，【】引用的内容均是笔者自行添加的。由于文字表述的限制，去掉了注释的内容。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;su-ge-la-di-shi-ti-wen-dui-lun-shu-de-jian-ce&quot;&gt;苏格拉底式提问——对论述的检测&lt;&#x2F;h3&gt;
&lt;p&gt;通过苏格拉底式的提问，分别检测了：&lt;&#x2F;p&gt;
&lt;p&gt;1，“认为帮助朋友，伤害敌人是正义”。看上去好的人可能实际上是坏人，或做不正义的事。他们伤害那些“真正”的好人。这就导致主观认为的“正义”，实际上是“不正义”。&lt;&#x2F;p&gt;
&lt;p&gt;2，“好人才是朋友，坏人才是敌人”，认为帮助朋友，伤害敌人是正义。苏格拉底通过“好人能用他的美德使人变坏吗？”的论述，检测了“伤害敌人是正义的”。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;【苏格拉底与格劳孔被请，&amp;lt;那么好！要么留在这儿，要么就干上一仗。&amp;gt;，到玻勒马霍斯家里。他们就什么是”正义“展开讨论。此前，玻勒马霍斯认为&amp;lt;欠债还债就是正义&amp;gt;。而苏格拉底已经进行了一轮的提问。此段截取的是第一轮提问后的对话。】
【第一部分，主观的好人。是否帮助好人就是正义。】
玻：老天爷啊！不是。我弄得晕头转向了，简直不晓得我刚才说的是什么了。不管怎么说罢，我终归认为帮助朋友，伤害敌人是正义的。
苏：你所谓的朋友是指那些看上去好的人呢，还是指那些实际上真正好的人呢？你所谓的敌人是指那些看上去坏的人呢，还是指那些看上去不坏，其实是真的坏人呢？
玻：那还用说吗？一个人总是爱他认为好的人，而恨那些他认为坏的人。
苏：那么，一般人不会弄错，把坏人当成好人，又把好人当成坏人吗？
玻：是会有这种事的。
苏：那岂不要把好人当成敌人，拿坏人当成朋友了吗？
玻：无疑会的。
苏：这么一来，帮助坏人，为害好人，岂不是正义了？
玻：好像是的了。
苏：可是好人是正义的，是不干不正义事的呀。
玻：是的。
苏：依你这么说，伤害不做不正义事的人倒是正义的了？
玻：不！不！苏格拉底，这个说法不可能对头。
苏：那么伤害不正义的人，帮助正义的人，能不能算正义。
玻：这个说法似乎比刚才的说法来得好。
苏：玻勒马霍斯，对于那些不识好歹的人来说，伤害他们的朋友，帮助他们的敌人反而是正义的——因为他们的若干朋友是坏人，若干敌人是好人。
所以，我们得到的结论就刚好跟西蒙尼得的意思【即：帮助朋友，伤害敌人是正义的】相反了。
玻：真的！结果就变成这样了。这是让我们来重新讨论吧。这恐怕是因为我们没把“朋友”和“敌人”的定义下好。
【第二部分，绝对的好人。是否伤害敌人就是正义。】
苏：玻勒马霍斯，定义错在哪儿？
玻：错在把似乎可靠的人当成了朋友。
苏：那现在我们该怎么来重新考虑呢？
玻：我们应该说朋友不是仅看起来可靠的人，而是真正可靠的人。看起来好，并不真正好的人只能当作外表上的朋友，不算作真朋友。关于敌人，理亦如此。
苏：照这个道理说来，好人才是朋友，坏人才是敌人。
玻：是的。
苏：我们原先说的以善报友，以恶报敌是正义。讲到这里我们是不是还得加上一条，即，假使朋友真是好人，当待之以善，假如敌人真是坏人，当待之以恶，这
才算是正义？
玻：当然。我觉得这样才成为一个很好的定义。
苏：别忙，一个正义的人能伤害别人吗？
玻：当然可以，他应该伤害那坏的敌人。
苏：拿马来说吧！受过伤的马变得好了呢？还是变坏了？
玻：变坏了。
苏：这是马之所以为马变坏？还是狗之所以为狗变坏？
玻：马之为马变坏了。
苏：同样道理，狗受了伤，是狗之所以为狗变坏，而不是马之所以为马变坏，是不是？
玻：那还用说吗！
苏：请问，我们是不是可以这样说呢：人受了伤害，就人之所以为人变坏了，人的德性变坏了？
玻：当然可以这么说。
苏：正义是不是一种人的德性呢？
玻：这是无可否认的。
苏：我的朋友啊！人受了伤害便变得更不正义，这也是不能否认的了。
玻：似乎是这样的。
苏：现在再说，音乐家能用他的音乐技术使人不懂音乐吗？
玻：不可能。
苏：那么骑手能用他的骑术使人变成更不会骑马的人吗？
玻：不可能。
苏：那么正义的人能用他的正义使人变得不正义吗？换句话说，好人能用他的美德使人变坏吗？
玻：不可能。
苏：我想发冷不是热的功能，而是和热相反的事物的功能。
玻：是的。
苏：发潮不是干燥的功能，而是和干燥相反的事物的功能。
玻：当然。
苏：伤害不是好人的功能，而是和好人相反的人的功能。
玻：好像是这样。
苏：正义的人不是好人吗？
玻：当然是好人。
苏：玻勒马霍斯啊！伤害朋友或任何人不是正义者的功能，而是和正义者相反的人的功能，是不正义者的功能。
玻：苏格拉底，你的理由看来很充分。
苏：如果有人说，正义就是还债，而所谓“还债”就是伤害他的敌人，帮助他的朋友。那么，我认为说这些话的人不可能算是聪明人。因为我们已经摆明，伤害任何人无论如何总是不正义的。
玻：我同意。
苏：如果有人认为这种说法是西蒙尼得，或毕阿斯，或皮塔科斯，或其他圣贤定下来的主张，那咱们俩就要合起来击鼓而攻之了。
玻：我准备参加战斗。
苏：你知道“正义就是助友害敌”，这是谁的主张？你知道我猜的是谁吗？
玻：谁啊？
苏：我想是佩里安得罗，或者佩狄卡，或者泽尔泽斯，或者是忒拜人伊斯梅尼阿，或其他有钱且自以为有势者的主张。
玻：你说得对极了。
苏：很好。既然这个正义的定义不能成立，谁能另外给下一个定义呢？
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;chuang-lun-li-nian-yu-shi-ti-de-biao-shu&quot;&gt;“床论”——理念与实体的表述&lt;&#x2F;h3&gt;
&lt;p&gt;在第十卷中，柏拉图借苏格拉底之口来批判模仿者，【按照理想建立的这个国家】“它绝对拒绝任何模仿”，同时表述了对“诗歌”的批判。其中，通过“床论”，实际上表述了哲学中很重要的一个概念：本体论。对本体的讨论可谓贯穿西方哲学的整个发展中。后来的亚里士多德有“四因说”，经院哲学中的“唯实”、“唯名”，以及黑格尔的“绝对精神”其实也是对此概念的发展。&lt;&#x2F;p&gt;
&lt;p&gt;这种表述是具有鲜明的古希腊的哲学色彩，与中国的哲学有不同之处——中国哲学对此讨论较少。笔者理解的中国哲学更多的是类似“组成”而非“概念”的讨论。比如，五行说、阴阳说。《周易》中的“形而上者谓之道，形而下者谓之器”与《道德经》中的“名可名，非常名”可能有类似的观点，但是在后来没有看到更近一步的延伸。印度哲学中对此的讨论较多，印度教的“梵”有类似绝对概念的感觉。&lt;&#x2F;p&gt;
&lt;p&gt;值得注意的是，我们延伸一下：柏拉图认为，神创造了床的概念；而人只是对神的模仿，或者概念模仿物的模仿，是相对卑劣的。这一点与中国哲学对“人”的推崇有明显的区别。《道德经》第二十五章，“故道大，天大，地大，人亦大。域中有四大，而人居其一焉。人法地，地法天，天法道，道法自然。”肯定了“人”的地位，认为“人”与“天”、“地”是平等的。这一点难能可贵&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;苏：那么下面我们设有三种床，一种是自然的床，我认为我们大概得说它是神造的。或者，是什么别的造的吗？
格：我认为不是什么别的造的。
苏：其次一种是木匠造的床。
格：是的。
苏：再一种是画家画的床，是吗？
格：就算是吧。
苏：因此，画家、造床匠、神，是这三者造这三种床。
格：是的，这三种人。
苏：神或是自己不愿或是有某种力量迫使他不能制造超过一个的自然床，因而就只造了一个本质的床，真正的床。神从未造过两个或两个以上这样的床，它以后也永远不会再有新的了。
格：为什么？
苏：因为，假定神只制造两张床，就会又有第三张出现，那两个都以它的形式为自己的形式，结果就会这第三个是真正的本质的床，那两个不是了。
格：对。
苏：因此，我认为神由于知道这一点，并且希望自己成为真实的床的真正制造者而不只是一个制造某一特定床的木匠，所以他就只造了唯一的一张自然的床。
格：看来是的。
苏：那么我们把神叫做床之自然的创造者，可以吗？还是叫做什么别的好呢？
格：这个名称是肯定正确的，既然自然的床以及所有其他自然的东西都是神的创造。
苏：木匠怎么样？我们可以把他叫做床的制造者吗？
格：可以。
苏：我们也可以称画家为这类东西的创造者或制造者吗？
格：无论如何不行。
苏：那么你说他是床的什么呢？
格：我觉得，如果我们把画家叫做那两种人所造的东西的模仿者，应该是最合适的。
苏：很好。因此，你把和自然隔着两层的作品的制作者称作模仿者？
格：正是。
苏：因此，悲剧诗人既然是模仿者，他就像所有其他的模仿者一样，自然地和王者或真实隔着两层。
格：看来是这样。
苏：那么，关于模仿者我们已经意见一致了。但是请你告诉我，画家努力模仿的是哪一种事物？你认为是自然中的每一事物本身还是工匠的制作品？
格：工匠的作品。
苏：因此这是事物的真实还是事物的影像？——这是需要进一步明确的。
格：我不明白你的意思。
苏：我的意思如下：例如一张床，你从不同的角度看它，从侧面或从前面或从别的角度看它，它都异于本身吗？或者，它只是样子显得不同，事实上完全没有什么不同，别的事物也莫不如此。是吗？
格：只是样子显得不同，事实上没有任何区别。
苏：那么请研究下面这个问题。画家在作关于每一事物的画时，是在模仿事物实在的本身还是在模仿看上去的样子呢？这是对影像的模仿还是对真实的模仿呢？
格：是对影像的模仿。
苏：因此，模仿术和真实距离是很远的。而这似乎也正是它之所以在只把握了事物的一小部分（而且还是表象的一小部分）时就能制造任何事物的原因。例如，我们说一个画家将给我们画一个鞋匠或木匠或别的什么工匠。虽然他自己对这些技术都一窍不通，但是，如果他是个优秀的画家的话，只要把他所画的例如木匠的肖像陈列得离观众有一定的距离，他还是能骗过小孩和一些笨人，使他们信以为真的。
格：这话当然对的。
苏：我的朋友，我认为，在所有这类情况下，我们都应该牢记下述这一点。当有人告诉我们说，他遇到过一个人，精通一切技艺，懂得一切只有本行专家才专门懂得的其他事物，没有什么事物他不是懂得比任何别人都清楚的。听到这些话我们必须告诉他说：“你是一个头脑简单的人，看来遇到了魔术师或巧于模仿的人，被他骗过了。你之所以以为他是万能的，乃是因为你不能区别知识、无知和模仿。”
格：再对不过了。
......
苏：是有这个传说的。但是，格劳孔啊，如果荷马真能教育人提高人的品德，他确有真知识而不是只有模仿术的话，我想就会有许多青年跟他学习，敬他爱他了。你
说是吗？既然阿布德拉的普罗塔戈拉、开奥斯的普洛蒂卡斯和许多别的智者能以私人教学使自己的同时代人深信，人们如果不受智者的教育，就不能管好家务治好国
家；他们靠这种智慧赢得了深深的热爱，以致他们的学生只差一点没把他们顶在自己的肩上走路了。同样道理，如果荷马真能帮助自己的同时代人得到美德，人们还
能让他（或赫西俄德）流离颠沛，卖唱为生吗？人们会依依难舍，把他看得胜过黄金，强留他住在自己家里的。如果挽留不住，那么，无论他到哪里，人们也会随时到那里，直到充分地得到了他的教育为止的。你说我的这些想法对吗？
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;dong-xue-yu-yan-wei-jing-jian-yan-de-ren-sheng-shi-bu-zhi-de-huo-de&quot;&gt;“洞穴寓言”——未经检验的人生是不值得活的&lt;&#x2F;h3&gt;
&lt;p&gt;“洞穴寓言”是《理想国》中极为精彩的论述。原文在第七卷，论述教育（知识是每个人灵魂里都有的一种能力，而每个人用以学习的器官就像眼睛。）与选择什么样的人来治理国家（没受过教育不知道真理的人和被允许终身完全从事知识研究的人，都是不能胜任治理国家的）。&lt;&#x2F;p&gt;
&lt;p&gt;“洞穴寓言”可以认为是苏格拉底一生行为的诠释：苏格拉底把自己看作神赐给雅典人的一个礼物、一个使者，任务就是整天到处找人谈话，讨论问题，探求对人最有用的真理和智慧。因此他的一生大部分是在室外度过的，喜欢在市场、运动场、街头等公众场合与各方面的人谈论各种各样的问题，例如，什么是虔诚？什么是民主？什么是美德？什么是勇气？什么是真理？以及你的工作是什么？你有什么知识和技能？你是不是政治家？如果是，关于统治你学会了什么？你是不是教师？在教育无知的人之前你怎样征服自己的无知？等等（来源：百度百科）。&lt;&#x2F;p&gt;
&lt;p&gt;“洞穴寓言”也是苏格拉底思想的综合体现：既体现了苏格拉底希望激发人们检验自己生活的主张，也有“理念”、“实体”观点的投影。洞穴中人所看到的投影显然是“床论”中画家的床。苏格拉底显然期望通过检验，最终能够让大家都认识到神造的“床”。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;苏：接下来让我们把受过教育的人与没受过教育的人的本质比作下述情形。让我们想象一个洞穴式的地下室，它有一长长通道通向外面，可让和洞穴一样宽的一路亮光照进来。有一些人从小就住在这洞穴里，头颈和腿脚都绑着，不能走动也不能转头，只能向前看着洞穴后壁。让我们再想象在他们背后远处高些的地方有东西燃烧着发出火光。在火光和这些被囚禁者之间，在洞外上面有一条路。沿着路边已筑有一带矮墙。矮墙的作用像傀儡戏演员在自己和观众之间设的一道屏障，他们把木偶举到屏障上头去表演。
格：我看见了。
苏：接下来让我们想象有一些人拿着各种器物举过墙头，从墙后面走过，有的还举着用木料、石料或其他材料制作的假人和假兽。而这些过路人，你可以料到有的在说话，有的不在说话。
格：你说的是一个奇特的比喻和一些奇特的囚徒。
苏：不，他们是一些和我们一样的人。你且说说看，你认为这些囚徒除了火光投射到他们对面洞壁上的阴影而外，他们还能看到自己的或同伴们的什么呢？
格：如果他们一辈子头颈被限制了不能转动，他们又怎样能看到别的什么呢？
苏：那么，后面路上人举着过去的东西，除了它们的阴影而外，囚徒们能看到它们别的什么吗？
格：当然不能。
苏：那么，如果囚徒们能彼此交谈，你不认为，他们会断定，他们在讲自己所看到的阴影时是在讲真物本身吗？
格：必定如此。
苏：又，如果一个过路人发出声音，引起囚徒对面洞壁的回声，你不认为，囚徒们会断定，这是他们对面洞壁上移动的阴影发出的吗？
格：他们一定会这样断定的。
苏：因此无疑，这种人不会想到，上述事物除阴影而外还有什么别的实在。
格：无疑的。
苏：那么，请设想一下，如果他们被解除禁锢，矫正迷误，你认为这时他们会怎样呢？如果真的发生如下的事情：其中有一人被解除了桎梏，被迫突然站了起来，转头环视，走动，抬头看望火光，你认为这时他会怎样呢？他在做这些动作时会感觉痛苦的，并且，由于眼花缭乱，他无法看见那些他原来只看见其阴影的实物。如果有人告诉他，说他过去惯常看到的全然是虚假，如今他由于被扭向了比较真实的器物，比较地接近了实在，所见比较真实了，你认为他听了这话会说些什么呢？如果再有人把墙头上过去的每一器物指给他看，并且逼他说出那是些什么，你不认为，这时他会不知说什么是好，并且认为他过去所看到的阴影比现在所看到的实物更真实吗？
格：更真实得多呀！
苏：如果他被迫看火光本身，他的眼睛会感到痛苦，他会转身走开，仍旧逃向那些他能够看清而且确实认为比人家所指示的实物还更清楚更实在的影像的。不是吗？
格：会这样的。
苏：再说，如果有人硬拉他走上一条陡峭崎岖的坡道，直到把他拉出洞穴见到了外面的阳光，不让他中途退回去，他会觉得这样被强迫着走很痛苦，并且感到恼
火；当他来到阳光下时，他会觉得眼前金星乱蹦金蛇乱串，以致无法看见任何一个现在被称为真实的事物的。你不认为会这样吗？
格：噢，的确不是一下子就能看得见的。
苏：因此我认为，要他能在洞穴外面的高处看得见东西，大概需要有一个逐渐习惯的过程。首先大概看阴影是最容易，其次要数看人和其他东西在水中的倒影容
易，再次是看东西本身；经过这些之后他大概会觉得在夜里观察天象和天空本身，看月光和星光比白天看太阳和太阳光容易。
格：当然啰。
苏：这样一来，我认为，他大概终于就能直接观看太阳本身，看见他的真相了，就可以不必通过水中的倒影或影像，或任何其他媒介中显示出的影像看它了，就可以在它本来的地方就其本身看见其本相了。
格：这是一定的。
苏：接着他大概对此已经可以得出结论了：造成四季交替和年岁周期，主宰可见世界一切事物的正是这个太阳，它也就是他们过去通过某种曲折看见的所有那些事物的原因。
格：显然，他大概会接着得出这样的结论。
苏：如果他回想自己当初的穴居、那个时候的智力水平，以及禁锢中的伙伴们，你不认为，他会庆幸自己的这一变迁，而替伙伴们遗憾吗？
格：确实会的。
苏：如果囚徒们之间曾有过某种选举，也有人在其中赢得过尊荣，而那些敏于辨别而且最能记住过往影像的惯常次序，因而最能预言后面还有什么影像会跟上来的人还得到过奖励，你认为这个既已解放了的人他会再热衷于这种奖赏吗？对那些受到囚徒们尊重并成了他们领袖的人，他会心怀嫉妒，和他们争夺那里的权力地位吗？或者，还是会像荷马所说的那样，他宁愿活在人世上做一个穷人的奴隶，受苦受难，也不愿和囚徒们有共同意见，再过他们那种生活呢？
格：我想，他会宁愿忍受任何苦楚也不愿再过囚徒生活的。
苏：如果他又回到地穴中坐在他原来的位置上，你认为会怎么样呢？他由于突然地离开阳光走进地穴，他的眼睛不会因黑暗而变得什么也看不见吗？
格：一定是这样的。
苏：这时他的视力还很模糊，还没来得及习惯于黑暗——再习惯于黑暗所需的时间也不会是很短的。如果有人趁这时就要他和那些始终禁锢在地穴中的人们较量一下“评价影像”，他不会遭到笑话吗？人家不会说他到上面去走了一趟，回来眼睛就坏了，不会说甚至连起一个往上去的念头都是不值得的吗？要是把那个打算释放他们并把他们带到上面去的人逮住杀掉是可以的话，他们不会杀掉他吗？
格：他们一定会的。
苏：亲爱的格劳孔，现在我们必须把这个比喻整个儿地应用到前面讲过的事情上去，把地穴囚室比喻可见世界，把火光比喻太阳的能力。如果你把从地穴到上面世界并在上面看见东西的上升过程和灵魂上升到可知世界的上升过程联想起来，你就领会对了我的这一解释了，既然你急于要听我的解释。至于这一解释本身是不是对，这是只有神知道的。但是无论如何，我觉得，在可知世界中最后看见的，而且是要花很大的努力才能最后看见的东西乃是善的理念。我们一旦看见了它，就必定能得出下述结论：它的确就是一切事物中一切正确者和美者的原因，就是可见世界中创造光和光源者，在可理知世界中它本身就是真理和理性的决定性源泉；任何人凡能在私人生活或公共生活中行事合乎理性的，必定是看见了善的理念的。
格：就我所能了解的而言，我都同意。
苏：那么来吧，你也来同意我下述的看法吧，而且在看到下述情形时别感到奇怪吧：那些已达到这一高度的人不愿意做那些琐碎俗事，他们的心灵永远渴望逗留在高
处的真实之境。如果我们的比喻是合适的话，这种情形应该是不奇怪的。
格：是不足为怪的。
苏：再说，如果有人从神圣的观察再回到人事；他在还看不见东西还没有变得足够地习惯于黑暗环境时，就被迫在法庭上或其他什么地方同人家争论关于正义的影子
或产生影子的偶像，辩论从未见过正义本身的人头脑里关于正义的观念。如果他在这样做时显得样子很难看举止极可笑，你认为值得奇怪吗？
格：一点儿也不值得奇怪。
苏：但是，凡有头脑的人都会记得，眼睛有性质不同的两种迷茫，它们是由两种相应的原因引起的：一是由亮处到了暗处，另一是由暗处到了亮处。凡有头脑的人也都会相信，灵魂也能出现同样的情况。他在看到某个灵魂发生迷茫不能看清事物时，不会不假思索就予以嘲笑的，他会考察一下，灵魂的视觉是因为离开了较光明的生活被不习惯的黑暗迷误了的呢，还是由于离开了无知的黑暗进入了比较光明的世界，较大的亮光使它失去了视觉的呢？于是他会认为一种经验与生活道路是幸福的，另一种经验与生活道路是可怜的；如果他想笑一笑的话，那么从下面到上面去的那一种是不及从上面的亮处到下面来的这一种可笑的。
格：你说的非常有道理。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;认识到神造的“床”：这里其实又是一个贯穿哲学的讨论，由此引发的“本质”、“现象”的讨论，贯穿了后世哲学的两千多年。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>存储概述</title>
        <published>2024-10-02T14:11:34+08:00</published>
        <updated>2024-10-02T14:11:34+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/storage-introduction/"/>
        <id>https://liyan-ah.github.io/storage-introduction/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/storage-introduction/">&lt;blockquote&gt;
&lt;p&gt;最近工作中一直接触存储相关的内容，感觉对现在的存储分类及各个存储的优缺点等了解的还很少。趁着这个机会整理下相关的内容。相信会有收获。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;jian-jie&quot;&gt;简介&lt;&#x2F;h2&gt;
&lt;p&gt;存储是系统设计中不可缺少的一部分，而存储的选择又有很多种，相关的概念也很繁杂：关系型数据库、列数据库、文件型数据库等等。在为系统选择合适的数据库之前，显然需要了解这些数据库的概念及它们的优缺点。这些是笔者还不具备的能力。笔者试着在本文中对这些概念进行总结，并结合实践来论述下使用需要注意的内容。本文主要内容均整理自互联网文档。希望是个引子，后面依据实践，持续补充及修正涉及到的内容。&lt;&#x2F;p&gt;
&lt;p&gt;从工作中的经验来看，笔者对存储系统一般关注系统的存储方式、数据一致性的保障方式、如何进行扩展。部分已确定的内容罗列在下面：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;系统&lt;&#x2F;th&gt;&lt;th&gt;存储类型&lt;&#x2F;th&gt;&lt;th&gt;存储方式&lt;&#x2F;th&gt;&lt;th&gt;CAP满足&lt;&#x2F;th&gt;&lt;th&gt;扩展方式&lt;&#x2F;th&gt;&lt;th&gt;常见优化&lt;&#x2F;th&gt;&lt;th&gt;价格&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;MySQL&lt;&#x2F;td&gt;&lt;td&gt;关系型数据库&lt;&#x2F;td&gt;&lt;td&gt;B+树 (InnoDB引擎)&lt;&#x2F;td&gt;&lt;td&gt;CA（同步复制），AP（异步复制、半同步复制）&lt;&#x2F;td&gt;&lt;td&gt;一般采用主从同步的方式。通过消费binlog, redolog, undolog 来实现数据间的一致性。&lt;&#x2F;td&gt;&lt;td&gt;加机器（CPU、内存、SSD盘）、集群同步方式修改（异步同步）、读写分离、分库分表&lt;&#x2F;td&gt;&lt;td&gt;均衡&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Elasticsearch&lt;&#x2F;td&gt;&lt;td&gt;检索系统&lt;&#x2F;td&gt;&lt;td&gt;索引+JSON为基础的文档&lt;&#x2F;td&gt;&lt;td&gt;CA（设置同步配置），AP&lt;&#x2F;td&gt;&lt;td&gt;扩展 shard 来实现水平扩展&lt;&#x2F;td&gt;&lt;td&gt;增加 Shard，索引优化，加机器&lt;&#x2F;td&gt;&lt;td&gt;涉及到倒排索引的构建，较为耗费 CPU&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;mysql&quot;&gt;MySQL&lt;&#x2F;h2&gt;
&lt;p&gt;本节期望能够回答以下问题：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 是否一定是 B+ 树的存储结构。&lt;&#x2F;li&gt;
&lt;li&gt;InnoDB 为何选择 B+ 树数据结构。&lt;&#x2F;li&gt;
&lt;li&gt;一个 InnoDB 实例支持多少条数据记录。&lt;&#x2F;li&gt;
&lt;li&gt;InnoDB 中索引（含主键）都存储在哪里。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;2-1-jian-shu&quot;&gt;2.1 简述&lt;&#x2F;h3&gt;
&lt;p&gt;MySQL 是最经典的存储系统了，作为关系型数据库中当之无愧的主流，很难找出一个后端的系统（非某个单独的服务）在运行时可以完全不使用 MySQL（笔者工作的这些年还没有遇到过）。通常认为 MySQL 是行数据库，这通常是指 InnoDB 存储引擎是行数据库。需要注意的是，MySQL 同样是有列数据库引擎&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#12&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-2-innodb&quot;&gt;2.2 InnoDB&lt;&#x2F;h3&gt;
&lt;p&gt;MySQL 支持诸多的存储引擎，一般会使用 InnoDB&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#7&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;（当然也支持 MyISAM，CSV，内存等方式的存储引擎）。本文中对 MySQL 的介绍也默认以 InnoDB 作为存储引擎。从分类上来看，MySQL 是典型的关系型数据库了：它的所有数据检索、查询等操作都是以关系组织操作为核心的。在此基础上有诸如外键、多表联查等操作。关系型数据库也是比较贴合实际的各种数据关系并且易于理解的，很多数据库课程中往往会通过构建一个图书管理系统的方式来学习 MySQL，这里书籍种类标签、各种借阅的关系描述也是关系型数据库所擅长的。&lt;&#x2F;p&gt;
&lt;p&gt;InnoDB 引擎默认使用 B+ 树来存储数据&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#9&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：将索引存储在内存中而将实际的数据存储在磁盘中，而且由于 B+ 树的特点，使得任意记录所在的页均可通过有限次的检索动作来定位到，并加载到内存中做进一步的检索。这一点较好的兼容了数据的查询性能及数据的存储容量。实际的记录会存放在数据页中（一般在磁盘中）。而索引页一般会在 MySQL 进程启动后加载到内存中。值的注意的是，MySQL 实例启动后，可以支持多种通信方式：TCP 连接、管道｜共享内存（需要指定参数）、UNIX 套接字等。&lt;&#x2F;p&gt;
&lt;p&gt;InnoDB 引擎中，明确声明为主键的字段（或者在没有明确生命为主键的情况下，第一个被声明为索引的字段）会存储在聚集索引表中（B+树）。而非主键的索引则存储在辅助索引表中（同样为 B+ 树）。不同的是，与聚集索引表中会存储数据页的地址不同，辅助索引表中存储的是目标数据的聚集索引信息，即主键信息。当使用非主键索引查询数据时，需要先从辅助索引表中检索出主键的值，再到聚集索引中检索出实际数据页的内容并加载到内存中。在硬盘足够大的情况下，B+ 树中索引的设计决定了单个 InnoDB 实例能够存储多少数据&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#11&quot;&gt;4&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。需要注意的是， B+ 树并不是二叉树，父节点可能会有很多子节点。限制内存非叶节点中能够存储索引条数的因素包括索引字段的大小、InnoDB 自身的叶结构等。从理论上看，单个 InnoDB 实例能存储多少数据取决于单个 B+ 树能存储多少数据。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-3-dai-que-ren&quot;&gt;2.3 待确认&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;一条记录的写入、同步、查询的过程。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;elasticsearch&quot;&gt;Elasticsearch&lt;&#x2F;h2&gt;
&lt;p&gt;本节期望能够回答以下问题：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;ES 的数据存储方式。&lt;&#x2F;li&gt;
&lt;li&gt;ES 的数据同步方式。&lt;&#x2F;li&gt;
&lt;li&gt;ES 的数据存储、查询过程。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;3-1-jian-shu&quot;&gt;3.1 简述&lt;&#x2F;h3&gt;
&lt;p&gt;Elasticsearch，ES，也是经典的存储了，其本身基于 Lucene 进行构建。ES 强大的全文索引能力使得其经常运用在很多检索的场景中，比如视频网站或者简单的文档检索就可以直接使用 ES，从这一点看，预期说 ES 是存储系统，不如说 ES 是检索系统。因为其强大的检索能力，以 ES 为基础的 ELK 生态系统也是日志存储中可以开箱即用的解决方案。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;3-2-xi-tong-zu-cheng&quot;&gt;3.2 系统组成&lt;&#x2F;h3&gt;
&lt;p&gt;ES 对外通过 index 提供查询能力，index 又可以通过设置 shard 数目来达到横向扩展的能力。当一个 ES 集群的读写压力很大时，可以通过调大 shard 数来使得单个 shard 的读写压力更小。当然，如果每个 node 节点启动了很多的 shard，比如已经到了机器的性能极限，此时即使扩充 shard，物理机的限制也会使得 ES 的查询效果有优化效果。除了横向扩展，ES 还通过 Replicas 备份的方式来实现容灾备份的效果。当 index 中的某个 shard 出现异常时，可以切换到备份的分片中&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#14&quot;&gt;5&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。值的注意的是，index 中包含了正倒排的索引，而基础数据仍然是基于 JSON 的展示结构&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#19&quot;&gt;6&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;3-3-shu-ju-chu-li-guo-cheng&quot;&gt;3.3 数据处理过程&lt;&#x2F;h3&gt;
&lt;p&gt;数据的写入动作会由 Coordinate Node 来处理，该 Node 可能是集群中的任一 Node。而后会依据文档 ID 来路由到对应的 shard 组（包含其备份）中的一个 node1 上。node1 在处理完成本节点的操作后，会将请求并行发送到其他副本中，在确认其他副本写入完成后，会将写成功的结果发送回去（可以通过参数控制，满足了 C）&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#18&quot;&gt;7&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;数据在检索时，同样会将请求发送到 Coordinating Node，并在该 Node 上进行分词等操作。而后将分词结果发送到所有的 shard 上去检索 doc 的排序字段。排序字段检索结果依旧会汇聚到该 Node 上，排序后找到所需要的 doc id 并到该 doc 的 shard 上取获取实际的 doc，返回给 Client&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#20&quot;&gt;8&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;3-4-dai-que-ren&quot;&gt;3.4 待确认&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;完整的架构图。&lt;&#x2F;li&gt;
&lt;li&gt;完整的数据处理流程。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;clickhouse&quot;&gt;ClickHouse&lt;&#x2F;h2&gt;
&lt;p&gt;本节期望能够回答以下问题：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;CK 的数据存储方式，横向扩展方式。&lt;&#x2F;li&gt;
&lt;li&gt;CK 的数据同步方式。&lt;&#x2F;li&gt;
&lt;li&gt;CK 的数据存储、查询过程。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;4-1-jian-shu&quot;&gt;4.1 简述&lt;&#x2F;h3&gt;
&lt;p&gt;ClickHouse 是近几年比较火的列式存储数据库。其与行式存储的区别可以认为是：列式存储是以列为单位的存储。当一行中往往仅需要读取少数几个列的情况下，列存储能够获得更好的读取效果。而且，由于每列的数据往往是相同的类型，按照列进行存储可以更方便的进行压缩。这样的特性使得列存储在 OLAP 的场景下可以获得更好的检索效果及更好的资源利用率&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#22&quot;&gt;9&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;4-2-xi-tong-zu-cheng&quot;&gt;4.2 系统组成&lt;&#x2F;h3&gt;
&lt;p&gt;CK 同样有诸多的表引擎，使用比较广泛的是 MergeTree。一般来说，每个 Table 可以按照多个 Partition 来进行划分。&lt;&#x2F;p&gt;
&lt;p&gt;集群部署时，一般使用 ZooKeeper 来维护集群的关系，启动多个节点并按照节点的角色划分来实现主备及横向扩展。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;4-3-dai-que-ren&quot;&gt;4.3 待确认&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;CK 数据同步方式。&lt;&#x2F;li&gt;
&lt;li&gt;CK 数据处理过程。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;hou-ji&quot;&gt;后记&lt;&#x2F;h2&gt;
&lt;p&gt;存储是一个很广大的领域。仅本文中设计到的 MySQL、ES、CK 这三种典型的存储系统就消耗了笔者两天的时间来准备文档，而且涉及的内容还很浅。而本文中未涉及到的 Druid、HDFS、Redis、RocksDB、Cassandra 等涉及的存储内容更多。感觉笔者一时怕是无法有效的整理完成。本次且这样吧。&lt;&#x2F;p&gt;
&lt;p&gt;在本次整理的过程中，笔者同样感觉到资料的缺失：MySQL 的文档及图书资料较为丰富，到后面的 ES、CK 等就开始缺少内容了。希望笔者能够贡献若干篇有深度的文章。&lt;&#x2F;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;10&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;draveness.me&#x2F;mysql-innodb&#x2F;。较为详细的介绍了 InnoDB 的一些概念。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;11&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;wtzbk&#x2F;p&#x2F;14410608.html。介绍了 MySQL 数据写入时的处理过程。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;12&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;danielzzz&#x2F;p&#x2F;16852877.html。MySQL 如何保障数据一致性。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;4&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;13&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6895761455358935053。MySQL 的 CAP 取舍介绍。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;5&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;14&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;64578822&#x2F;cap-theorm-why-mysql-is-ca。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;6&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;15&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;kylinlin&#x2F;p&#x2F;5258719.html。MySQL 主从同步过程介绍。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;7&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;8.4&#x2F;en&#x2F;innodb-introduction.html。InnoDB introduction。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;8&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;16&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1899186。InnoDB 为什么要选择 B+ 树来存储数据。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;9&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;medium.com&#x2F;@relieved_gold_mole_613&#x2F;why-does-mysql-use-b-trees-7807ed3090bc。 why does mysql use b+ tree。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;10&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;17&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;book.douban.com&#x2F;subject&#x2F;24708143&#x2F;。MySQL 技术内幕（InnoDB 存储引擎）。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;11&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;4&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;2123136。单表最大 2000 万行数据。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;12&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;dhName&#x2F;p&#x2F;14233938.html。mysql 的存储引擎和 infobright 引擎说明。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;13&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;18&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;elasticsearch.cn&#x2F;article&#x2F;6178。ES 中数据是如何存储的。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;14&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;5&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;32990496。从 Elasticsearch 来看分布式架构系统设计。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;15&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;19&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;fxh0707&#x2F;p&#x2F;17126196.html。ES 文档存储流程。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;16&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;20&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;2398626。Elasticsearch 数据写入、检索流程及底层原理全方位解析。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;17&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;21&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;elasticsearch&#x2F;reference&#x2F;current&#x2F;docs-replication.html。Reading and Writing documents。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;18&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;7&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jimoer&#x2F;p&#x2F;15573952.html。ES 写入数据的过程是怎样的？以及是如何快速更新索引数据的？&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;19&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;6&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.knowi.com&#x2F;blog&#x2F;what-is-elastic-search&#x2F;。what is elastic search。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;20&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;8&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;liuzhihang&#x2F;p&#x2F;elasticsearch-4.html。ES 查询检索数据的过程。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;21&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;22&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;xie.infoq.cn&#x2F;article&#x2F;9f325fb7ddc5d12362f4c88a8。行式存储与列式存储。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;22&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;9&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;ya-qiang&#x2F;p&#x2F;13680283.html。ClickHouse 的特性。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;23&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;23&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;clickhouse.com&#x2F;docs&#x2F;zh&#x2F;development&#x2F;architecture。ClickHouse 架构概述。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;24&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;24&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;crazymakercircle&#x2F;p&#x2F;16718469.html。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;25&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;25&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1953788。常见 ClickHouse 集群部署架构。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;26&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;26&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;xie.infoq.cn&#x2F;article&#x2F;cc6415931f2f9aa26b6ae12e2。ClickHouse 常见集群部署架构。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;27&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;27&lt;&#x2F;sup&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;eedbaa&#x2F;p&#x2F;14512803.html。ClickHouse 数据存储结构。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>Datafusion 学习（0）</title>
        <published>2024-09-08T17:25:22+08:00</published>
        <updated>2024-09-08T17:25:22+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/datafusion-learning-0/"/>
        <id>https://liyan-ah.github.io/datafusion-learning-0/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/datafusion-learning-0/">&lt;blockquote&gt;
&lt;p&gt;开始搞存储了。从3月份开始到9月，大概搞了6个月。项目跌跌撞撞的开始了。但是项目中用到的很多基础知识还是欠缺的。期望通过这个系列的博客来总结下。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;datafusion-jie-shao&quot;&gt;Datafusion 介绍&lt;&#x2F;h2&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>【译文&#x2F;effective-rust】第 30 条：不仅仅是单测</title>
        <published>2024-09-08T16:35:05+08:00</published>
        <updated>2024-09-08T16:35:05+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/write-more-than-unit-tests/"/>
        <id>https://liyan-ah.github.io/write-more-than-unit-tests/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/write-more-than-unit-tests/">&lt;blockquote&gt;
&lt;p&gt;“所有的公司都拥有测试环境。但只有那些幸运的公司拥有独立于测试环境的生产环境。” —— @FearlessSon&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;和大多数其他的现代编程语言一样，Rust 也包含一些便于&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch11-00-testing.html&quot;&gt;编写测试&lt;&#x2F;a&gt;的特性。借助这些特性，你可以将单测和代码共存。而通过测试，可以提升代码运行准确性的信心。&lt;&#x2F;p&gt;
&lt;p&gt;这并非是兜售测试重要性的文章。从测试最基本功能来说，如果代码缺少了测试，它很可能并非如我们所希望的那样运行。本条目是在你已经建立了&lt;strong&gt;为代码编写测试&lt;&#x2F;strong&gt;这一信念的基础上展开的。&lt;&#x2F;p&gt;
&lt;p&gt;单元测试（unit tests）以及集成测试（integration tests）是测试领域内的两大重要成员。在接下来的两节内将会介绍。但是，Rust 工具链，也包括它的扩展，允许多种多样的测试形式。本条目将会介绍它们的基本使用流程及应用场景。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dan-yuan-ce-shi&quot;&gt;单元测试&lt;&#x2F;h2&gt;
&lt;p&gt;Rust 代码中最常见的测试类型是单元测试：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F; ... (code defining `nat_subtract*` functions for natural
&#x2F;&#x2F;      number subtraction)

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_nat_subtract() {
        assert_eq!(nat_subtract(4, 3).unwrap(), 1);
        assert_eq!(nat_subtract(4, 5), None);
    }

    #[should_panic]
    #[test]
    fn test_something_that_panics() {
        nat_subtract_unchecked(4, 5);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这段单测示例体现了 Rust 所有单测都会有的形式：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;使用模块对单测函数进行封装。&lt;&#x2F;li&gt;
&lt;li&gt;每个单测都会使用&lt;code&gt;#[test]&lt;&#x2F;code&gt;属性来进行标志。&lt;&#x2F;li&gt;
&lt;li&gt;用来测试的模块使用&lt;code&gt;#[cfg(test)]&lt;&#x2F;code&gt;进行声明，所以单测的代码仅会在测试时生效。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;示例也展示了一些仅在特定测试中才会出现的形式：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;这里的测试代码放置在单独的模块里，模块名一般为&lt;code&gt;tests&lt;&#x2F;code&gt;或者&lt;code&gt;test&lt;&#x2F;code&gt;。这个模块可以和逻辑代码放置在一起，或者放置在单独的&lt;em&gt;tests.rs&lt;&#x2F;em&gt;文件里。放置在单独的文件里可以让人更加便捷的区分代码是用来测试的，还是用于一般的功能逻辑。&lt;&#x2F;li&gt;
&lt;li&gt;测试的模块可以使用一个通配符&lt;code&gt;use super::*&lt;&#x2F;code&gt;来将父模块的所有依赖都声明到测试模块里。这种操作可以让编写测试代码更加方便（同时依据&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_4&#x2F;item23-wildcard.html&quot;&gt;第 23 条&lt;&#x2F;a&gt;来说，通配符的引入是一种要规避的操作）。&lt;&#x2F;li&gt;
&lt;li&gt;在模块的一般可达性规则下，单测可以使用所有父模块里包含的内容，无论是否声明为公共的。基于单测对内部功能可访问的特点，可以对代码进行“开箱”测试。&lt;&#x2F;li&gt;
&lt;li&gt;测试代码使用&lt;code&gt;expect()&lt;&#x2F;code&gt;或者&lt;code&gt;unwrap()&lt;&#x2F;code&gt;来标志其希望的结果。显然，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_3&#x2F;item18-panic.html&quot;&gt;第 18 条&lt;&#x2F;a&gt;中声明的规则并不适用这些单测的代码。单测中需要使用&lt;code&gt;panic!&lt;&#x2F;code&gt;来标注失败的结果。同样的，测试的代码中也会使用&lt;code&gt;assert_eq!&lt;&#x2F;code&gt;来校验期待的值，并且会在失败时抛出&lt;code&gt;panic&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;测试代码中使用了一个函数，该函数在一些非法的输入下会造成&lt;code&gt;panic&lt;&#x2F;code&gt;。为了校验该函数的这一功能是否生效，单测的函数中使用了&lt;code&gt;#[should_panic]&lt;&#x2F;code&gt;特性。这一特性在需要测试一个内部函数且希望保持这个函数的各校验规则不发生改变，或者测试一个公共的函数且由于一些原因需要忽略&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_3&#x2F;item18-panic.html&quot;&gt;第 18 条&lt;&#x2F;a&gt;中的建议。（这样的函数需要在它的注释文档中有“Panics”小节，就像&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_5&#x2F;item27-document-public-interfaces.html&quot;&gt;第 27 条&lt;&#x2F;a&gt;中描述的。）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_5&#x2F;item27-document-public-interfaces.html&quot;&gt;第 27 条&lt;&#x2F;a&gt;中建议不要对已经通过类型表述出的内容。同样的，也不需要对已经由类型进行约束的内容进行测试。如果你的&lt;code&gt;enum&lt;&#x2F;code&gt;类型派生出了不在声明列表中罗列的变量，你可能遇到了比单测失败更加严重的问题。&lt;&#x2F;p&gt;
&lt;p&gt;然而，如果你的代码依赖了一些依赖库中的独特功能，对这些功能准备基础的单测会很有用。这里的单测目的并非是重复依赖中已经具备的功能测试，而是尽量早地暴露依赖的包依赖的这些功能发生了变更的风险 —— 尤其是公共的接口约定发生了变化，通常应当通过版本号来表明（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;semver.html&quot;&gt;第 21 条&lt;&#x2F;a&gt;）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ji-cheng-ce-shi&quot;&gt;集成测试&lt;&#x2F;h2&gt;
&lt;p&gt;Rust 项目中另一种常用到的测试模式是：&lt;em&gt;集成测试&lt;&#x2F;em&gt;（integration tests），测试通常被放置在&lt;code&gt;tests&#x2F;&lt;&#x2F;code&gt;目录下。这个目录下的每个文件都会作为一个单独的测试程序运行，每个测试程序都会执行其包含的所有以&lt;code&gt;#[test]&lt;&#x2F;code&gt;标志的测试函数。&lt;&#x2F;p&gt;
&lt;p&gt;集成测试没有访问包内部内容的权限，因此集成测试仅能覆盖包的公共 API。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wen-dang-ce-shi&quot;&gt;文档测试&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_5&#x2F;item27-document-public-interfaces.html&quot;&gt;第 27 条&lt;&#x2F;a&gt;描述了在注释中包含一小段代码的示例，通常是为了说明特定的公共 API 的使用方式。每段这样的代码都包含在一个隐式的&lt;code&gt;fn main() { ... }&lt;&#x2F;code&gt;函数中，并且可以在&lt;code&gt;cargo test&lt;&#x2F;code&gt;时被执行。这是一种高效的代码添加测试用例的方法，一般被称为&lt;em&gt;文档测试&lt;&#x2F;em&gt;（doc tests）。每个类似的测试都可以通过&lt;code&gt;cargo test --doc &amp;lt;item-name&amp;gt;&lt;&#x2F;code&gt;的方式来选择性的执行。&lt;&#x2F;p&gt;
&lt;p&gt;定期的通过 CI 系统（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;ci.html&quot;&gt;第 32 条&lt;&#x2F;a&gt;）来执行这些测试可以确保代码不会离包中期望提供的 API 太远。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dai-ma-shi-li&quot;&gt;代码示例&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_5&#x2F;item27-document-public-interfaces.html&quot;&gt;第 27 条&lt;&#x2F;a&gt;也描述了为公共接口提供示例代码的实践。在&lt;code&gt;examples&#x2F;&lt;&#x2F;code&gt;目录下的每个 Rust 文件（或者&lt;code&gt;examples&lt;&#x2F;code&gt;目录下每个子目录中的&lt;code&gt;main.rs&lt;&#x2F;code&gt;文件）都可以通过&lt;code&gt;cargo run --example &amp;lt;name&amp;gt;&lt;&#x2F;code&gt;或者&lt;code&gt;cargo test --example &amp;lt;name&amp;gt;&lt;&#x2F;code&gt;的方式来作为独立的可执行文件运行。&lt;&#x2F;p&gt;
&lt;p&gt;这些程序仅能访问包中的公共接口，并且可以说明这些公共接口的使用方式。示例代码并非被设计为测试代码（没有&lt;code&gt;#[test]&lt;&#x2F;code&gt;，没有&lt;code&gt;[cfg(test)]&lt;&#x2F;code&gt;的标注），而且由于处于一些不起眼的角落，它们并不适合放置代码 —— 尤其是，它们并不在&lt;code&gt;cargo test&lt;&#x2F;code&gt;时默认执行。&lt;&#x2F;p&gt;
&lt;p&gt;尽管如此，CI 系统（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;ci.html&quot;&gt;第 32 条&lt;&#x2F;a&gt;）构建并且运行这些示例代码（通过&lt;code&gt;cargo test --examples&lt;&#x2F;code&gt;）仍然是一个很好的实践。通过执行这些代码，可以为那些会影响大多数用户的接口提供一个很好的回归校验机制。特别地，如果你的示例揭示了接口使用的一般方式，那么示例运行的失败往往意味着存在如下的错误：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;如果这是个高超的错误，它可能会影响很多用户 —— 示例中的代码将会被很多用户复制、粘贴或者参照。&lt;&#x2F;li&gt;
&lt;li&gt;如果公共接口发生了变更，那么这些示例也需要参照最新的接口定义来实现。接口的改变往往意味着不兼容。所以当包被发布时，版本号需要随着调整以说明这是个不兼容的升级（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;semver.html&quot;&gt;第 21 条&lt;&#x2F;a&gt;）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;用户复制、粘贴测试代码的行为意味着示例代码和测试代码的形式有很大的不同。如&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_3&#x2F;item18-panic.html&quot;&gt;第 18 条&lt;&#x2F;a&gt;中描述的一样，你可以避免对 Results 进行 unwrap() 使用，从而为用户提供一个很好的参照。同样的，在每个示例代码的&lt;code&gt;main()&lt;&#x2F;code&gt;函数中返回类似&lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;&#x2F;code&gt;的结果，并且在内部使用&lt;code&gt;?&lt;&#x2F;code&gt;符号来组织代码（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item3-transform.html&quot;&gt;第 3 条&lt;&#x2F;a&gt;）也是一种很好的行为。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ji-zhun-ce-shi&quot;&gt;基准测试&lt;&#x2F;h2&gt;
&lt;p&gt;[第 20 条]试图说明极致的代码性能优化并非总是必要的。尽管如此，有时性能肯定时很关键的，并且在这种情况下，衡量以及追踪代码的性能变化是很好的实践。具备定期运行的&lt;em&gt;基准测试&lt;&#x2F;em&gt;（benchmarks）（比如，作为 CI 系统的一部分，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;ci.html&quot;&gt;第 32 条&lt;&#x2F;a&gt;）允许你发觉代码或者工具链的变更可以如何影响代码的性能。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;[cargo bench]&lt;&#x2F;code&gt;命令可以运行重复执行特定操作的测试代码，并且计算出这个操作的平均耗时。在撰写本文时，Rust 对基准测试的支持还不太稳定，所以基准测试相关的指令需要通过&lt;code&gt;cargo +nightly bench&lt;&#x2F;code&gt;的方式来执行。（Rust 不稳定的特性，包括本文中使用的&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;unstable-book&#x2F;library-features&#x2F;test.html&quot;&gt;test&lt;&#x2F;a&gt;特性，都描述在 Rust &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;unstable-book&#x2F;the-unstable-book.html&quot;&gt;Unstable Book&lt;&#x2F;a&gt;中。）&lt;&#x2F;p&gt;
&lt;p&gt;然而，这里存在着编译器给出错误结果的风险，尤其是当你将操作约束在很简单的代码时。考虑如下一个简单的算数函数：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;pub fn factorial(n: u128) -&amp;gt; u128 {
    match n {
        0 =&amp;gt; 1,
        n =&amp;gt; n * factorial(n - 1),
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这段代码的一个简单的基准测试实现是：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;#![feature(test)]
extern crate test;

#[bench]
fn bench_factorial(b: &amp;amp;mut test::Bencher) {
    b.iter(|| {
        let result = factorial(15);
        assert_eq!(result, 1_307_674_368_000);
    });
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出了一段奇妙的结果：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;test bench_factorial             ... bench:           0 ns&#x2F;iter (+&#x2F;- 0)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于在测试过程中使用固定的输入以及很少的代码指令，编译器可能会对迭代进行优化并且直接输出计算结果。这就将会导致不切实际的测试结论。&lt;&#x2F;p&gt;
&lt;p&gt;使用 &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;hint&#x2F;fn.black_box.html&quot;&gt;std::hint::black_box&lt;&#x2F;a&gt; 可以解决这一问题。这是一个标志函数，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rfcs&#x2F;2360-bench-black-box.html&quot;&gt;编辑器识别后将不&lt;&#x2F;a&gt;对其进行优化。&lt;&#x2F;p&gt;
&lt;p&gt;上述基准测试可以变更为如下形式：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;#[bench]
fn bench_factorial(b: &amp;amp;mut test::Bencher) {
    b.iter(|| {
        let result = factorial(std::hint::black_box(15));
        assert_eq!(result, 1_307_674_368_000);
    });
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;给出了如下更加接近实际的结果：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;test blackboxed::bench_factorial ... bench:          16 ns&#x2F;iter (+&#x2F;- 3)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust.godbolt.org&#x2F;&quot;&gt;Godbolt 编辑资源管理器&lt;&#x2F;a&gt;也可以通过展示实际的机器码的方式来辅助测试，这样就能让实际执行的优化后的字节码变得清晰以确认是否过度优化而不能得到实际的结果。&lt;&#x2F;p&gt;
&lt;p&gt;最后，如果你为 Rust 代码准备了基准测试，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;criterion&quot;&gt;criterion&lt;&#x2F;a&gt;包可能提供了&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;test&#x2F;bench&#x2F;struct.Bencher.html&quot;&gt;test::bench::Bencher&lt;&#x2F;a&gt;的替代品，而且使用起来更加便捷（可以在稳定的 Rust 工具链上运行），功能也更多（支持结果的数据统计及图表）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mo-hu-ce-shi&quot;&gt;模糊测试&lt;&#x2F;h2&gt;
&lt;p&gt;模糊测试（fuzzy testing）是将代码暴露在随机输入中以期能够发现错误，尤其导致异常的场景，的测试方法。从技术校验的角度来说它已经很重要了，而当你的输入会被其他人填充或者攻击时，它将会显得更加重要 —— &lt;strong&gt;所以如果你的代码输入可能暴露给潜在的攻击者时，你应当使用模糊测试&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;从历史上来看，C&#x2F;C++ 代码通过模糊测试发现的往往时内存安全问题，通常会通过结合模糊测试与内存访问模式的运行时结合来检测（比如&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;AddressSanitizer.html&quot;&gt;AddressSanitizer&lt;&#x2F;a&gt;或者&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clang.llvm.org&#x2F;docs&#x2F;ThreadSanitizer.html&quot;&gt;ThreadSanitizer&lt;&#x2F;a&gt;）。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 对其中的一些（但并非全部）内存安全问题免疫，尤其是未引入&lt;code&gt;unsafe&lt;&#x2F;code&gt;的代码时（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_3&#x2F;item16-unsafe.html&quot;&gt;第 16 条&lt;&#x2F;a&gt;）。然而，Rust 并不能杜绝全部的错误，触发&lt;code&gt;panic!&lt;&#x2F;code&gt;（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_3&#x2F;item18-panic.html&quot;&gt;第 18 条&lt;&#x2F;a&gt;）的代码仍可能引发导致拒绝服务攻击（denial-of-service，DOS）。&lt;&#x2F;p&gt;
&lt;p&gt;模糊测试的最佳实践是以&lt;em&gt;覆盖率引导&lt;&#x2F;em&gt;：测试的基础设施监控代码的哪些部分被执行，随机更改输入直至能够触发新的代码路径。“&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lcamtuf.coredump.cx&#x2F;afl&#x2F;&quot;&gt;American fuzzy lop&lt;&#x2F;a&gt;”（AFL）是其中的佼佼者。但是近些年来，类似的功能已经被引入了 LLVM 的工具链，比如&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LibFuzzer.html&quot;&gt;libFuzzer&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 编译器是在 LLVM 的基础上构建的，因此&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-fuzz&#x2F;cargo-fuzz&quot;&gt;cargo-fuzz&lt;&#x2F;a&gt;自然地为 Rust 引入了&lt;code&gt;libFuzzer&lt;&#x2F;code&gt;（仅在部分平台上可用）。&lt;&#x2F;p&gt;
&lt;p&gt;模糊测试的首要要求是确定代码的入口点，该入口点需要采用（或者可以适应）任意字节的数据作为输入：&lt;&#x2F;p&gt;
&lt;div class=&quot;ferris&quot;&gt;&lt;img src=&quot;..&#x2F;images&#x2F;ferris&#x2F;not_desired_behavior.svg&quot; width=&quot;75&quot; height=&quot;75&quot; &#x2F;&gt;&lt;&#x2F;div&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Determine if the input starts with &amp;quot;FUZZ&amp;quot;.
pub fn is_fuzz(data: &amp;amp;[u8]) -&amp;gt; bool {
    if data.len() &amp;gt;= 3 &#x2F;* oops *&#x2F;
    &amp;amp;&amp;amp; data[0] == b&amp;#39;F&amp;#39;
    &amp;amp;&amp;amp; data[1] == b&amp;#39;U&amp;#39;
    &amp;amp;&amp;amp; data[2] == b&amp;#39;Z&amp;#39;
    &amp;amp;&amp;amp; data[3] == b&amp;#39;Z&amp;#39;
    {
        true
    } else {
        false
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当目标入口点确定后，Rust &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-fuzz.github.io&#x2F;book&#x2F;&quot;&gt;Fuzz Book&lt;&#x2F;a&gt;给出了如何启动测试的说明。它的核心是一个小型的驱动程序，会将目标入口点连接到模糊测试的基础设施上：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F; fuzz&#x2F;fuzz_targets&#x2F;target1.rs file
#![no_main]
use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &amp;amp;[u8]| {
    let _ = somecrate::is_fuzz(data);
});
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;运行&lt;code&gt;cargo +nightly fuzz run target1&lt;&#x2F;code&gt;将会持续使用随机数据来执行模糊测试的目标函数，直至异常出现。上述示例中，错误将被立即发现：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;INFO: Running with entropic power schedule (0xFF, 100).
INFO: Seed: 1607525774
INFO: Loaded 1 modules: 1624 [0x108219fa0, 0x10821a5f8),
INFO: Loaded 1 PC tables (1624 PCs): 1624 [0x10821a5f8,0x108220b78),
INFO:        9 files found in fuzz&#x2F;corpus&#x2F;target1
INFO: seed corpus: files: 9 min: 1b max: 8b total: 46b rss: 38Mb
#10	INITED cov: 26 ft: 26 corp: 6&#x2F;22b exec&#x2F;s: 0 rss: 39Mb
thread panicked at &amp;#39;index out of bounds: the len is 3 but the index is 3&amp;#39;,
     testing&#x2F;src&#x2F;lib.rs:77:12
stack backtrace:
   0: rust_begin_unwind
             at &#x2F;rustc&#x2F;f77bfb7336f2&#x2F;library&#x2F;std&#x2F;src&#x2F;panicking.rs:579:5
   1: core::panicking::panic_fmt
             at &#x2F;rustc&#x2F;f77bfb7336f2&#x2F;library&#x2F;core&#x2F;src&#x2F;panicking.rs:64:14
   2: core::panicking::panic_bounds_check
             at &#x2F;rustc&#x2F;f77bfb7336f2&#x2F;library&#x2F;core&#x2F;src&#x2F;panicking.rs:159:5
   3: somecrate::is_fuzz
   4: _rust_fuzzer_test_input
   5: ___rust_try
   6: _LLVMFuzzerTestOneInput
   7: __ZN6fuzzer6Fuzzer15ExecuteCallbackEPKhm
   8: __ZN6fuzzer6Fuzzer6RunOneEPKhmbPNS_9InputInfoEbPb
   9: __ZN6fuzzer6Fuzzer16MutateAndTestOneEv
  10: __ZN6fuzzer6Fuzzer4LoopERNSt3__16vectorINS_9SizedFileENS_
      16fuzzer_allocatorIS3_EEEE
  11: __ZN6fuzzer12FuzzerDriverEPiPPPcPFiPKhmE
  12: _main
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;导致上述错误的测试数据也给出了。&lt;&#x2F;p&gt;
&lt;p&gt;一般来说，模糊测试并不能如此快地发现错误，因此将模糊测试作为 CI 流程中的一部分也是没有意义的。模糊测试的不确定性及随之而来的计算成本意味着你需要考虑如何开展以及何时开展模糊测试 —— 可能仅需要在新的发布版本或者主要变更发生时才运行，或者仅运行确定性的时间&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;你也可以通过存储和重用先前模糊测试程序已找到用来触发新的代码路径的语料库的方式来加速模糊测试的执行。这将有助于后续的模糊测试过程将时间放在尝试新的输入上，而非重新测试以前访问过的代码路径。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ce-shi-de-jian-yi&quot;&gt;测试的建议&lt;&#x2F;h2&gt;
&lt;p&gt;一般性的建议也适用于 Rust 项目中：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;由于测试是需要持续进行的，&lt;strong&gt;每次变更后都需要在 CI 中执行单测&lt;&#x2F;strong&gt;（除了模糊测试）。&lt;&#x2F;li&gt;
&lt;li&gt;当你在修复一个错误时，&lt;strong&gt;在修复前，准备一个能反映错误的测试用例&lt;&#x2F;strong&gt;。这样当你完成错误的修复时，就可以通过测试用例的执行来说名修复效果。并且在未来不会重新引入。&lt;&#x2F;li&gt;
&lt;li&gt;如果你的包中包含了某些功能（[第 26 条]），&lt;strong&gt;对所有可能的功能组合都要进行测试&lt;&#x2F;strong&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;更一般性的，如果你的包中包含了任何特殊的配置，（比如，&lt;code&gt;#[cfg(target_os=&quot;windows&quot;)]&lt;&#x2F;code&gt;），&lt;strong&gt;每种包含了独特配置的平台上的测试都需要运行&lt;&#x2F;strong&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这些建议包含了很多不同类型的测试，在项目中应当选择那些最有价值的测试。&lt;&#x2F;p&gt;
&lt;p&gt;如果你有很多测试的代码并且会将你的包推送到&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;&quot;&gt;crates.io&lt;&#x2F;a&gt;中，那么就需要考虑下哪些测试项发布后是有意义的。一般地，&lt;code&gt;cargo&lt;&#x2F;code&gt;项目中会包含单元测试、集成测试、基准测试以及代码示例（但是并没有包含模糊测试，因为&lt;code&gt;cargo-fuzz&lt;&#x2F;code&gt;工具会将模糊测试的内容放置在包的子目录中）等等远超一般用户使用所需要的测试项。如果某些测试项并非是必须的，你可以&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;manifest.html#the-exclude-and-include-fields&quot;&gt;移除&lt;&#x2F;a&gt;一些测试项或者将这些测试项（尤其是行为性的测试）移入单独的测试包中。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xu-yao-zhu-yi-de-dian&quot;&gt;需要注意的点&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;编写单元测试来达到全面测试的目的，包括仅包含内部代码的测试。通过&lt;code&gt;cargo test&lt;&#x2F;code&gt;来运行它们。&lt;&#x2F;li&gt;
&lt;li&gt;编写集成测试代码来测试公共的接口。通过&lt;code&gt;cargo test&lt;&#x2F;code&gt;来运行它们。&lt;&#x2F;li&gt;
&lt;li&gt;编写文档测试来校验公共接口的调用方式。通过&lt;code&gt;cargo test&lt;&#x2F;code&gt;来调用它们。&lt;&#x2F;li&gt;
&lt;li&gt;编写示例代码来完整的说明如何使用包中的公共 API。通过&lt;code&gt;cargo test --exmaples&lt;&#x2F;code&gt;或者&lt;code&gt;cargo run --example &amp;lt;name&amp;gt;&lt;&#x2F;code&gt;的方式来运行它们。&lt;&#x2F;li&gt;
&lt;li&gt;如果代码对性能有很明确的要求，编写基准测试来确认代码的性能表现。通过&lt;code&gt;cargo bench&lt;&#x2F;code&gt;来执行它们。&lt;&#x2F;li&gt;
&lt;li&gt;如果代码会暴露在未被信任的输入中，编写模糊测试来确认对输入的参数的约束。通过&lt;code&gt;cargo fuzz&lt;&#x2F;code&gt;来（持续地）运行它们。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;zhu-shi&quot;&gt;注释&lt;&#x2F;h3&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;如果你的代码是一个被广泛运用的开源包，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;google.github.io&#x2F;oss-fuzz&#x2F;getting-started&#x2F;accepting-new-projects&#x2F;&quot;&gt;Google OSS-Fuzz program&lt;&#x2F;a&gt;可以为你的项目进行模糊测试。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;原文&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;testing.html&quot;&gt;点这里&lt;&#x2F;a&gt;查看&lt;&#x2F;p&gt;
&lt;!-- 参考链接 --&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>【译文&#x2F;effective-rust】第 29 条：遵循 Clippy 的建议</title>
        <published>2024-09-08T16:30:36+08:00</published>
        <updated>2024-09-08T16:30:36+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/listen-to-clippy/"/>
        <id>https://liyan-ah.github.io/listen-to-clippy/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/listen-to-clippy/">&lt;blockquote&gt;
&lt;p&gt;“看起来你在写信。需要什么帮助么？” —— &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Office_Assistant&quot;&gt;Microsoft Clippit&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;use-tools.html&quot;&gt;第 31 条&lt;&#x2F;a&gt;会描述了 Rust 工具箱中一些很有用的工具。但是其中一个特别有用且重要的工具值的在这里进行进行单独的介绍：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rust-clippy#clippy&quot;&gt;Clippy&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;Clippy 是 Cargo 的一个附加模块（通过&lt;code&gt;cargo clippy&lt;&#x2F;code&gt;的方式调用）。它可以生成涵盖多种类别的&lt;code&gt;warining&lt;&#x2F;code&gt;信息：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;正确性：提示常见的编程错误。&lt;&#x2F;li&gt;
&lt;li&gt;风格：提示不完全符合 Rust 标准风格的代码结构。&lt;&#x2F;li&gt;
&lt;li&gt;简洁性：指出能让代码更加简洁的可行变更。&lt;&#x2F;li&gt;
&lt;li&gt;性能：提示能避免无效处理或者内存分配的可选项。&lt;&#x2F;li&gt;
&lt;li&gt;可读性：给出能让代码更易读或者更易懂的建议。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;比如，如下这段代码编译是正常的：&lt;&#x2F;p&gt;
&lt;div class=&quot;ferris&quot;&gt;&lt;img src=&quot;..&#x2F;images&#x2F;ferris&#x2F;not_desired_behavior.svg&quot; width=&quot;75&quot; height=&quot;75&quot; &#x2F;&gt;&lt;&#x2F;div&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;pub fn circle_area(radius: f64) -&amp;gt; f64 {
    let pi = 3.14;
    pi * radius * radius
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是 Clippy 会指出这里对 π 的近似赋值是没必要且不准确的：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;error: approximate value of `f{32, 64}::consts::PI` found
 --&amp;gt; src&#x2F;main.rs:5:18
  |
5 |         let pi = 3.14;
  |                  ^^^^
  |
  = help: consider using the constant directly
  = help: for further information visit
    https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;master&#x2F;index.html#approx_constant
  = note: `#[deny(clippy::approx_constant)]` on by default
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;链接中的文档解释了问题并且给出了优化代码的方式。上述示例可调整为：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;pub fn circle_area(radius: f64) -&amp;gt; f64 {
    std::f64::consts::PI * radius * radius
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;正如示例中所展示的，每个 Clippy 警告都会伴随着一个网页的链接来描述问题。链接的网页中会说明为什么目标代码会被认为是不恰当的。这些说明很重要：它们的存在使得你可以自行判断采纳这些建议或者由于特殊的原因而忽略它们。有的时候，说明文本中还会描述一些校验器的已知问题，这些描述会解释一些令人困惑的误报。&lt;&#x2F;p&gt;
&lt;p&gt;如果你认定一些警告信息和自己的代码没有关系，你可以通过添加(#[allow(clippy::some_line)])来忽略关联代码的报错，或者在包的顶层（top level）添加(#![allow(clipy::some_lint)])来忽略整个包中的警告信息。通常情况下，建议调整目标代码而非花费很多时间来确认警告关联的代码是否是一个罕见的误报。&lt;&#x2F;p&gt;
&lt;p&gt;无论你选择了修复或者忽略掉这些警告信息，请&lt;strong&gt;确保你的代码中没有 Clippy-warning 的信息&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;这样，当新的警告信息出现时 —— 无论是由于代码发生了调整还是 Clippy 升级后包含了新的校验信息 —— 我们就能够及时的关注到。Clippy 也应当被纳入你的持续集成系统中（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;ci.html&quot;&gt;第 32 条&lt;&#x2F;a&gt;）。&lt;&#x2F;p&gt;
&lt;p&gt;Clippy 的警告信息在你学习 Rust 时特别重要，因为它们可以揭示那些被你忽略的细节，并帮助你熟悉 Rust 的风格。&lt;&#x2F;p&gt;
&lt;p&gt;本书中提到的很多建议，在 Clippy 中均存在相关的警告信息：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item1-use-types.html&quot;&gt;第 1 条&lt;&#x2F;a&gt;建议使用更具表现力的类型，而非一般的&lt;code&gt;bool&lt;&#x2F;code&gt;类型。Clippy 也指出了在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;fn_params_excessive_bools&quot;&gt;函数参数&lt;&#x2F;a&gt;以及&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;struct_excessive_bools&quot;&gt;结构体&lt;&#x2F;a&gt;中使用多个&lt;code&gt;bool&lt;&#x2F;code&gt;类型的问题。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item3-transform.html&quot;&gt;第 3 条&lt;&#x2F;a&gt;包括了一些&lt;code&gt;Option&lt;&#x2F;code&gt;及&lt;code&gt;Result&lt;&#x2F;code&gt;类型的操作。Clippy 指出了一些可行的精简行为，比如：
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;ok_expect&quot;&gt;Unnecessarily converting &lt;code&gt;Result&lt;&#x2F;code&gt; to &lt;code&gt;Option&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;unwrap_or_else_default&quot;&gt;Opportunities to use &lt;code&gt;unwrap_or_default&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item3-transform.html&quot;&gt;第 3 条&lt;&#x2F;a&gt;同样建议了应当将错误返回给调用方。Clippy [指出了应当返回的地方]。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;from_over_into&quot;&gt;第 5 条&lt;&#x2F;a&gt;应当实现&lt;code&gt;From&lt;&#x2F;code&gt;特征而非&lt;code&gt;Into&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item5-casts.html&quot;&gt;第 5 条&lt;&#x2F;a&gt;还描述了一些强制转换，而 Clippy 给出了如下的警告（对应的检查项默认是关掉的）：
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;cast_lossless&quot;&gt;&lt;code&gt;as&lt;&#x2F;code&gt; casts that could be from instead&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;cast_possible_truncation&quot;&gt;&lt;code&gt;as&lt;&#x2F;code&gt; casts that might truncate&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;cast_possible_wrap&quot;&gt;&lt;code&gt;as&lt;&#x2F;code&gt; casts that might wrap&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;cast_precision_loss&quot;&gt;&lt;code&gt;as&lt;&#x2F;code&gt; casts that lose precision&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;cast_sign_loss&quot;&gt;&lt;code&gt;as&lt;&#x2F;code&gt; casts that might convert signed negative numbers to large positive numbers&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;as_conversions&quot;&gt;any use of &lt;code&gt;as&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item8-references&amp;amp;pointer.html&quot;&gt;第 8 条&lt;&#x2F;a&gt;描述了胖指针类型，并且很多 Clippy 的校验器指出了一些非必要的额外的指针间接访问：
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;box_collection&quot;&gt;Holding a heap-allocated collection in a &lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;vec_box&quot;&gt;Holding a heap-allocated collection of &lt;code&gt;Box&lt;&#x2F;code&gt; items&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;borrowed_box&quot;&gt;Taking a reference to a &lt;code&gt;Box&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item9-iterators.html&quot;&gt;第 9 条&lt;&#x2F;a&gt;描述了操作&lt;code&gt;Iterator&lt;&#x2F;code&gt;实例的诸多方法。Clippy 包含了诸多的可以简化迭代器方法使用的校验器&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_2&#x2F;item10-std-traits.html&quot;&gt;第 10 条&lt;&#x2F;a&gt;描述了 Rust 的标准特性，并且包含了很多 Clippy 会校验到的实现时的要求：
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;derive_ord_xor_partial_ord&quot;&gt;&lt;code&gt;Ord&lt;&#x2F;code&gt; must agree with &lt;code&gt;PartialOrd&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;partialeq_ne_impl&quot;&gt;&lt;code&gt;PartialEq::ne&lt;&#x2F;code&gt; should not need a nondefault implementation&lt;&#x2F;a&gt;（参照 &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_2&#x2F;item13-use-default-impl.html&quot;&gt;第 13 条&lt;&#x2F;a&gt;）。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;derived_hash_with_manual_eq&quot;&gt;&lt;code&gt;Hash&lt;&#x2F;code&gt; and &lt;code&gt;Eq&lt;&#x2F;code&gt; must be consistent&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;expl_impl_clone_on_copy&quot;&gt;&lt;code&gt;Clone&lt;&#x2F;code&gt; for &lt;code&gt;Copy&lt;&#x2F;code&gt; types should match&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_3&#x2F;item18-panic.html&quot;&gt;第 18 条&lt;&#x2F;a&gt;提供了一些关于减少&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;panic&quot;&gt;&lt;code&gt;panic!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;或类似&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;expect_used&quot;&gt;&lt;code&gt;expect&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;的方法，这些建议也会在 Clippy 的校验器中检查到。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;semver.html&quot;&gt;第 21 条&lt;&#x2F;a&gt;表述了引入通过通配符限定的包是不明智的。Clippy 同样对此&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;wildcard_dependencies&quot;&gt;进行了校验&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_4&#x2F;item23-wildcard.html&quot;&gt;第 23 条&lt;&#x2F;a&gt;及&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;dep-graph.html&quot;&gt;第 25 条&lt;&#x2F;a&gt;涉及到一种不同版本的包出现在同一个项目的依赖中。Clippy 可以通过配置，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;multiple_crate_versions&quot;&gt;在问题出现时给出警告信息&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;features.html&quot;&gt;第 26 条&lt;&#x2F;a&gt;叙述了 Cargo 特性的一些相加性，而 Clippy 会将与此原则相违背特性提示为&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;negative_feature_names&quot;&gt;“否定”的特性&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;features.html&quot;&gt;第 26 条&lt;&#x2F;a&gt;同样表述了一个包的可选依赖项同样是其特征集的一部分。如果存在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;redundant_feature_names&quot;&gt;需要明确的特性名（如：&quot;use-crate-x&quot;形式的命名）&lt;&#x2F;a&gt;时，Clippy 将会提示直接应当使用明确的特性名，而非模糊的。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_5&#x2F;item27-document-public-interfaces.html&quot;&gt;第 27 条&lt;&#x2F;a&gt;描述了文档注释的约束，Clippy 同时有如下的提示：
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;missing_panics_doc&quot;&gt;Missing descriptions of &lt;code&gt;panic!&lt;&#x2F;code&gt;s&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;missing_safety_doc&quot;&gt;Missing descriptions&lt;&#x2F;a&gt; of &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;undocumented_unsafe_blocks&quot;&gt;&lt;code&gt;unsafe&lt;&#x2F;code&gt; concerns&lt;&#x2F;a&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;上述的信息无疑说明了&lt;strong&gt;阅读 &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html&quot;&gt;Clippy 的警告信息&lt;&#x2F;a&gt;列表&lt;&#x2F;strong&gt;同样是一种有意义的学习方式 —— 包括那些默认被关掉校验的原因，是由于它们太严苛了还是由于它们会产生虚警？尽管你可能并不希望代码中出现这么多的警告信息，领悟这些校验规则出现的原因将会提升你对 Rust 及其风格的理解。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhu-shi&quot;&gt;注释&lt;&#x2F;h3&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;部分校验器列举如下。&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;explicit_counter_loop&quot;&gt;explicit_counter_loop&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;explicit_iter_loop&quot;&gt;explicit_iter_loop&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;explicit_into_iter_loop&quot;&gt;explicit_into_iter_loop&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;filter_map_identity&quot;&gt;filter_map_identity&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;from_iter_instead_of_collect&quot;&gt;from_iter_instead_of_collect&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;into_iter_on_ref&quot;&gt;into_iter_on_ref&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;iter_count&quot;&gt;iter_count&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;iter_next_loop&quot;&gt;iter_next_loop&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;iter_not_returning_iterator&quot;&gt;iter_not_returning_iterator&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;manual_filter_map&quot;&gt;manual_filter_map&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;manual_find_map&quot;&gt;manual_find_map&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;map_clone&quot;&gt;map_clone&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;needless_range_loop&quot;&gt;needless_range_loop&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;search_is_some&quot;&gt;search_is_some&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;skip_while_next&quot;&gt;skip_while_next&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;suspicious_map&quot;&gt;suspicious_map&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;unnecessary_filter_map&quot;&gt;unnecessary_filter_map&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rust-lang.github.io&#x2F;rust-clippy&#x2F;stable&#x2F;index.html#&#x2F;unnecessary_fold&quot;&gt;unnecessary_fold&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;原文&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;clippy.html&quot;&gt;点这里&lt;&#x2F;a&gt;查看&lt;&#x2F;p&gt;
&lt;!-- 参考链接 --&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>【译文&#x2F;effective-rust】第 28 条：在合适的时候使用宏</title>
        <published>2024-07-29T14:59:31+08:00</published>
        <updated>2024-07-29T14:59:31+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/use-macros-judiciously/"/>
        <id>https://liyan-ah.github.io/use-macros-judiciously/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/use-macros-judiciously/">&lt;blockquote&gt;
&lt;p&gt;原文由笔者翻译并提交至 [rustx-labs&#x2F;effective-rust-cn&#x2F;item28]，同步转载到此处。最近一直在搞翻译了，从中看到了很多自己的不足。比如本文关于宏的内容，实际上还有很多没有弄明白的。过了这段时间再看看是否能整理下。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“在一些场景下，我们会很容易来决定应该使用宏（macro）而非函数（function），因为只有宏才能满足我们的需求。” - Paul Graham，“&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.paulgraham.com&#x2F;onlisp.html&quot;&gt;On Lisp (Prentice Hall)&lt;&#x2F;a&gt;”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Rust 的宏能够让你实现元编程（metaprogramming）：在项目中使用代码来生成代码。这一特性在需要编写很多确定性、重复性都很强的“样板代码”时会很有用，不借助宏的话我们就只能手动维护这些代码了。&lt;&#x2F;p&gt;
&lt;p&gt;程序员接触 Rust 之前可能已经预先了解了 C&#x2F;C++ 中通过预处理（preprocessor）来实现的宏，这种方式是在预处理阶段通过文本替换来展开宏定义。而 Rust 的宏则有一些不同，它是在符号流（parsed tokens of the program）或者在抽象语法树（abstract syntax tree, AST）的基础上实现的宏，而非在文本处理阶段。&lt;&#x2F;p&gt;
&lt;p&gt;这就意味着 Rust 的宏是能够理解代码结构并且规避掉一系列的文本替换方式实现的宏所存在的意外情况。比如说，在接下来的内容中，我们可以看到 Rust 所声明的宏是&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hygienic_macro&quot;&gt;卫生的&lt;&#x2F;a&gt; —— 在宏里不会意外引用（或者捕获）宏所嵌入代码中的变量信息。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;c&quot;&gt;&#x2F;* 这段内容较为晦涩。引用一段维基百科上的内容来说明文本替换方式实现的宏所带来的问题。*&#x2F;
#define INCI(i) { int a=0; ++i; }
int main(void)
{
  int a = 4, b = 8;
  INCI(a);
  INCI(b);
  printf(&amp;quot;a is now %d, b is now %d\n&amp;quot;, a, b);
  return 0;
}

&#x2F;* 以上代码中的 INCI 宏期望分别对 a, b 进行加一操作。文本替换后的结果如下所示。*&#x2F;

int main(void)
{
    int a = 4, b = 8;
    { int a = 0; ++a; }; &#x2F;&#x2F; 注意这里对 a 进行了重新声明，实际上是对声明的这个 a 进行了自增。
    { int a = 0; ++b; }; 
    printf(&amp;quot;a is now %d, b is now %d\n&amp;quot;, a, b);
    return 0;
}

&#x2F;* 最终的结果会输出如下。 
 *
 * a is now 4, b is now 9
 *
 * 这显然是不符合预期的。产生这一结果的原因是由于文本替换过于粗暴，而无法进行实际语意上的理解。
 *
 * 本注释内容为译者添加。
 *&#x2F;

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;一种理解宏的方法是将其视为代码的不同抽象方式。函数也是代码的一种简单抽象：它将同一类型的不同值的不同抽象出来，实现了针对这一类型，而非特定的值，会做的操作及方法。而宏中的生成则是另外一个层面的抽象：宏是对符合同一特性的不同类型进行抽象，使用针对这些不同类型所具备的相同特性，而非特性的类型，进行代码的实现。&lt;&#x2F;p&gt;
&lt;p&gt;宏可以对不同程序中扮演相同角色（类型、标记、表达式等）的代码抽象出来，然后这些程序就可以以同一种方式来使用抽象出的逻辑。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 提供了两种方式来定义宏：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;声明宏，也被成为“示例宏”。声明宏允许将输入到宏中任意的 Rust 程序，基于抽象语法树中的结果，集成到代码中。&lt;&#x2F;li&gt;
&lt;li&gt;过程宏。过程宏同样可以将任意的 Rust 程序集成到代码中，不过是基于源码中的解析符号。&lt;code&gt;derive&lt;&#x2F;code&gt;宏就是常见的过程宏。&lt;code&gt;derive&lt;&#x2F;code&gt;宏可以基于代码的结构定义来展开代码。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;sheng-ming-hong&quot;&gt;声明宏&lt;&#x2F;h2&gt;
&lt;p&gt;虽然这篇文章不是为了重复&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;macros-by-example.html&quot;&gt;声明宏&lt;&#x2F;a&gt;的内容，但还是有必要来提醒下声明宏中需要关注的内容。&lt;&#x2F;p&gt;
&lt;p&gt;首先，需要注意的是声明宏的作用域范围和直觉上的理解的是不同的（对比 C 里的预处理宏）。如果一个声明宏在源代码中被定义了，就只有&lt;em&gt;跟在&lt;&#x2F;em&gt;宏里的代码能够使用：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;fn before() {
    println!(&amp;quot;[before] square {} is {}&amp;quot;, 2, square!(2));
}

&#x2F;&#x2F;&#x2F; Macro that squares its argument.
macro_rules! square {
    { $e:expr } =&amp;gt; { $e * $e }
}

fn after() {
    println!(&amp;quot;[after] square {} is {}&amp;quot;, 2, square!(2));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;error: cannot find macro `square` in this scope
 --&amp;gt; src&#x2F;main.rs:4:45
  |
4 |     println!(&amp;quot;[before] square {} is {}&amp;quot;, 2, square!(2));
  |                                             ^^^^^^
  |
  = help: have you added the `#[macro_use]` on the module&#x2F;import?

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;#[macro_export]&lt;&#x2F;code&gt;特性让宏可以访问更多的数据，但是也存在一些奇怪的事情：尽管宏并没有在模块中定义，它还是出现在了模块的顶层。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;mod submod {
    #[macro_export]
    macro_rules! cube {
        { $e:expr } =&amp;gt; { $e * $e * $e }
    }
}

mod user {
    pub fn use_macro() {
        &#x2F;&#x2F; Note: *not* `crate::submod::cube!`
        let cubed = crate::cube!(3);
        println!(&amp;quot;cube {} is {}&amp;quot;, 3, cubed);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Rust 的声明宏是卫生（hygienic）的：宏内部展开的代码无法使用所在作用域的局部变量。比如，宏内部使用了局部变量 x 时：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F; Create a macro that assumes the existence of a local `x`.
macro_rules! increment_x {
    {} =&amp;gt; { x += 1; };
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样的用法将会造成编译错误：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let mut x = 2;
increment_x!();
println!(&amp;quot;x = {}&amp;quot;, x);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;error[E0425]: cannot find value `x` in this scope
   --&amp;gt; src&#x2F;main.rs:55:13
    |
55  |     {} =&amp;gt; { x += 1; };
    |             ^ not found in this scope
...
314 |     increment_x!();
    |     -------------- in this macro invocation
    |
    = note: this error originates in the macro `increment_x`
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这种“卫生”的特性意味着 Rust 的宏比 C 的基于预处理替换的宏要安全很多。然而，仍有一些需要在使用时注意的内容。&lt;&#x2F;p&gt;
&lt;p&gt;第一，尽管一个宏&lt;em&gt;看起来&lt;&#x2F;em&gt;很像是函数的声明，它并不是。宏将会在调用的地方进行代码展开，而且可以随着传入参数的不同进行不同形式的展开：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;macro_rules! inc_item {
    { $x:ident } =&amp;gt; { $x.contents += 1; }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这就意味着常规意义上的参数被移动（moved）或者 &amp;amp; （被引用）的情形没有发生：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let mut x = Item { contents: 42 }; &#x2F;&#x2F; type is not `Copy`

&#x2F;&#x2F; Item is *not* moved, despite the (x) syntax,
&#x2F;&#x2F; but the body of the macro *can* modify `x`.
inc_item!(x);

println!(&amp;quot;x is {x:?}&amp;quot;);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;x is Item { contents: 43 }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果我们还记得宏只是在调用它的地方进行展开的话，上述示例就会变得清楚了 —— 在这个示例中，调用宏的地方只相当于添加了一行增加&lt;code&gt;x.contents&lt;&#x2F;code&gt;值的代码。借助&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;dtolnay&#x2F;cargo-expand&quot;&gt;cargo-expand&lt;&#x2F;a&gt;可以很清晰地看到编译器将宏进行展开后的代码：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let mut x = Item { contents: 42 };
x.contents += 1;
{
    ::std::io::_print(format_args!(&amp;quot;x is {0:?}\n&amp;quot;, x));
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;展开的代码中可以看到直接使用了变量本身，而非其引用。（一个有意思的事情是，我们可以看到&lt;code&gt;println!&lt;&#x2F;code&gt;的展开中，依赖了&lt;code&gt;format_args!&lt;&#x2F;code&gt;宏&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。）&lt;&#x2F;p&gt;
&lt;p&gt;所以，宏里的&lt;code&gt;!&lt;&#x2F;code&gt;起到了一个警示的作用：展开的代码可能会对参数做一些任性的事情。&lt;&#x2F;p&gt;
&lt;p&gt;展开的代码也可能会包含一些在调用代码中无法访问的控制流，可能包括循环、判断、返回值甚至使用&lt;code&gt;?&lt;&#x2F;code&gt;操作符。显然，这里会和[最小惊讶原则]相冲突，所以在使用宏时，应当考虑封装常规的 Rust 语句。（另一方面，如果使用宏的&lt;em&gt;目的&lt;&#x2F;em&gt;是实现一些奇怪的控制流，请确保这些控制流在文档中都给用户提供了！）&lt;&#x2F;p&gt;
&lt;p&gt;举例来说，考虑这样一个宏（用来校验 HTTP 状态码）包含了一个&lt;code&gt;return&lt;&#x2F;code&gt;语句：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Check that an HTTP status is successful; exit function if not.
macro_rules! check_successful {
    { $e:expr } =&amp;gt; {
        if $e.group() != Group::Successful {
            return Err(MyError(&amp;quot;HTTP operation failed&amp;quot;));
        }
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用这段宏来校验一些 HTTP 行为的代码可能会以一些很晦涩的控制流来结束：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let rc = perform_http_operation();
check_successful!(rc); &#x2F;&#x2F; may silently exit the function

&#x2F;&#x2F; ...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;另一种可以实现上述功能的宏是产生一个&lt;code&gt;Result&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Convert an HTTP status into a `Result&amp;lt;(), MyError&amp;gt;` indicating success.
macro_rules! check_success {
    { $e:expr } =&amp;gt; {
        match $e.group() {
            Group::Successful =&amp;gt; Ok(()),
            _ =&amp;gt; Err(MyError(&amp;quot;HTTP operation failed&amp;quot;)),
        }
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;而这样依赖，代码就很好理解了：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let rc = perform_http_operation();
check_success!(rc)?; &#x2F;&#x2F; error flow is visible via `?`

&#x2F;&#x2F; ...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于声明宏来说，第二件需要注意的事情是和 C 的预编译宏同样的问题：如果宏的参数是一个存在副作用的表达式，当心在宏里多次使用的情况。比如我们在早先定义的&lt;code&gt;square!&lt;&#x2F;code&gt;宏输入了较为随意的表达式来作为参数，然后使用两次，这将会造成奇怪的结果：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let mut x = 1;
let y = square!({
    x += 1;
    x
});
println!(&amp;quot;x = {x}, y = {y}&amp;quot;);
&#x2F;&#x2F; output: x = 3, y = 6
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;假设这种行为并非有意的，一种修复的方法是尝试仅执行给定的表达式一次，然后将结果赋值给一个本地的变量：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;macro_rules! square_once {
    { $e:expr } =&amp;gt; {
        {
            let x = $e;
            x*x &#x2F;&#x2F; Note: there&amp;#39;s a detail here to be explained later...
        }
    }
}
&#x2F;&#x2F; output now: x = 2, y = 4
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;另一种可选的方案是不允许将表达式作为宏的输入。如果将[expr]替换为&lt;code&gt;indent&lt;&#x2F;code&gt;，那么这个宏就仅会接受标志符作为入参，而使用类似任意的表达式将不再能编译通过。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ge-shi-hua-can-shu&quot;&gt;格式化参数&lt;&#x2F;h2&gt;
&lt;p&gt;声明宏的一种常见的使用模式将多个值汇聚成一个消息。比如，标准库中的&lt;code&gt;format!&lt;&#x2F;code&gt;用来拼接一个字符串，&lt;code&gt;println!&lt;&#x2F;code&gt;用来输出到标准输出，&lt;code&gt;eprintln!&lt;&#x2F;code&gt;用来输出到标准错误输出。&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;fmt&#x2F;index.html&quot;&gt;fmt 文档&lt;&#x2F;a&gt;中阐述了&lt;code&gt;format!&lt;&#x2F;code&gt;的语法，和&lt;code&gt;C&lt;&#x2F;code&gt;中的&lt;code&gt;printf&lt;&#x2F;code&gt;使用几乎是相同的。当然，Rust 中的&lt;code&gt;format!&lt;&#x2F;code&gt;参数是类型安全并且会在编译时进行检查的，并且&lt;code&gt;format!&lt;&#x2F;code&gt;宏实现时使用了&lt;code&gt;Display&lt;&#x2F;code&gt;以及&lt;code&gt;Debug&lt;&#x2F;code&gt;特性用来约束宏的参数。&lt;code&gt;Display&lt;&#x2F;code&gt;以及&lt;code&gt;Debug&lt;&#x2F;code&gt;宏的使用参见&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_2&#x2F;item10-std-traits.html&quot;&gt;第 10 条&lt;&#x2F;a&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;你可以（同时也建议）在项目中的宏中使用相同的格式化语法。比如，一个&lt;code&gt;log&lt;&#x2F;code&gt;库中的&lt;code&gt;logging&lt;&#x2F;code&gt;宏就可以使用和&lt;code&gt;format!&lt;&#x2F;code&gt;相同的语法。在实践中，使用&lt;code&gt;format_args!&lt;&#x2F;code&gt;来实现参数的格式化而不是重复造轮子。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Log an error including code location, with `format!`-like arguments.
&#x2F;&#x2F;&#x2F; Real code would probably use the `log` crate.
macro_rules! my_log {
    { $($arg:tt)+ } =&amp;gt; {
        eprintln!(&amp;quot;{}:{}: {}&amp;quot;, file!(), line!(), format_args!($($arg)+));
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let x = 10u8;
&#x2F;&#x2F; Format specifiers:
&#x2F;&#x2F; - `x` says print as hex
&#x2F;&#x2F; - `#` says prefix with &amp;#39;0x&amp;#39;
&#x2F;&#x2F; - `04` says add leading zeroes so width is at least 4
&#x2F;&#x2F;   (this includes the &amp;#39;0x&amp;#39; prefix).
my_log!(&amp;quot;x = {:#04x}&amp;quot;, x);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;src&#x2F;main.rs:331: x = 0x0a
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;guo-cheng-hong&quot;&gt;过程宏&lt;&#x2F;h2&gt;
&lt;p&gt;Rust 也支持了&lt;em&gt;过程宏&lt;&#x2F;em&gt;，也被称为&lt;code&gt;proc macros&lt;&#x2F;code&gt;。和声明宏类似，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;procedural-macros.html&quot;&gt;过程宏&lt;&#x2F;a&gt;能够任意的 Rust 代码插入到程序的源代码中。不同的时，过程宏的输入不再仅限制在特定的传入参数。过程宏可以访问一些源代码中的解析符号（parsed tokens）。这就过程宏一定程度上类似动态语言，比如 Lisp，的非常富有表达力的能力 —— 但是仍然在编译时进行检查。这也帮助缓解了 Rust 中反射的局限，这在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;reflection.html&quot;&gt;第 19 条&lt;&#x2F;a&gt;中讨论了。&lt;&#x2F;p&gt;
&lt;p&gt;过程宏需要和其被使用的代码定义在不同的包中（并且包需要被声明为&lt;code&gt;proc_macro&lt;&#x2F;code&gt;），并且包中往往需要引入[proc-macro]（官方工具链中提供）或者[proc-macro2]（由 David Tolnay 提供）的依赖，这两个依赖可以宏能够操作输入的符号。&lt;&#x2F;p&gt;
&lt;p&gt;实际上，有三种不同的过程宏：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;类函数宏（Function-like macros）：通过传入的参数调用。&lt;&#x2F;li&gt;
&lt;li&gt;类属性宏（Attribute macros）：附加到程序中的某些特定语法的代码中。&lt;&#x2F;li&gt;
&lt;li&gt;派生宏（Derive macros）：附加到特定的数据结构中。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;lei-han-shu-hong&quot;&gt;类函数宏&lt;&#x2F;h3&gt;
&lt;p&gt;函数式的宏会通过传递参数来调用，宏的实现中可以访问参数的解析符号（parsed tokens），并且返回任意的符号。注意在先前的表述中，我们使用的是单数的参数， —— 即使函数式的宏调用的时候看起来传入了很多参数：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;my_func_macro!(15, x + y, f32::consts::PI);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但是宏本身只接收到了一个解析后的符号流。一个将符号流输出（在编译时）的宏实现示例如下：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;use proc_macro::TokenStream;

&#x2F;&#x2F; Function-like macro that just prints (at compile time) its input stream.
#[proc_macro]
pub fn my_func_macro(args: TokenStream) -&amp;gt; TokenStream {
    println!(&amp;quot;Input TokenStream is:&amp;quot;);
    for tt in args {
        println!(&amp;quot;  {tt:?}&amp;quot;);
    }
    &#x2F;&#x2F; Return an empty token stream to replace the macro invocation with.
    TokenStream::new()
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其运行结果如下：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;Input TokenStream is:
  Literal { kind: Integer, symbol: &amp;quot;15&amp;quot;, suffix: None,
            span: #0 bytes(10976..10978) }
  Punct { ch: &amp;#39;,&amp;#39;, spacing: Alone, span: #0 bytes(10978..10979) }
  Ident { ident: &amp;quot;x&amp;quot;, span: #0 bytes(10980..10981) }
  Punct { ch: &amp;#39;+&amp;#39;, spacing: Alone, span: #0 bytes(10982..10983) }
  Ident { ident: &amp;quot;y&amp;quot;, span: #0 bytes(10984..10985) }
  Punct { ch: &amp;#39;,&amp;#39;, spacing: Alone, span: #0 bytes(10985..10986) }
  Ident { ident: &amp;quot;f32&amp;quot;, span: #0 bytes(10987..10990) }
  Punct { ch: &amp;#39;:&amp;#39;, spacing: Joint, span: #0 bytes(10990..10991) }
  Punct { ch: &amp;#39;:&amp;#39;, spacing: Alone, span: #0 bytes(10991..10992) }
  Ident { ident: &amp;quot;consts&amp;quot;, span: #0 bytes(10992..10998) }
  Punct { ch: &amp;#39;:&amp;#39;, spacing: Joint, span: #0 bytes(10998..10999) }
  Punct { ch: &amp;#39;:&amp;#39;, spacing: Alone, span: #0 bytes(10999..11000) }
  Ident { ident: &amp;quot;PI&amp;quot;, span: #0 bytes(11000..11002) }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于输入流涉及到的底层特性式的这段宏在实现时必须要能够解析所传入的参数。比如，宏中分隔那些需要分隔的参数需要使用&lt;code&gt;TokenTree:Punct&lt;&#x2F;code&gt;。&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;syn&#x2F;latest&#x2F;syn&#x2F;&quot;&gt;syn 包&lt;&#x2F;a&gt;（David Tolnay开发）提供了一个解析的库来辅助这些事情，下一节会进行介绍。&lt;&#x2F;p&gt;
&lt;p&gt;正因为这些解析的工作，使用声明宏往往比函数式的过程宏要简单，因为声明宏所处理的是匹配所定义的结构。&lt;&#x2F;p&gt;
&lt;p&gt;这种需要手动处理繁杂的另一面是函数是的宏可以更加灵活的接受那些无法像一般 Rust 代码解析的输入。这种特性并非经常需要的，所以函数式的宏相对较少出现。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lei-shu-xing-hong&quot;&gt;类属性宏&lt;&#x2F;h3&gt;
&lt;p&gt;类属性宏通过将其放置在程序的一些片段前调用的，而这些片段的解析符号会被传入到宏的内部进行处理。类属性宏也可以将任意的结果作为返回值，但是一般返回值是对输出的一些转换处理。&lt;&#x2F;p&gt;
&lt;p&gt;比如，下面是一个用来封装函数体的类属性宏：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;#[log_invocation]
fn add_three(x: u32) -&amp;gt; u32 {
    x + 3
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;之后，在调用这个被封装的函数时，就会有日志输出：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;let x = 2;
let y = add_three(x);
println!(&amp;quot;add_three({x}) = {y}&amp;quot;);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;log: calling function &amp;#39;add_three&amp;#39;
log: called function &amp;#39;add_three&amp;#39; =&amp;gt; 5
add_three(2) = 5
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个宏的实现是极为复杂的，这里并不打算将其细节附上。在实现时，需要校验输入符号的结构以便构建新的输出符号。当然，这一过程仍然可以使用&lt;code&gt;syn&lt;&#x2F;code&gt;包来辅助实现。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pai-sheng-hong&quot;&gt;派生宏&lt;&#x2F;h3&gt;
&lt;p&gt;最后一种过程宏是派生宏。派生宏可以为其修饰的数据（struct, enum 或者 union 均可）自动地生成代码。这一点和类属性宏有些像，但是会多一些派生的操作 —— 请注意理解这里的派生概念。&lt;&#x2F;p&gt;
&lt;p&gt;首先，派生宏会附加到输入的符号中，而非将其替换。这就意味着原始的数据结构的定义会被保留，而派生宏将在原始数据结构的基础上附加代码。&lt;&#x2F;p&gt;
&lt;p&gt;其次，派生宏可以用来声明一些辅助性的特征。当数据需要用作一些特殊的处理时，可以使用派生宏来辅助标注。比如，[serde 库]的&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;serde&#x2F;latest&#x2F;serde&#x2F;derive.Deserialize.html&quot;&gt;Deserialize&lt;&#x2F;a&gt;派生宏有一个&lt;code&gt;serde&lt;&#x2F;code&gt;的辅助特性，用户可以使用派生宏来声明这些结构体符合某种特性：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;fn generate_value() -&amp;gt; String {
    &amp;quot;unknown&amp;quot;.to_string()
}

#[derive(Debug, Deserialize)]
struct MyData {
    &#x2F;&#x2F; If `value` is missing when deserializing, invoke
    &#x2F;&#x2F; `generate_value()` to populate the field instead.
    #[serde(default = &amp;quot;generate_value&amp;quot;)]
    value: String,
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;关于派生宏的最后一个概念是，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;syn&#x2F;latest&#x2F;syn&#x2F;&quot;&gt;syn 包&lt;&#x2F;a&gt;可以完成将输入符号解析到相应的语法树的工作。&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;syn&#x2F;latest&#x2F;syn&#x2F;macro.parse_macro_input.html&quot;&gt;syn::parse_macro_input!&lt;&#x2F;a&gt;宏可以将符号转换成&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;syn&#x2F;latest&#x2F;syn&#x2F;struct.DeriveInput.html&quot;&gt;syn::DeriveInput&lt;&#x2F;a&gt;数据结构，这种结构描述被修饰对象的主要内容，并且&lt;code&gt;DeriveInput&lt;&#x2F;code&gt;操作起来远比原始的符号流要好处理。&lt;&#x2F;p&gt;
&lt;p&gt;特别地，&lt;code&gt;derive&lt;&#x2F;code&gt;宏是所有过程宏中最常使用的宏 —— 这种逐字段或逐变量操作的能力能够让程序员最简单地实现最多的功能 —— 比如，仅通过添加一行类似&lt;code&gt;#[derive(Debug, Clone, PartialEq, Eq)]&lt;&#x2F;code&gt;的代码，即可实现预期的目的。&lt;&#x2F;p&gt;
&lt;p&gt;由于派生宏的代码插入是自动实现地，这也意味着这些插入的代码可以同时和结构体的实现保持一致。比如，如果你向&lt;code&gt;struct&lt;&#x2F;code&gt;中插入了一个新的字段，如果采用手动实现&lt;code&gt;Debug&lt;&#x2F;code&gt;特征的话，你就需要在插入后对结构体进行更新以使其满足特征的需求。而对于自动插入代码的派生宏来说，你并不需要做任何调整（当然了，如果插入的字段不满足派生宏的实现要求，编译时会报错）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shen-me-shi-hou-shi-yong-hong&quot;&gt;什么时候使用宏&lt;&#x2F;h2&gt;
&lt;p&gt;使用宏的首要原因当然是避免重复的代码 —— 尤其是那些需要人工确保和其他代码关联正确性的重复代码。从这一点来说，使用宏仅是编程常用的封装抽象的扩展：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;如果需要重复一段处理同一类型的不同值的代码，将其封装为一个函数并在所有需要这段逻辑的地方使用它。&lt;&#x2F;li&gt;
&lt;li&gt;如果需要重复一段处理不同类型的代码，构建一个&lt;code&gt;trait&lt;&#x2F;code&gt;并且使用该&lt;code&gt;trait&lt;&#x2F;code&gt;来封装逻辑并在所有满足该特性的要求的地方进行使用。&lt;&#x2F;li&gt;
&lt;li&gt;如果需要重复一段结构相同的代码，将其封装成一个宏并且在所有满足类似结构的代码中进行使用。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;举例如下：如果希望规避重复处理不同&lt;code&gt;enum&lt;&#x2F;code&gt;的代码，使用宏即可：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;enum Multi {
    Byte(u8),
    Int(i32),
    Str(String),
}

&#x2F;&#x2F;&#x2F; Extract copies of all the values of a specific enum variant.
#[macro_export]
macro_rules! values_of_type {
    { $values:expr, $variant:ident } =&amp;gt; {
        {
            let mut result = Vec::new();
            for val in $values {
                if let Multi::$variant(v) = val {
                    result.push(v.clone());
                }
            }
            result
        }
    }
}

fn main() {
    let values = vec![
        Multi::Byte(1),
        Multi::Int(1000),
        Multi::Str(&amp;quot;a string&amp;quot;.to_string()),
        Multi::Byte(2),
    ];

    let ints = values_of_type!(&amp;amp;values, Int);
    println!(&amp;quot;Integer values: {ints:?}&amp;quot;);

    let bytes = values_of_type!(&amp;amp;values, Byte);
    println!(&amp;quot;Byte values: {bytes:?}&amp;quot;);

    &#x2F;&#x2F; Output:
    &#x2F;&#x2F;   Integer values: [1000]
    &#x2F;&#x2F;   Byte values: [1, 2]
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;另一个宏的使用场景是，规避同一结构体中的数据被分散在代码的不同区域。&lt;&#x2F;p&gt;
&lt;p&gt;比如，假设一个结构体封装了 HTTP 的状态码。通过宏可以避免实现这些信息时代码的分散：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F; http.rs module

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum Group {
    Informational, &#x2F;&#x2F; 1xx
    Successful,    &#x2F;&#x2F; 2xx
    Redirection,   &#x2F;&#x2F; 3xx
    ClientError,   &#x2F;&#x2F; 4xx
    ServerError,   &#x2F;&#x2F; 5xx
}

&#x2F;&#x2F; Information about HTTP response codes.
http_codes! {
    Continue           =&amp;gt; (100, Informational, &amp;quot;Continue&amp;quot;),
    SwitchingProtocols =&amp;gt; (101, Informational, &amp;quot;Switching Protocols&amp;quot;),
    &#x2F;&#x2F; ...
    Ok                 =&amp;gt; (200, Successful, &amp;quot;Ok&amp;quot;),
    Created            =&amp;gt; (201, Successful, &amp;quot;Created&amp;quot;),
    &#x2F;&#x2F; ...
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过使用宏，可以将每个 HTTP 状态码的所有相关联的信息 —— 数值、元组以及描述信息 —— 都聚集起来，看起来就像是使用一种领域特定语言（domain-specifix language, DSL）来保存数据一样。&lt;&#x2F;p&gt;
&lt;p&gt;汇聚之后，宏就可以生成代码。每一行类似&lt;code&gt;$( ... )+&lt;&#x2F;code&gt;中的代码都会被扩展成特定的代码：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;macro_rules! http_codes {
    { $( $name:ident =&amp;gt; ($val:literal, $group:ident, $text:literal), )+ } =&amp;gt; {
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
        #[repr(i32)]
        enum Status {
            $( $name = $val, )+
        }
        impl Status {
            fn group(&amp;amp;self) -&amp;gt; Group {
                match self {
                    $( Self::$name =&amp;gt; Group::$group, )+
                }
            }
            fn text(&amp;amp;self) -&amp;gt; &amp;amp;&amp;#39;static str {
                match self {
                    $( Self::$name =&amp;gt; $text, )+
                }
            }
        }
        impl core::convert::TryFrom&amp;lt;i32&amp;gt; for Status {
            type Error = ();
            fn try_from(v: i32) -&amp;gt; Result&amp;lt;Self, Self::Error&amp;gt; {
                match v {
                    $( $val =&amp;gt; Ok(Self::$name), )+
                    _ =&amp;gt; Err(())
                }
            }
        }
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样处理后，宏就可以依据输入的参数来派生如下的代码：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个&lt;code&gt;enum&lt;&#x2F;code&gt;枚举用来保存所有的数值。&lt;&#x2F;li&gt;
&lt;li&gt;一个&lt;code&gt;group()&lt;&#x2F;code&gt;方法来返回一个 HTTP 状态码的分组归属。&lt;&#x2F;li&gt;
&lt;li&gt;一个&lt;code&gt;text()&lt;&#x2F;code&gt;方法来将状态码映射到对应的文字描述中。&lt;&#x2F;li&gt;
&lt;li&gt;一个&lt;code&gt;TryFrom&amp;lt;i32&amp;gt;&lt;&#x2F;code&gt;的特征实现来将数值转换成&lt;code&gt;enum&lt;&#x2F;code&gt;中的枚举值。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;如果需要新增一个状态码，只需要添加这样的一行代码：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;ImATeapot =&amp;gt; (418, ClientError, &amp;quot;I&amp;#39;m a teapot&amp;quot;),
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果不使用宏的话，就需要对四部分代码分别更新。编译器可能会有一些提示信息（&lt;code&gt;match&lt;&#x2F;code&gt;表达式需要覆盖所有的场景），但是存在一些遗漏 —— &lt;code&gt;TryFrom&amp;lt;i32&lt;&#x2F;code&gt; 就很容易被遗忘。&lt;&#x2F;p&gt;
&lt;p&gt;由于宏可以在调用的地方对代码进行展开，所有它们也可以用来自动生成一些提示信息 —— 尤其是，在使用了标准库中的&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;macro.file.html&quot;&gt;file!()&lt;&#x2F;a&gt;以及&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;macro.line.html&quot;&gt;line!()&lt;&#x2F;a&gt;宏了之后，可以生成代码的位置信息：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;macro_rules! log_failure {
    { $e:expr } =&amp;gt; {
        {
            let result = $e;
            if let Err(err) = &amp;amp;result {
                eprintln!(&amp;quot;{}:{}: operation &amp;#39;{}&amp;#39; failed: {:?}&amp;quot;,
                          file!(),
                          line!(),
                          stringify!($e),
                          err);
            }
            result
        }
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当报错出现时，日志文件中就会自动地包含报错内容、位置等细节：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;use std::convert::TryInto;

let x: Result&amp;lt;u8, _&amp;gt; = log_failure!(512.try_into()); &#x2F;&#x2F; too big for `u8`
let y = log_failure!(std::str::from_utf8(b&amp;quot;\xc3\x28&amp;quot;)); &#x2F;&#x2F; invalid UTF-8
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;hong-de-que-dian&quot;&gt;宏的缺点&lt;&#x2F;h2&gt;
&lt;p&gt;使用宏的最大缺点是引入之后代码的可读性及可维护性。之前在声明宏小结中介绍了宏允许我们创建一个特定的语言来简明地描述代码及数据的关键特性。但是，这也意味着任何阅读这段代码的人将不得不理解这段使用 Rust 实现的特定的语句 —— 而且这还是使用宏来定义的。比如，在&lt;code&gt;http_codes!&lt;&#x2F;code&gt;宏的示例中使用了一个名为&lt;code&gt;Status&lt;&#x2F;code&gt;的 Rust &lt;code&gt;enum&lt;&#x2F;code&gt;，但是在使用的时候并不能察觉到。&lt;&#x2F;p&gt;
&lt;p&gt;这种使用宏而引入的不可知性远超一般程序员所能带来的影响：很多分析或和 Rust 交互的工具无法理解这样晦涩的代码，因为它不在遵循 Rust 代码交互语法。先前展示的&lt;code&gt;square_once!&lt;&#x2F;code&gt;宏就是一个直观的例子：宏的主体并没有按照&lt;code&gt;rustfmt&lt;&#x2F;code&gt;的规则来格式化：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;{
    let x = $e;
    &#x2F;&#x2F; The `rustfmt` tool doesn&amp;#39;t really cope with code in
    &#x2F;&#x2F; macros, so this has not been reformatted to `x * x`.
    x*x
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;另一个例子是已经提到的&lt;code&gt;http_codes!&lt;&#x2F;code&gt;宏，这里使用了&lt;code&gt;Group&lt;&#x2F;code&gt;枚举了诸如&lt;code&gt;Informational&lt;&#x2F;code&gt;的值，而没有使用&lt;code&gt;Group::&lt;&#x2F;code&gt;前缀或&lt;code&gt;use&lt;&#x2F;code&gt;语句。这一点会让代码的补全工具感到混淆。&lt;&#x2F;p&gt;
&lt;p&gt;甚至编译器本身也无法提供更多的帮助：编译器提供的报错信息没有完全符合宏的定义及使用。当然，还是有一些工具（参照&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;use-tools.html&quot;&gt;第 31 条&lt;&#x2F;a&gt;）可以辅助宏的使用，比如早先使用的 David Tolnay 的 &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;dtolnay&#x2F;cargo-expand&quot;&gt;cargo-expand&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;使用宏也可能会导致代码的膨胀 —— 一个简单的宏调用就可能引入数百行的生成代码，并且在进行代码分析时是无法直观看到的。这在代码第一次编写时可能不会成为问题，因为彼时这些代码是需要的，并且帮助开发者节约了大量的代码编写时间。但是，如果这些代码随后不再需要了，考虑实际生成的数百行代码，仅从数行的宏调用中可能并不能看到将其删除的必要性。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jian-yi&quot;&gt;建议&lt;&#x2F;h2&gt;
&lt;p&gt;尽管上节我们列举了很多宏的缺点，但是当我们需要合并存在一些存在一致性的代码，但是没有其他可用的方式时，使用宏仍然是完成这样工作的正确工具：&lt;em&gt;当宏是确保不同代码保持一致的唯一方式时，使用它！&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;当我们需要合并一些模版化的代码时，宏也是可以使用的工具：&lt;em&gt;使用宏来处理模版代码&lt;&#x2F;em&gt;，当它们无法合并为一个函数或者一个特性时。&lt;&#x2F;p&gt;
&lt;p&gt;为了降低宏对可读性的影响，请尽量避免在宏中使用和 Rust 的一般语法规则相冲突的语法。要么让宏在调用时和一般的代码表现的一致；要么让宏在调用时和一般的代码完全不同，这样就没有用户会混淆宏和一般的代码。特别地，可以遵循如下的准则：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;尽可能的避免向宏传递参数的引用&lt;&#x2F;em&gt; —— 类似&lt;code&gt;my_macro!(list)&lt;&#x2F;code&gt;的使用就比&lt;code&gt;my_macro!(&amp;amp;list)&lt;&#x2F;code&gt;要好。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;em&gt;尽量避免在宏中引入非局部的控制流&lt;&#x2F;em&gt;，这样所有阅读这段代码的人都可以在不了解宏的细节的情况下，正确理解上下文中的控制流。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这种倾向于类似 Rust 一般代码的可读性偏好有时会影响声明宏或者过程式宏的选择。如果你需要给一个&lt;code&gt;struct&lt;&#x2F;code&gt;的每一个字段或者&lt;code&gt;enum&lt;&#x2F;code&gt;中的每一个枚举值都生成代码，&lt;em&gt;尽量使用派生宏来处理&lt;&#x2F;em&gt;（暂时忽略在上一节中列举的问题） —— 这样会更加符合语言习惯并且读起来更加简单。&lt;&#x2F;p&gt;
&lt;p&gt;然而，如果要添加的派生宏并非是项目中所独有的功能，可以检查下外部的库中是否已经提供了所需要的宏（参照&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;dep-graph.html&quot;&gt;第 25 条&lt;&#x2F;a&gt;）。比如，类似将数值类型转换为合适的 C 风格的枚举值的需求：在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;enumn&#x2F;latest&#x2F;enumn&#x2F;derive.N.html&quot;&gt;enumn::N&lt;&#x2F;a&gt;、[num_enum::TryFromPrimitive]、&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;num-derive&#x2F;latest&#x2F;num_derive&#x2F;derive.FromPrimitive.html&quot;&gt;num_derive::FromPrimitive&lt;&#x2F;a&gt;以及&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;strum&#x2F;latest&#x2F;strum&#x2F;derive.FromRepr.html&quot;&gt;strum::FromRepr&lt;&#x2F;a&gt;中都一定程度的实现了这个需求。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;zhu-shi&quot;&gt;注释&lt;&#x2F;h3&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;眼神儿好的读者可能已经注意到了&lt;code&gt;format_arg!&lt;&#x2F;code&gt;仍然像是一个宏的调用，尽管它在&lt;code&gt;println!&lt;&#x2F;code&gt;宏的展开代码里。这是因为它是编译器的内建宏。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;fmt&#x2F;index.html&quot;&gt;std::fmt 模块&lt;&#x2F;a&gt;中也包含了很多其他展示特定格式数据是会使用的特性。比如，当需要一个 x 格式的特殊说明符来输出小写的十六进制输出时，就会使用&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;fmt&#x2F;trait.LowerHex.html&quot;&gt;LowerHex&lt;&#x2F;a&gt;特性。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;原文&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;macros.html&quot;&gt;点这里&lt;&#x2F;a&gt;查看。&lt;&#x2F;p&gt;
&lt;!-- 参考链接 --&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>【译文&#x2F;effective-rust】第 27 条：为公共接口撰写文档</title>
        <published>2024-06-17T15:08:08+08:00</published>
        <updated>2024-06-17T15:08:08+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/document-public-interfaces/"/>
        <id>https://liyan-ah.github.io/document-public-interfaces/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/document-public-interfaces/">&lt;blockquote&gt;
&lt;p&gt;原文由笔者翻译并提交至 &lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_5&#x2F;item27-document-public-interfaces.html&quot;&gt;rustx-labs&#x2F;effective-rust-cn&#x2F;item27&lt;&#x2F;a&gt;，同步转载到此处。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;如果你的包（crate）会被其他程序员所使用，那么为包中的内容添加文档就是很好的实践，尤其是包中的公共接口。如果你的包不仅仅是随用随丢的代码，那么这个“其他程序员”就包括未来的你，那个已经忘掉了自己代码细节的你。&lt;&#x2F;p&gt;
&lt;p&gt;这个建议并不是 Rust 所独有的，它也并不是一个新的建议 —— 比如，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.oreilly.com&#x2F;library&#x2F;view&#x2F;effective-java-2nd&#x2F;9780137150021&#x2F;&quot;&gt;Effective Java&lt;&#x2F;a&gt; 第二版（2008年出版）在第 44 条中建议：“为所有导出的 API 元素编写文档注释”。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 文档类型注释的细节 —— 基于 Markdown 格式，以 &#x2F;&#x2F;&#x2F; 或者 &#x2F;&#x2F;! 分割 —— 已经在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments&quot;&gt;Rust book&lt;&#x2F;a&gt;中介绍了，如下为示例：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;Rust&quot;&gt;&#x2F;&#x2F;&#x2F; Calculate the [`BoundingBox`] that exactly encompasses a pair
&#x2F;&#x2F;&#x2F; of [`BoundingBox`] objects.
pub fn union(a: &amp;amp;BoundingBox, b: &amp;amp;BoundingBox) -&amp;gt; BoundingBox {
    &#x2F;&#x2F; ...
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然而，关于文档型注释的格式仍有一些值得关注的细节：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;使用代码格式：对于任何作为源代码的注释，使用反引号来确保在最终的文档中代码会以一种等宽字体来展示，并以此来明确的区分&lt;code&gt;code&lt;&#x2F;code&gt;以及一般的文本。&lt;&#x2F;li&gt;
&lt;li&gt;添加丰富的引用内容：为任何能够给读者提供上下文信息的内容添加 Markdown 链接。特别地，可以使用比较方便的 [&lt;code&gt;SomeThing&lt;&#x2F;code&gt;] 格式的交叉引用标注符语法 —— 括号内的&lt;code&gt;Something&lt;&#x2F;code&gt;将会在最终文档中被添加正确的超链接。&lt;&#x2F;li&gt;
&lt;li&gt;多添加示例代码：如果接口应该如何使用并非一目了然的，那么添加一个使用该接口的&lt;code&gt;# Example&lt;&#x2F;code&gt;段落将会很有用。如在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rustdoc&#x2F;write-documentation&#x2F;documentation-tests.html&quot;&gt;文档注释&lt;&#x2F;a&gt;里的示例代码会在你执行&lt;code&gt;cargo test&lt;&#x2F;code&gt;（详情查看&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;testing.html&quot;&gt;第 13 条&lt;&#x2F;a&gt;）时编译并且运行，这一特性将有助于示例代码和它希望表述的代码保持一致。&lt;&#x2F;li&gt;
&lt;li&gt;为&lt;code&gt;panic&lt;&#x2F;code&gt;和&lt;code&gt;unsafe&lt;&#x2F;code&gt;的代码添加说明文档：如果存在会导致函数&lt;code&gt;panic&lt;&#x2F;code&gt;的输入，在文档（&lt;code&gt;# Panics&lt;&#x2F;code&gt;段落）里说明规避&lt;code&gt;panic!&lt;&#x2F;code&gt;的前置条件。同样地，在文档（&lt;code&gt;# Safety&lt;&#x2F;code&gt;段落）里说明&lt;code&gt;unsafe&lt;&#x2F;code&gt;代码的使用要求。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Rust 的&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;index.html&quot;&gt;标准库&lt;&#x2F;a&gt;是一个能够实践了上述所有细节的优秀示例。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gong-ju&quot;&gt;工具&lt;&#x2F;h2&gt;
&lt;p&gt;在注释文档中使用 Markdown 格式不仅意味着优美的输出，还意味着需要有一个明确的转换步骤（&lt;code&gt;cargo doc&lt;&#x2F;code&gt;）。而转换也就会增加出现问题的可能性。&lt;&#x2F;p&gt;
&lt;p&gt;对于这个问题，最简单的建议是在写完文档后，运行&lt;code&gt;cargo doc --open&lt;&#x2F;code&gt;（或者&lt;code&gt;cargo doc --no-deps --open&lt;&#x2F;code&gt;，这个指令能够严格约束仅产生当前包中的文档）并来&lt;em&gt;仔细阅读生成的结果&lt;&#x2F;em&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;对于所有生成超链接的有效性，你当然可以人工地去校验它们，或者让机器来完成这项工作 —— 通过&lt;code&gt;broken_intra_dock_links&lt;&#x2F;code&gt;的包特性&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;#![deny(broken_intra_doc_links)]

&#x2F;&#x2F;&#x2F; The bounding box for a [`Polygone`].
#[derive(Clone, Debug)]
pub struct BoundingBox {
    &#x2F;&#x2F; ...
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当特性生效的时候，&lt;code&gt;cargo doc&lt;&#x2F;code&gt;将会找出无效的链接：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;error: unresolved link to `Polygone`
 --&amp;gt; docs&#x2F;src&#x2F;main.rs:4:30
  |
4 | &#x2F;&#x2F;&#x2F; The bounding box for a [`Polygone`].
  |                              ^^^^^^^^ no item named `Polygone` in scope
  |
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;你也可以设置要求文档化，通过在包里设置&lt;code&gt;![warn(missing_docs)]&lt;&#x2F;code&gt;属性。当设置生效的时候，编译器将会给每个未配置文档的公开条目生成警告信息。然而，这样设置也存在着为了解决编译器报错而提供低质量注释文档的风险 —— 当然设置引入的问题不仅如此。&lt;&#x2F;p&gt;
&lt;p&gt;同样地，为了能够及时发现潜在风险，这些工具应该被纳入到你的持续集成系统（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;ci.html&quot;&gt;第 32 条&lt;&#x2F;a&gt;）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qi-ta-de-wen-dang-wei-zhi&quot;&gt;其他的文档位置&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;cargo doc&lt;&#x2F;code&gt;的输出是包中文档所在的主要位置，但并不是唯一的地方 —— 在项目中的其他地方添加注释也可以帮助用户理解如何使用你的代码。&lt;&#x2F;p&gt;
&lt;p&gt;在 Cargo 项目的&lt;code&gt;examples&#x2F;&lt;&#x2F;code&gt;子目录下可以添加一些方便使用包的示例代码。这些代码可以构建并运行，和集成测试（&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;testing.html&quot;&gt;第 30 条&lt;&#x2F;a&gt;）的运行方式非常类似，不同的是这些代码提供的是便于理解包中接口使用的代码。&lt;&#x2F;p&gt;
&lt;p&gt;需要说明的是，&lt;code&gt;tests&#x2F;&lt;&#x2F;code&gt;子目录下的集成测试代码也可以给用户提供帮助，虽然它们的主要作用是测试包的对外接口。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fa-bu-bao-de-wen-dang&quot;&gt;发布包的文档&lt;&#x2F;h2&gt;
&lt;p&gt;如果你的包会发布到&lt;code&gt;crates.io&lt;&#x2F;code&gt;，项目的文档就可以在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;&quot;&gt;docs.rs&lt;&#x2F;a&gt;中查看到。docs.rs 是为发布的包构建并提供文档的官方 Rust 网站。&lt;&#x2F;p&gt;
&lt;p&gt;注意，&lt;code&gt;crates.io&lt;&#x2F;code&gt;和&lt;code&gt;docs.rs&lt;&#x2F;code&gt;的受众是不同的：&lt;code&gt;crates.io&lt;&#x2F;code&gt;旨在为选择包的用户提供服务，而&lt;code&gt;docs.rs&lt;&#x2F;code&gt;的受众是那些需要弄明白他们已经引用的包该如何使用的人（很明显的，这两种场景有很大的重叠）。&lt;&#x2F;p&gt;
&lt;p&gt;综上，一个包的主页在不同的地方会展示不同的内容：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docs.rs&lt;&#x2F;code&gt;：展示&lt;code&gt;cargo doc&lt;&#x2F;code&gt;产出结果的顶层页面，比如从顶层&lt;code&gt;src&#x2F;lib.rs&lt;&#x2F;code&gt;文件的&lt;code&gt;&#x2F;&#x2F;!&lt;&#x2F;code&gt;生成的文档。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;crates.io&lt;&#x2F;code&gt;：展示包含在项目仓库中的任何顶层&lt;em&gt;README.md&lt;&#x2F;em&gt; &lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;文件内容。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;bu-wen-dang-hua-de-nei-rong&quot;&gt;不文档化的内容&lt;&#x2F;h2&gt;
&lt;p&gt;当一个项目&lt;em&gt;要求&lt;&#x2F;em&gt;公共条目都需要添加注释的时候，很容易就陷入到给无价值的内容也文档化的陷阱中。编译器的缺少注释文档的警告只是提醒你添加真正需要内容 —— 有用的文档 —— 的一种表现，并且仅仅期望程序员添加必要的内容来消除警告。&lt;&#x2F;p&gt;
&lt;p&gt;好的注释文档是一种能够帮助用户了解他们所使用代码的福利；糟糕的注释文档则增加了代码的维护成本并且让用户在它们不再和代码保持一致的时候变得更加困惑。那么好与不好的区别是什么呢？&lt;&#x2F;p&gt;
&lt;p&gt;最重要的建议是&lt;em&gt;避免重复可以从代码中看出的信息&lt;&#x2F;em&gt;。&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rustx-labs.github.io&#x2F;effective-rust-cn&#x2F;chapter_1&#x2F;item1-use-types.html&quot;&gt;第 1 条&lt;&#x2F;a&gt;建议你的代码尽量的和 Rust 的类型系统保持一致；一旦你做到了这一点，就通过类型系统来说明这些语意。可以假定使用代码的用户对 Rust 已经熟悉了 —— 可能他们已经读了一些描述了如何高效使用语言的建议 —— 并且不需要重复从代码中的参数类型和函数签名中就能读出来的东西。&lt;&#x2F;p&gt;
&lt;p&gt;回到之前的例子，一个冗余的注释文档可能如下面描述的这样：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Return a new [`BoundingBox`] object that exactly encompasses a pair
&#x2F;&#x2F;&#x2F; of [`BoundingBox`] objects.
&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F;&#x2F; Parameters:
&#x2F;&#x2F;&#x2F;  - `a`: an immutable reference to a `BoundingBox`
&#x2F;&#x2F;&#x2F;  - `b`: an immutable reference to a `BoundingBox`
&#x2F;&#x2F;&#x2F; Returns: new `BoundingBox` object.
pub fn union(a: &amp;amp;BoundingBox, b: &amp;amp;BoundingBox) -&amp;gt; BoundingBox {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个注释重复了很多从函数签名中就能读到的信息，注释信息毫无益处。&lt;&#x2F;p&gt;
&lt;p&gt;更糟的是，考虑一种代码重构后，将结果存储到其中一个参数（这是一种不兼容的变更；参照&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;semver.html&quot;&gt;第 21 条&lt;&#x2F;a&gt;）。没有编译器或者工具能够发现注释没有随之更新，结果就产生了一个未能和代码逻辑保持一致的注释：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Return a new [`BoundingBox`] object that exactly encompasses a pair
&#x2F;&#x2F;&#x2F; of [`BoundingBox`] objects.
&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F;&#x2F; Parameters:
&#x2F;&#x2F;&#x2F;  - `a`: an immutable reference to a `BoundingBox`
&#x2F;&#x2F;&#x2F;  - `b`: an immutable reference to a `BoundingBox`
&#x2F;&#x2F;&#x2F; Returns: new `BoundingBox` object.
pub fn union(a: &amp;amp;mut BoundingBox, b: &amp;amp;BoundingBox) {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;相反地，原本恰当的注释在重构中则可以毫发无损地保留下来，因为它的文本描述的是行为，而非语意本身：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Calculate the [`BoundingBox`] that exactly encompasses a pair
&#x2F;&#x2F;&#x2F; of [`BoundingBox`] objects.
pub fn union(a: &amp;amp;mut BoundingBox, b: &amp;amp;BoundingBox) {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;先前的建议也可以帮助提升文档质量：&lt;em&gt;在文档中包含任何从代码中无法了解的内容&lt;&#x2F;em&gt;。这包含前置条件、可变性、异常、报错条件以及任何可能会让用户感到意外的事情；如果你的代码不能遵守&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Principle_of_least_astonishment&quot;&gt;最小惊讶原则&lt;&#x2F;a&gt;，确保这些意外都被记录在文档里，至少你可以说“我已经告诉过你了”。&lt;&#x2F;p&gt;
&lt;p&gt;另一个常见的失败情形是，注释里描述了其他使用这个方法的代码，而非这个方法做了什么：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Return the intersection of two [`BoundingBox`] objects, returning `None`
&#x2F;&#x2F;&#x2F; if there is no intersection. The collision detection code in `hits.rs`
&#x2F;&#x2F;&#x2F; uses this to do an initial check to see whether two objects might overlap,
&#x2F;&#x2F;&#x2F; before performing the more expensive pixel-by-pixel check in
&#x2F;&#x2F;&#x2F; `objects_overlap`.
pub fn intersection(
    a: &amp;amp;BoundingBox,
    b: &amp;amp;BoundingBox,
) -&amp;gt; Option&amp;lt;BoundingBox&amp;gt; {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;像这样的注释几乎不可能和代码保持一致：当使用了这个方法的代码（比如，&lt;code&gt;hits.rs&lt;&#x2F;code&gt;）变更的时候，这段描述了调用行为的注释相隔甚远而无法保持一致。&lt;&#x2F;p&gt;
&lt;p&gt;应当将注释重新组织以聚焦在&lt;em&gt;为什么&lt;&#x2F;em&gt;这样使用，可以让这段注释更好的适应未来的变更。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;rust&quot;&gt;&#x2F;&#x2F;&#x2F; Return the intersection of two [`BoundingBox`] objects, returning `None`
&#x2F;&#x2F;&#x2F; if there is no intersection.  Note that intersection of bounding boxes
&#x2F;&#x2F;&#x2F; is necessary but not sufficient for object collision -- pixel-by-pixel
&#x2F;&#x2F;&#x2F; checks are still required on overlap.
pub fn intersection(
    a: &amp;amp;BoundingBox,
    b: &amp;amp;BoundingBox,
) -&amp;gt; Option&amp;lt;BoundingBox&amp;gt; {
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当编写软件时，“面向未来的编程”&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;是一种很好的实践：调整代码结构以适应未来的变更。同样的原则也适用于文档：聚焦在语意，为什么这样做以及为什么不这样做，会让文本在未来的运行中始终是有意义的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;给公共的 API 内容添加注释文档。&lt;&#x2F;li&gt;
&lt;li&gt;为那些从代码中无法明确看出的内容添加描述 —— 比如&lt;code&gt;panics&lt;&#x2F;code&gt;以及&lt;code&gt;unsafe&lt;&#x2F;code&gt;的条件。&lt;&#x2F;li&gt;
&lt;li&gt;不要给可以从代码中明确看出的内容重复描述。&lt;&#x2F;li&gt;
&lt;li&gt;通过交叉引用及添加标志符来让导航变得明确。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;zhu-shi&quot;&gt;注释&lt;&#x2F;h3&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;这个配置也曾称成为&lt;code&gt;intra_doc_link_resolution_failure&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;包含 &lt;em&gt;README.md&lt;&#x2F;em&gt; 的引用动作可以被&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;manifest.html#the-readme-field&quot;&gt;Cargo.toml 中的 readme 字段&lt;&#x2F;a&gt;覆盖。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;3&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2F;sup&gt;
&lt;p&gt;Scott Meyers，More Effective C++ (Addison-Wesley)，第 32 条。&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;原文&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.lurklurk.org&#x2F;effective-rust&#x2F;documentation.html&quot;&gt;点这里&lt;&#x2F;a&gt;查看。&lt;&#x2F;p&gt;
&lt;!-- 参考链接 --&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>3-sum 问题</title>
        <published>2024-05-26T14:39:35+08:00</published>
        <updated>2024-05-26T14:39:35+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/3-sum/"/>
        <id>https://liyan-ah.github.io/3-sum/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/3-sum/">&lt;h2 id=&quot;cong-3-sum-wen-ti-kai-shi-shuo-qi&quot;&gt;从 3-sum 问题开始说起&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;3sum&#x2F;description&#x2F;&quot;&gt;3-sum&lt;&#x2F;a&gt; 问题是 leetcode 中的一个经典问题。笔者最近重新重新回顾了这个问题，尴尬的是
关键时刻居然没有解出来。今天来重新回顾下。作为数组类问题中的经典问题，笔者认为这里有三个关键点：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;记得排序。数组问题大多需要进行排序，有序的数组才具有可操作性。&lt;&#x2F;li&gt;
&lt;li&gt;通过比较，来决定下标移动的位置。在处理 2-sum 过程时，比较当前下标数字的和与目标值的大小来决定下标的下一步移动方向。&lt;&#x2F;li&gt;
&lt;li&gt;对去重的处理。尴尬的就是这部分的处理过程。以笔者目前写代码的习惯，会直接使用 set 来进行去重。翻了下代码，对这部分的处理确实有点绕。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;围绕第三点，下面给出两个解法。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;set-qu-zhong&quot;&gt;set 去重&lt;&#x2F;h3&gt;
&lt;p&gt;先看第一种解法，在处理结果集不重复时，使用 HashSet 来处理结果集唯一性的问题：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;Rust&quot;&gt;impl Solution {
    pub fn three_sum_n(mut nums: Vec&amp;lt;i32&amp;gt;, sum: i32) -&amp;gt; Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; {
        nums.sort();
        let mut res = std::collections::HashSet::new();
        for i in 0..nums.len() {
            let target = sum - nums[i];
            let mut left = i + 1;
            let mut right = nums.len() - 1;
            while left &amp;lt; right {
                if nums[left] + nums[right] == target {
                    &#x2F;&#x2F; 题目中要求的时结果集不重复。直接使用 set 来保证唯一性。
                    res.insert(vec![nums[i], nums[left], nums[right]]);
                    &#x2F;&#x2F; 找到一个后，同时移动 left &amp;amp; right 后继续遍历
                    left += 1;
                    right -= 1;
                    continue;
                }
                if nums[left] + nums[right] &amp;gt; target {
                    right -= 1;
                } else {
                    left += 1;
                }
            }
        }

        res.into_iter().collect()
    }

    pub fn three_sum(mut nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; {
        Self::three_sum_n(nums, 0)
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;tong-guo-bi-jiao-lai-qu-zhong&quot;&gt;通过比较来去重&lt;&#x2F;h3&gt;
&lt;p&gt;第二种解法也是经典解法：在移动下标时，确保当前值和前一个值不同。笔
者回顾了下自己的思路以及给候选人的建议：先进行去重，然后进行比对。
先去重的问题就是，像 [0, 0, 0] 这样的结果就会先被去重环节排除
掉。而题目中没有结果集中的 [x, y, z] x != y &amp;amp;&amp;amp; y != z 的条件。
正确的去重方式应该是，通过后置位和前置位的对比来允许 [0, 0, 0]的
候选集能够出现。解题过程如下：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;Rust&quot;&gt;impl Solution {
    pub fn three_sum_n(mut nums: Vec&amp;lt;i32&amp;gt;, sum: i32) -&amp;gt; Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; {
        nums.sort();
        let mut res = vec![];
        for i in 0..nums.len() {
            &#x2F;&#x2F; 同样需要对 i 进行去重处理
            if i != 0 &amp;amp;&amp;amp; nums[i] == nums[i-1]{
                continue;
            }
            let target = sum - nums[i];
            let mut left = i + 1;
            let mut right = nums.len() - 1;
            while left &amp;lt; right {
                &#x2F;&#x2F; 允许第一个 left 值继续处理。第二个值和前置值对比
                if left != i + 1 &amp;amp;&amp;amp; nums[left] == nums[left - 1] {
                    left += 1;
                    continue;
                }
                &#x2F;&#x2F; 允许第一个 right 值继续处理。第二个值和前置值对比
                if right != nums.len() - 1 &amp;amp;&amp;amp; nums[right] == nums[right + 1] {
                    right -= 1;
                    continue;
                }

                if nums[left] + nums[right] == target {
                    res.push(vec![nums[i], nums[left], nums[right]]);
                    &#x2F;&#x2F; 找到一个后，同时移动 left &amp;amp; right 后继续遍历
                    left += 1;
                    right -= 1;
                    continue;
                }
                if nums[left] + nums[right] &amp;gt; target {
                    right -= 1;
                } else {
                    left += 1;
                }
            }
        }
        res
    }

    pub fn three_sum(mut nums: Vec&amp;lt;i32&amp;gt;) -&amp;gt; Vec&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; {
        Self::three_sum_n(nums, 0)
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;yi-xie-gan-xiang&quot;&gt;一些感想&lt;&#x2F;h2&gt;
&lt;p&gt;最近接触了很多实习生，感觉现在的实习生实力都很强。笔者找工作时，简历里的项目只有小学期的一个项目以及实验室里的一个项目，而且工程量都很小。现在
的候选人都可以在网上找一些开源项目的教程项目来学习了，而且给开源项目提 PR 的能力也很强。确实超过笔者很多。&lt;br &#x2F;&gt;
另一点感想是，学校所在的城市对学生的工程能力还是有影响的：北上的研究生工程实践都很多，而且普遍对工程涉及的一些项目（Redis, ES等）都有一些了解。
而非大厂所在城市的学校，研究生跟着导师做的项目普遍偏学术，而且对工程的了解要少很多。这确实是地利带来的影响，而且确实对候选人的面试有很大的影响。
还是应该通过适当的实习来接触行业。同样的，工作了也需要不断的提升自己的视野面。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>Emacs 字符操作快捷键</title>
        <published>2024-05-13T10:51:15+08:00</published>
        <updated>2024-05-13T10:51:15+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/emacs-zi-fu-cao-zuo-kuai-jie-jian/"/>
        <id>https://liyan-ah.github.io/emacs-zi-fu-cao-zuo-kuai-jie-jian/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/emacs-zi-fu-cao-zuo-kuai-jie-jian/">&lt;p&gt;Emacs 指令行中，比如 load-file 加载文件时默认会填充当前的目录，可以使用 Ctr-backspace 来较为快速的删除文本。也可以通过光标移动至待删除处，Ctr-k 来直接删除光标（含）之后的所有文本。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;快捷键&lt;&#x2F;th&gt;&lt;th&gt;功能&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Ctr-backspace&lt;&#x2F;td&gt;&lt;td&gt;删除光标前的一个单词&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Ctr-k&lt;&#x2F;td&gt;&lt;td&gt;删除光标（含）后的所有文本&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>Cargo config 使用备注</title>
        <published>2024-05-07T11:39:00+08:00</published>
        <updated>2024-05-07T11:39:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/cargo-config/"/>
        <id>https://liyan-ah.github.io/cargo-config/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/cargo-config/">&lt;p&gt;本文旨在回答如下问题：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Rust 项目中，如何配置 dependencies 的路径为指定仓库。&lt;&#x2F;li&gt;
&lt;li&gt;在不指定 branch 或 version 的情况下，dependencies 会拉取什么版本&#x2F;仓库里的数据。&lt;&#x2F;li&gt;
&lt;li&gt;Rust 项目中，配置 dependencies 的最佳实践。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;以下为正文。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ru-he-pei-zhi-dependencies-de-lu-jing&quot;&gt;如何配置 dependencies 的路径？&lt;&#x2F;h2&gt;
&lt;p&gt;出于稳定性考虑，工作中使用的项目，尤其是一些开源的项目，往往无法和社区时刻保持一致。甚至，在选定了一个基线版本后，以周或者年计，主干会持续保持这个版本。有一些效果较好的“新特性”需要合入时，就需要以 patch 的形式合入。同样出于稳定性考虑，
或者兼容性考虑，服务的依赖，甚至依赖的依赖都是无法进行升级的。如果项目的新特性需要依赖库进行变更，就只能将依赖库的基线版本单独维护，按需合入依赖库的 patch。这样的维护方式看起来较为繁琐，但是能够有效避免项目因依赖库的升级而引入新的问
题。&lt;br &#x2F;&gt;
有了这样的需求，对应到 Rust 项目中，就需要对 Cargo.toml 里的 dependencies 配置进行调整，将部分依赖调整为自有库。
参照&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;specifying-dependencies.html&quot;&gt;reference&#x2F;specifying-dependencies&lt;&#x2F;a&gt;，可以通过如下方式来指定依赖库：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;Rust&quot;&gt;[dependencies]
regex = { version = &amp;quot;1.10.3&amp;quot;, git = &amp;quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;regex.git&amp;quot;, branch = &amp;quot;next&amp;quot;, rev = &amp;quot;0c0990399270277832fbb5b91a1fa118e6f63dba&amp;quot;, tag = &amp;quot;11.10.4&amp;quot; }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;除了 git，version、branch、rev 以及 tag 都是可选的，补充四者中的一个参数即可实现分支提交控制的目的。在实践过程中，考虑到分支上的提交是时刻进行的，在确认了基础的功能后，可以考虑发布一个版本。一来可以通过 tag 来进行版本&#x2F;功能的
发布控制，同时也便于后续的功能梳理以及项目整理关键里程碑可视化。通过 branch 来指定依赖库会比较方便，这种方式对仓库的开发流程管理较为依赖：如果分支上提交了功能异常的代码，项目的编译就会异常。rev 方案也可以唯一指定代码版本，只是看起来
不像 tag 那样直观。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dependences-mo-ren-la-qu-shen-me-ban-ben&quot;&gt;dependences 默认拉取什么版本？&lt;&#x2F;h2&gt;
&lt;p&gt;笔者在近期的工作中，遇到了如下的配置方式：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;Rust&quot;&gt;[dependencies]
regex = { git = &amp;quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;regex.git&amp;quot; }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里并没有指定 version, branch 或者 rev。但是在编译项目时也会进行拉取的动作。默认会拉取目标仓库的最新提交（效果和直接 git clone 一致）。&lt;br &#x2F;&gt;
在复杂的项目中，通常会出现依赖库和依赖库的依赖有重合的情况。而Rust 工程在编译时，会通过校验目标库的 source 信息（Cargo.lock 中生成）来识别两个库是相同。当项目的依赖库的 dependence 配置和项目依赖库的依赖的 dependence 配置不同时，
就会出现种种类型不兼容的情况。比如，目前有这样的一个项目&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;dep-check&quot;&gt;dep-check&lt;&#x2F;a&gt;，其依赖
&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;trait-lib&quot;&gt;trait-lib&lt;&#x2F;a&gt;和&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;middle-lib&quot;&gt;middle-lib&lt;&#x2F;a&gt;两个库。同时，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;middle-lib&quot;&gt;middle-lib&lt;&#x2F;a&gt;又对
&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;trait-lib&quot;&gt;trait-lib&lt;&#x2F;a&gt;存在依赖。当&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;dep-check&quot;&gt;dep-check&lt;&#x2F;a&gt;使用了&lt;code&gt;trait_lib::Check&lt;&#x2F;code&gt;，并且将该&lt;code&gt;trait&lt;&#x2F;code&gt;通过引用
&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;middle-lib&quot;&gt;middle-lib&lt;&#x2F;a&gt;里的函数进行处理时，就涉及到&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;dep-check&quot;&gt;dep-check&lt;&#x2F;a&gt;和&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;middle-lib&quot;&gt;middle-lib&lt;&#x2F;a&gt;对&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;trait-lib&quot;&gt;trait-lib&lt;&#x2F;a&gt;的引用校验问题：两个库里涉及的&lt;code&gt;Check&lt;&#x2F;code&gt;是否是同一个&lt;code&gt;Trait&lt;&#x2F;code&gt;？就笔者目前的理解来看，由于 rust 里的 trait 采用的不是 duck-typing，因此就需要编译器在编译时对类型进行强校验。在这个小示例中，如果 middle-lib
的 dependencies 设置如下：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;Rust&quot;&gt;[dependencies]
trait-lib = { git = &amp;quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;trait-lib.git&amp;quot;, tag = &amp;quot;1.0.0&amp;quot; }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;而 dep-check 的 dependencies 设置如下：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;Rust&quot;&gt;[dependencies]
trait-lib = { git = &amp;quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;trait-lib.git&amp;quot;, tag = &amp;quot;1.0.0&amp;quot; }
middle-lib = { git = &amp;quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;middle-lib.git&amp;quot; } # 注意，这种配置方式在 Cargo.lock 生成后，除非使用 cargo update 触发更新，否则依赖版本不会随着代码提交而更新。
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;dep-check 编译时，其引用的&lt;code&gt;trait_lib::Check&lt;&#x2F;code&gt;和 middle-lib 里使用的&lt;code&gt;trait_lib::Check&lt;&#x2F;code&gt;就无法认为是同一个（即使实际上代码的提交是同一个）。依赖库的设置可以通过 Cargo.lock 里的 source 来确认。当 dep-check 和 middle-lib 的 Cargo.lock 对 trait-lib 的 source
配置相同时，就不会出现类型不一致的问题。&lt;br &#x2F;&gt;
由于使用了 tag &#x2F; rev &#x2F; branch 来作为 dependencies 的配置，一个问题是当 trait-lib 发生更新时，需要同时升级 middle-lib 和 dep-check 这两个仓库。否则就会出现版本不一致而编译失败的情况。如果使用 version 控制，由于 version 实际
上表示的是一个&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;specifying-dependencies.html#specifying-dependencies-from-cratesio&quot;&gt;范围&lt;&#x2F;a&gt;，只要 update 后的依赖库是同一个版本即可（准确来说，x.y.z 中的 x.y 保持一致即可），可
以在 cargo update 后检查 dep-check 的 Cargo.lock 中存在几个 trait-lib。在仅存在一个 trait-lib 时，说明依赖库不存在版本冲突，此时不需要更新 middle-lib 中的 Cargo.toml。&lt;&#x2F;p&gt;
&lt;p&gt;配置的问题在这里有描述：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;cargo&#x2F;issues&#x2F;11490&quot;&gt;The dependency resolution is confused when using git dependency and there&#x27;s a lockfile&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;duck-typing 的接口在校验时还比较简单，只需要检查是否实现了目标类型&#x2F;接口定义的函数即可。但是对于非 duck-typing，情况会复杂些：不同的库里是允许出现同名的 trait 的。如何确定项目中实现的 trait 和引用库中需要的 trait 是同一个 trait？这就需要确保项目中 trait 的来源库和引用库中所需要的 trait 来源库是相同的。而看起来，库是否相同，又是通过 source 来确定的。Cargo.toml 中的 source 毕竟是一个工程里的概念，是如何影响编译的呢？是否是编译过程中，函数签名里带着一些source 信息？还需要进一步的探索，期望能够整理成文档。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;dependences-pei-zhi-de-zui-jia-shi-jian&quot;&gt;dependences 配置的最佳实践？&lt;&#x2F;h2&gt;
&lt;p&gt;golang 和 rust 都支持通过配置 git 仓库的地址来直接引用，个人还是比较喜欢 rust 的配置方式：通过 Cargo.toml 能够简洁、明了的声明各种依赖的信息，在工程里可以直接使用库名（而非 golang 里的项目地址）。此外，rust 里的 workspace 机制
对仓库里存在多个 sub-lib 时也能较好的处理依赖的管理。&lt;br &#x2F;&gt;
下面是一个实践示例&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;dep-check&quot;&gt;dep-check&lt;&#x2F;a&gt;：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;Rust&quot;&gt;[workspace]
members = [
    &amp;quot;dep-check&amp;quot;,
    &amp;quot;dep-run&amp;quot;,
]

default-members = [&amp;quot;dep-check&amp;quot;]
resolver = &amp;quot;2&amp;quot;

[workspacepackage]
name = &amp;quot;dep-check&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
edition = &amp;quot;2021&amp;quot;

# See more keys and their definitions at https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;manifest.html

[workspace.dependencies]
trait-lib = { git = &amp;quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;trait-lib.git&amp;quot;, tag = &amp;quot;1.0.0&amp;quot; }
middle-lib = { git = &amp;quot;https:&#x2F;&#x2F;github.com&#x2F;liyan-ah&#x2F;middle-lib.git&amp;quot;, tag = &amp;quot;1.0.0&amp;quot; }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对于其中的一个 member:dep-check，其配置为：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code data-lang=&quot;Rust&quot;&gt;[package]
name = &amp;quot;dep-check&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
edition = &amp;quot;2021&amp;quot;

# See more keys and their definitions at https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;manifest.html

[dependencies]
trait-lib = { workspace = true }
middle-lib = { workspace = true }
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样，就能很便捷的对项目里的依赖进行管理了。&lt;&#x2F;p&gt;
&lt;p&gt;以上。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>合并区间</title>
        <published>2024-04-20T17:11:31+08:00</published>
        <updated>2024-04-20T17:11:31+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/merge-range/"/>
        <id>https://liyan-ah.github.io/merge-range/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;很久没有找工作的经历了，反而由于种种原因，最近接触了一些候选人。总体的感觉是最近是越来越卷了。
候选人的的水平明显比笔者毕业的时候高的多，也可能是笔者太菜了。其中一个合并区间的问题，笔者看到了
一个很有意思的解法。在这里记录下。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;《合并区间》问题的思路很明显：排序、合并。笔者最近见到了一种特殊场景下很有意思的解法：在数据范围较小的情况下，使用桶的思想来
解决，就不再需要进行排序了。算法复杂度也从时间复杂度&lt;code&gt;o(nlgn)&lt;&#x2F;code&gt;降到了&lt;code&gt;o(n)&lt;&#x2F;code&gt;。这里记录下。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>BPF LRU_HASH_MAP 及 HASH_MAP 的使用异常</title>
        <published>2024-03-12T11:02:00+08:00</published>
        <updated>2024-03-12T11:02:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/bpf-lru-hash-map-ji-hash-map-de-shi-yong-yi-chang/"/>
        <id>https://liyan-ah.github.io/bpf-lru-hash-map-ji-hash-map-de-shi-yong-yi-chang/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;BPF 技术看起来还有很多不易察觉的缺陷。最近又踩了一个坑。记录下。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;LRU_HASH_MAP&lt;&#x2F;code&gt; 在实现的时候，出现了不符合预期的数据驱逐问题：设定一个 512 大小的&lt;code&gt;LRU_HASH_MAP&lt;&#x2F;code&gt;，很可能出现在40-50个&lt;code&gt;key&lt;&#x2F;code&gt;的时候，之前的&lt;code&gt;key&lt;&#x2F;code&gt;就被覆盖。在一段时间未更新时，重新更新也可能会出现异常。总结就是，执行了写入操作，很可能没有写入。这个问题在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;75882443&#x2F;elements-incorrectly-evicted-from-ebpf-lru-hash-map&quot;&gt;Elements incorrectly evicted from eBPF LRU hash map&lt;&#x2F;a&gt;有较为详细的描述。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>TCP close 过程分析</title>
        <published>2024-02-24T15:55:00+08:00</published>
        <updated>2024-02-24T15:55:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/tcp-close-guo-cheng-fen-xi/"/>
        <id>https://liyan-ah.github.io/tcp-close-guo-cheng-fen-xi/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近做了一些 TCP 连接观测相关的项目，又到了一个节奏点上了。这里趁着这个机会，做一些总结，同时描述一下 tcp close 过程中的一些疑惑。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;在一些场景下，对服务的调用观测是很有价值的。笔者最近实践了使用&lt;code&gt;tcp_close&lt;&#x2F;code&gt;对服务主被调信息的观测，在这里作一下记录。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>BPF 获取 LVS FullNat 模式下的 Client IP</title>
        <published>2024-01-03T16:15:00+08:00</published>
        <updated>2024-01-03T16:15:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/bpf-huo-qu-lvs-fullnet-mo-shi-xia-de-client-ip/"/>
        <id>https://liyan-ah.github.io/bpf-huo-qu-lvs-fullnet-mo-shi-xia-de-client-ip/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;搞项目。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;观测服务的请求调用需求是客观存在的。一般是需要观测服务的主动发起的调用信息，但是偶尔也会遇到需要观测服务被调用信息的需求。但是一般待采集的服务都是挂载在&lt;code&gt;LVS&lt;&#x2F;code&gt;下面的。这就势必涉及到&lt;code&gt;LVS&lt;&#x2F;code&gt;预设的工作模式下，一般都是&lt;code&gt;FULLNET&lt;&#x2F;code&gt;，需要的&lt;code&gt;real client ip&lt;&#x2F;code&gt;的信息获取方式。&lt;br &#x2F;&gt;
笔者通过调研，实现了一种通过&lt;code&gt;BPF&lt;&#x2F;code&gt;来观测挂载在&lt;code&gt;LVS&lt;&#x2F;code&gt;下的&lt;code&gt;RS&lt;&#x2F;code&gt;被调用&lt;code&gt;TCP&lt;&#x2F;code&gt;连接信息的方式。本文中关于&lt;code&gt;toa&lt;&#x2F;code&gt;的操作及代码定义均引用自&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Huawei&#x2F;TCP_option_address&#x2F;tree&#x2F;master&quot;&gt;Huawei&#x2F;TCP_option_address&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>如何追踪golang channel?</title>
        <published>2023-12-08T19:43:00+08:00</published>
        <updated>2023-12-08T19:43:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/wei-shen-me-wo-men-wu-fa-zhui-zong-golang-channel/"/>
        <id>https://liyan-ah.github.io/wei-shen-me-wo-men-wu-fa-zhui-zong-golang-channel/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2023年就要结束了，算起来距离上一次更新也有很久了。搜肠刮肚，总得在23年结束前再搞两篇总结，算是有始有终。总结今年，总还是绕不过 BPF，golang。既然如此，就对BPF观测golang这个话题再往下挖掘下，先做第一篇文章。下旬如果有时间并且顺利的话，希望能把BPF的原理总结完成。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2023&#x2F;03&#x2F;29&#x2F;cljb83dmh003dkcs61joe1kfh&#x2F;#more&quot;&gt;无侵入观测服务拓扑四元组的一种实现&lt;&#x2F;a&gt;中，笔者有提到追踪&lt;code&gt;golang&lt;&#x2F;code&gt;处理过程的两个无法解决的问题是&lt;code&gt;golang&lt;&#x2F;code&gt;里的&lt;code&gt;channel&lt;&#x2F;code&gt;处理以及&lt;code&gt;goroutine pool&lt;&#x2F;code&gt;。再深究下，这两个问题实际上都可以归纳到对&lt;code&gt;channel&lt;&#x2F;code&gt;的处理，因为很多&lt;code&gt;goroutine pool&lt;&#x2F;code&gt;都离不了&lt;code&gt;channel&lt;&#x2F;code&gt;的使用，比如&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Jeffail&#x2F;tunny&quot;&gt;Jeffail&#x2F;tunny&lt;&#x2F;a&gt;这个库。&lt;br &#x2F;&gt;
本文将会构建一个&lt;code&gt;channel&lt;&#x2F;code&gt;的追踪的方案。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>bpftrace 遍历 golang 链表（go17+）</title>
        <published>2023-11-18T15:36:00+08:00</published>
        <updated>2023-11-18T15:36:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/bpftrace-bian-li-golang-lian-biao-go17/"/>
        <id>https://liyan-ah.github.io/bpftrace-bian-li-golang-lian-biao-go17/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;不出意外的，之前提到的 ELF 文件解析内容又拖延了。目前还不知道什么时候有时间能够把希望完成的几篇文章给搞完。翻一翻目前的博客，已经有很久没有更新了。那就水一篇文章吧。目前算是项目里的低谷期，希望能够重拾程序员的意义。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;07&#x2F;22&#x2F;cljb83dlm000ckcs6bp7thrf9&#x2F;#more&quot;&gt;bpftrace 无侵入遍历golang链表&lt;&#x2F;a&gt;里，笔者展示了使用&lt;code&gt;bpftrace&lt;&#x2F;code&gt;来遍历&lt;code&gt;golang&lt;&#x2F;code&gt;链表的方法。由于&lt;code&gt;go-17&lt;&#x2F;code&gt;和&lt;code&gt;go-16&lt;&#x2F;code&gt;的函数调用规约存在不同，因此&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;07&#x2F;22&#x2F;cljb83dlm000ckcs6bp7thrf9&#x2F;#more&quot;&gt;bpftrace 无侵入遍历golang链表&lt;&#x2F;a&gt;并不适用于&lt;code&gt;go-17&lt;&#x2F;code&gt;。其实这个问题在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2023&#x2F;03&#x2F;03&#x2F;cljb83dm2001mkcs68hgf9o2s&#x2F;#more&quot;&gt;go-1.17+ 调用规约&lt;&#x2F;a&gt;已经提到了解决方案。本文给一个实例，算是更进一步的延伸这个话题，希望能够起到一些效果。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>eBPF tail-calls示例</title>
        <published>2023-08-26T12:30:00+08:00</published>
        <updated>2023-08-26T12:30:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/ebpf-tail-calls/"/>
        <id>https://liyan-ah.github.io/ebpf-tail-calls/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近在整理一些技术文章。本来希望把涉及ELF的内容整理出来，结果发现太难了。ELF涉及的内容要多很多，如果要把希望整理的内容表述清楚，还需要做一些准备的工作。刚好最近完成了tail-calls 的调研，先把关于eBPF的tail-calls的功能整理下吧。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;eBPF&lt;&#x2F;code&gt;程序是事件驱动的，这就意味着当目标事件触发后，程序才能执行。考虑这样一个场景：有几个不同的&lt;code&gt;BPF&lt;&#x2F;code&gt;程序均挂载在相同的&lt;code&gt;hook&lt;&#x2F;code&gt;点上，而执行需要保持一定的顺序。这时就需要借助&lt;code&gt;tail calls&lt;&#x2F;code&gt;的功能来实现。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>BPF追踪Go程序的挑战</title>
        <published>2023-06-25T17:08:00+08:00</published>
        <updated>2023-06-25T17:08:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/golang/"/>
        <id>https://liyan-ah.github.io/golang/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文地址&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.0x74696d.com&#x2F;posts&#x2F;challenges-of-bpf-tracing-go&#x2F;&quot;&gt;Challenges of BPF Tracing Go&lt;&#x2F;a&gt;。翻译不尽如人意，继续努力。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;bpfzhui-zong-gocheng-xu-de-tiao-zhan&quot;&gt;BPF追踪Go程序的挑战&lt;&#x2F;h1&gt;
&lt;p&gt;当大家对&lt;code&gt;Go 1.17&lt;&#x2F;code&gt;语言调用规约(&lt;code&gt;function calling convention&lt;&#x2F;code&gt;)调整带来的性能优化感到兴奋时，我却遗憾的看到&lt;code&gt;Go 1.17&lt;&#x2F;code&gt;并没有让&lt;code&gt;BPF uretprobe&lt;&#x2F;code&gt;变得可行。事实证明，我还没有完全意识到&lt;code&gt;Go&lt;&#x2F;code&gt;的可调整的栈空间会让事情变得多复杂。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>PlantUML-文本化绘制UML多类图表</title>
        <published>2023-04-21T20:51:00+08:00</published>
        <updated>2023-04-21T20:51:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/plantuml-wen-ben-hua-hui-zhi-umlduo-lei-tu-biao/"/>
        <id>https://liyan-ah.github.io/plantuml-wen-ben-hua-hui-zhi-umlduo-lei-tu-biao/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;笔者一直都是文本编辑器教派的忠实拥趸：期望将所有的任务都通过文本编辑，而非鼠标&#x2F;触摸板等，进行实现。从早年的&lt;code&gt;Vim&lt;&#x2F;code&gt;，到现而今的&lt;code&gt;Emacs&lt;&#x2F;code&gt;，对文本化完成需求是越来越习惯，也越来越依赖了。最近刚好有了些时间，把最近的一些实践整理下。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;在之前的文章，&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2023&#x2F;02&#x2F;10&#x2F;emacs-org-mode%E7%BB%98%E5%88%B6%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE&#x2F;&quot;&gt;emacs org-mode 绘制思维导图&lt;&#x2F;a&gt;，中，笔者有提到在探索不跳出&lt;code&gt;Emacs&lt;&#x2F;code&gt;这一文本编辑器的情况下，完成思维导图绘制的需求。在翻了一些文章后，找到了一款神器：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;plantuml.com&#x2F;zh&#x2F;&quot;&gt;PlantUML&lt;&#x2F;a&gt;。其完美的匹配了笔者的需求：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;不仅是思维导图，工程、文档常用的&lt;code&gt;UML&lt;&#x2F;code&gt;图像也能全部支持文本化表示；&lt;&#x2F;li&gt;
&lt;li&gt;功能强大，颜色、文本等格式均能支持；&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Emacs&lt;&#x2F;code&gt;友好，而且可以集成到&lt;code&gt;Org-mode&lt;&#x2F;code&gt;里使用。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;而且，&lt;code&gt;PlantUML&lt;&#x2F;code&gt;支持在线使用，意味着能够很方便的获取、使用。这里做下介绍。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>无侵入观测服务拓扑四元组的一种实现</title>
        <published>2023-03-29T19:42:00+08:00</published>
        <updated>2023-03-29T19:42:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/wu-qin-ru-guan-ce-fu-wu-si-yuan-zu/"/>
        <id>https://liyan-ah.github.io/wu-qin-ru-guan-ce-fu-wu-si-yuan-zu/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近有了些时间，继续整理下之前的项目。服务四元组的信息对于故障处置、根因定位等都有重要意义。使用eBPF可以做到无侵入用户代码获取服务四元组信息的功能。这一点在工程应用上很有意义。笔者在这方面投入了一些精力，这里做一下简单的总结。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;服务四元组指的是[caller, caller_func, callee, callee_func]四元组。如下图是一个调用示例，站在服务&lt;code&gt;A&lt;&#x2F;code&gt;的角度，就存在如下两个四元组: [A, &#x2F;a, B, &#x2F;b]，[A, &#x2F;a, C, &#x2F;c]。站在服务&lt;code&gt;B&lt;&#x2F;code&gt;, &lt;code&gt;C&lt;&#x2F;code&gt;的角度，也存在两个四元组（可能有不同的理解）: [B, &#x2F;b, none, none], [C, &#x2F;c, none, none]。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;                       service call                  
                                                     
     ,-------.          ,-.          ,-.          ,-.
     |outisde|          |A|          |B|          |C|
     `---+---&amp;#39;          `+&amp;#39;          `+&amp;#39;          `+&amp;#39;
         |      &#x2F;a       |            |            | 
         |--------------&amp;gt;|            |            | 
         |               |            |            | 
         |               |    &#x2F;b      |            | 
         |               |-----------&amp;gt;|            | 
         |               |            |            | 
         |               |           &#x2F;c            | 
         |               |------------------------&amp;gt;| 
     ,---+---.          ,+.          ,+.          ,+.
     |outisde|          |A|          |B|          |C|
     `-------&amp;#39;          `-&amp;#39;          `-&amp;#39;          `-&amp;#39;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在弄清楚四元组是什么之后，下面进入今天的话题：如何使用&lt;code&gt;BPF&lt;&#x2F;code&gt;来采集四元组。需要说明的是，笔者这里的语言使用的是&lt;code&gt;golang-1.16&lt;&#x2F;code&gt;。&lt;code&gt;golang&lt;&#x2F;code&gt;不同语言版本间的区别，见：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2023&#x2F;03&#x2F;03&#x2F;golang-1-17-%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E7%BA%A6&#x2F;#more&quot;&gt;golang-1.17+调用规约&lt;&#x2F;a&gt;。&lt;br &#x2F;&gt;
值得注意的是，关于观测服务数据，是有很多解决方案的。本文仅是笔者实践的一种解决方案，在文末会简单提到这种方案的优缺点。&lt;br &#x2F;&gt;
按照惯例，先看下效果吧：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# 启动采集
bpftrace .&#x2F;http.bt
Attaching 2 probes...  # 未触发请求前，停止在这里
caller:                # 触发请求后，输出
  	caller_path: &#x2F;handle
callee:
  	method: GET
  	host: 0.0.0.0:9932
  	url: &#x2F;echo
  
caller:
  	caller_path: &#x2F;echo
callee: none
  
# 开始服务
.&#x2F;http_demo &amp;amp;
# 触发请求
curl http:&#x2F;&#x2F;0.0.0.0:9932&#x2F;handle
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>go-1.17+ 调用规约</title>
        <published>2023-03-03T20:59:00+08:00</published>
        <updated>2023-03-03T20:59:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/golang-1-17-can-shu-diao-yong-gui-yue/"/>
        <id>https://liyan-ah.github.io/golang-1-17-can-shu-diao-yong-gui-yue/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;go-1.17&lt;&#x2F;code&gt;是一个很不友好的版本，这里我指的是函数调用规约的变更。在此之前，虽然栈传参比较奇怪，但是在掌握了规律后，参数信息很好获取。升级到&lt;code&gt;go-1.17&lt;&#x2F;code&gt;之后，笔者发现变更后的寄存器传值方式并不是系统的调用规约，至少和&lt;code&gt;C&#x2F;C++&lt;&#x2F;code&gt;的是完全不一致的。这个问题使得笔者在处理&lt;code&gt;ebpf&lt;&#x2F;code&gt;方案时，始终无法覆盖&lt;code&gt;go-1.17+&lt;&#x2F;code&gt;的版本。虽然短期不会造成影响，线上服务使用的大多还在&lt;code&gt;go-1.16&lt;&#x2F;code&gt;以下，但是这始终是一个绕不过去的问题。近期通过查阅资料和参考其他开源项目里对这部分内容的处理，整理了一下&lt;code&gt;go-1.17+&lt;&#x2F;code&gt;的调用规约。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;go&lt;&#x2F;code&gt;在&lt;code&gt;1.17&lt;&#x2F;code&gt;之前使用的是内存栈来传递参数，这种传参的方式使得&lt;code&gt;golang&lt;&#x2F;code&gt;的语言设计很灵活：&lt;code&gt;golang&lt;&#x2F;code&gt;函数的多返回值能够很容易的实现。同样的，由于&lt;code&gt;golang&lt;&#x2F;code&gt;需要这样灵活的能力，是的系统默认的调用规约方式并不适用。在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;go.googlesource.com&#x2F;proposal&#x2F;+&#x2F;refs&#x2F;changes&#x2F;78&#x2F;248178&#x2F;1&#x2F;design&#x2F;40724-register-calling.md&quot;&gt;Proposal: Register-based Go calling convention&lt;&#x2F;a&gt;文章里对这个问题进行了详细的讨论，总结起来是&lt;code&gt;golang&lt;&#x2F;code&gt;的特性使得使用系统默认规约并不能带来多语言交互上的收益，且&lt;code&gt;golang&lt;&#x2F;code&gt;希望保持独特。&lt;br &#x2F;&gt;
本文下面会给出总结的调用规约，并且给出验证程序。本文档的整理所基于的平台是&lt;code&gt;x86_64&lt;&#x2F;code&gt;的&lt;code&gt;centos8&lt;&#x2F;code&gt;系统。其他架构下，寄存器名称可能不同。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>ebpf 采集ebpf 采集tag+tcp五元组</title>
        <published>2023-02-24T21:44:49+08:00</published>
        <updated>2023-02-24T21:44:49+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/ebpf-cai-ji-caller-func/"/>
        <id>https://liyan-ah.github.io/ebpf-cai-ji-caller-func/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在这里对文章题目作一些说明。笔者想了很长时间也无法给这篇文章想个恰当的表意题目。实际上使用&lt;code&gt;ebpf&lt;&#x2F;code&gt;来进行服务观测是有在进行的，比如获取目前&lt;code&gt;l1s&lt;&#x2F;code&gt;上的常见的四元组。但是本文不是介绍这部分可观测实践的。文章希望阐述的场景是：采集请求触发里的一些信息（诸如&lt;code&gt;trace&lt;&#x2F;code&gt;及其他&lt;code&gt;header&lt;&#x2F;code&gt;等）并和服务请求下游的传输层五元组(protocol, src-ip, src-port, dst-ip, dst-port)进行关联。这也是最近工作中实际遇到的问题。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;基于&lt;code&gt;ebpf&lt;&#x2F;code&gt;的丰富的特性能够获取服务很多的信息，不同特性的组合更是可以达到极强的数据整合能力。比如通过&lt;code&gt;uprobe&lt;&#x2F;code&gt;便捷的获取业务信息后，结合&lt;code&gt;kprobe&lt;&#x2F;code&gt;来获取系统调用里的内容，可以获取一般侵入式可观测代码无法获取的内容。笔者最近遇到的一个实际问题是：获取服务&lt;code&gt;A&lt;&#x2F;code&gt;的接口&lt;code&gt;&#x2F;a&lt;&#x2F;code&gt;响应后，向下游&lt;code&gt;B&lt;&#x2F;code&gt;发起的请求时，所使用的传输层五元组，同时带上结合一些&lt;code&gt;&#x2F;a&lt;&#x2F;code&gt;触发时的一些内容，比如&lt;code&gt;caller_fun&lt;&#x2F;code&gt;或者&lt;code&gt;traceId&lt;&#x2F;code&gt;。&lt;br &#x2F;&gt;
这里值得说明的是，用户态请求的是一个域名。域名的解析是在&lt;code&gt;golang&lt;&#x2F;code&gt;的&lt;code&gt;http&lt;&#x2F;code&gt;里完成的。但是请注意，&lt;code&gt;golang&lt;&#x2F;code&gt;发起&lt;code&gt;tcp&lt;&#x2F;code&gt;请求时，&lt;code&gt;local port&lt;&#x2F;code&gt;设置的是&lt;code&gt;0&lt;&#x2F;code&gt;，然后由内核态的&lt;code&gt;tpc&lt;&#x2F;code&gt;处理来选择一个空闲的&lt;code&gt;port&lt;&#x2F;code&gt;作为&lt;code&gt;socket&lt;&#x2F;code&gt;里的&lt;code&gt;lport&lt;&#x2F;code&gt;。这部分的信息通过代码的埋点显然是无法获取的（详情可参考&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?__biz=MjM5Njg5NDgwNA==&amp;amp;mid=2247485577&amp;amp;idx=1&amp;amp;sn=24220fcc3782f61b4a691585251f1c27&amp;amp;chksm=a6e309b2919480a4696c8a2944ad887951100b5068050d354eab40cf0c8f1124b6367176a0a6&amp;amp;scene=21#wechat_redirect&quot;&gt;TCP连接中客户端的端口号是如何确定的？&lt;&#x2F;a&gt;）。&lt;br &#x2F;&gt;
下面介绍下实现效果及思路。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于&lt;code&gt;bpftrace&lt;&#x2F;code&gt;使用的介绍，可以参见：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;07&#x2F;22&#x2F;bpfTrace-%E8%BF%BD%E8%B8%AA-uprobe&#x2F;#more&quot;&gt;bpftrace 无侵入遍历golang链表&lt;&#x2F;a&gt;，关于&lt;code&gt;ebpf&lt;&#x2F;code&gt;来进行数据采集的实践，可以参见&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;10&#x2F;21&#x2F;ebpf%E9%87%87%E9%9B%86mysql%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E5%8F%8Aebpf%E5%AF%B9%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E7%9A%84%E6%80%9D%E8%80%83&#x2F;&quot;&gt;ebpf采集mysql请求信息及ebpf对应用安全的思考&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>emacs org-mode 绘制思维导图</title>
        <published>2023-02-10T19:46:21+08:00</published>
        <updated>2023-02-10T19:46:21+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/emacs-org-modehui-zhi-si-wei-dao-tu/"/>
        <id>https://liyan-ah.github.io/emacs-org-modehui-zhi-si-wei-dao-tu/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;工作中难免会搞一些思维导图，一些小的需求又不希望切换窗口到另外一个界面去特地绘制。使用 emacs 来整理思维导图可以提升一些的效率，在当前窗口（文本编辑器）里即可完成简单思维导图的绘制。同时可以便于对工作内容进行归档（比如把相关的文本都放到一起）。live in emacs.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;yi-lai-nei-rong&quot;&gt;依赖内容&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;org-contrib 扩展文件。用来将 org-mode 格式的文本转换成 freemind mm 文件。&lt;&#x2F;li&gt;
&lt;li&gt;freemind 软件。用来查看生成的 mm 文件。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;笔者试了一下，&lt;code&gt;Xmind思维导图&lt;&#x2F;code&gt;看起来无法打开&lt;code&gt;mm&lt;&#x2F;code&gt;文件，&lt;code&gt;freemind&lt;&#x2F;code&gt;工作正常。也可能是我操作有问题。&lt;br &#x2F;&gt;
此外，生成的思维导图展现样式肯定没有目前专业的思维导图工具丰富，如果有正式的使用需求，还是首先考虑下专业的思维导图工具。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>golang常见类型作为参数的eBPF解析</title>
        <published>2022-12-30T19:24:18+08:00</published>
        <updated>2022-12-30T19:24:18+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/golangchang-jian-lei-xing-jie-xi/"/>
        <id>https://liyan-ah.github.io/golangchang-jian-lei-xing-jie-xi/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;即将过去的2022年，笔者相当比例的精力都投入在了eBPF上。最初的时候，写了一篇&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;06&#x2F;06&#x2F;golang-%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E5%AD%97%E8%8A%82%E6%95%B0&#x2F;&quot;&gt;golang 常见类型字节数
&lt;&#x2F;a&gt;，开启了&lt;code&gt;eBPF+golang&lt;&#x2F;code&gt;的总结性工作。此后陆续整理了一些关于&lt;code&gt;ebpf&lt;&#x2F;code&gt;的使用文章，同时项目也在逐步的推进。&lt;code&gt;eBPF&lt;&#x2F;code&gt;的实际落地有很大的挑战，但是最终还是找到了一些落地的场景。年底了，结合最近的调研工作，笔者整理了这篇文章。既算是对之前文章的呼应，也是对今年整理内容的总结。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;eBPF&lt;&#x2F;code&gt;能够提供一种切入服务细节的独特视角。本文即通过实例，对&lt;code&gt;golang&lt;&#x2F;code&gt;常见类型作为函数参数时进行解析，期望读者能够感受这一视角。需要说明的是，本文是基于&lt;code&gt;golang-1.16&lt;&#x2F;code&gt;来整理的。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>基于ebpf实现的gls</title>
        <published>2022-11-25T01:14:00+08:00</published>
        <updated>2022-11-25T01:14:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/ji-yu-ebpfshi-xian-de-gls/"/>
        <id>https://liyan-ah.github.io/ji-yu-ebpfshi-xian-de-gls/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;虽然&lt;code&gt;golang&lt;&#x2F;code&gt;并不推荐使用&lt;code&gt;goid&lt;&#x2F;code&gt;来构建&lt;code&gt;gls&lt;&#x2F;code&gt;(&lt;code&gt;goroutine local storage&lt;&#x2F;code&gt;)，仍然有着很多的实现&lt;code&gt;gls&lt;&#x2F;code&gt;并使用的尝试。&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jtolio&#x2F;gls&quot;&gt;github-gls&lt;&#x2F;a&gt;这里是一个常见的实现，基本表述了&lt;code&gt;golang&lt;&#x2F;code&gt;里&lt;code&gt;gls&lt;&#x2F;code&gt;的实现思路：获取&lt;code&gt;goid&lt;&#x2F;code&gt;，基于&lt;code&gt;goid&lt;&#x2F;code&gt;构建一个存储。本文中笔者尝试基于&lt;code&gt;ebpf&lt;&#x2F;code&gt;来构建一个&lt;code&gt;golang&lt;&#x2F;code&gt;的&lt;code&gt;gls&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;ji-ben-gong-neng&quot;&gt;基本功能&lt;&#x2F;h1&gt;
&lt;p&gt;本文中基于&lt;code&gt;ebpf&lt;&#x2F;code&gt;实现的&lt;code&gt;gls&lt;&#x2F;code&gt;具有如下功能：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;基于&lt;code&gt;goid&lt;&#x2F;code&gt;的存储。即&lt;code&gt;map[goid]=value&lt;&#x2F;code&gt;；&lt;&#x2F;li&gt;
&lt;li&gt;基于&lt;code&gt;goroutine&lt;&#x2F;code&gt;派生关系设置的&lt;code&gt;value&lt;&#x2F;code&gt;缺省值。即&lt;code&gt;map[goid=1]=121&lt;&#x2F;code&gt;，且&lt;code&gt;goid=1&lt;&#x2F;code&gt;派生&lt;code&gt;goid=2&lt;&#x2F;code&gt;，则&lt;code&gt;map[goid=2]=map[goid=1]=121&lt;&#x2F;code&gt;；&lt;br &#x2F;&gt;
本文建议参照&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;11&#x2F;04&#x2F;%E9%BB%91%E9%AD%94%E6%B3%95-ebpf-%E5%AF%B9%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%86%99%E5%85%A5&#x2F;#more&quot;&gt;黑魔法-ebpf-对用户空间数据的写入&lt;&#x2F;a&gt;进行理解。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>黑魔法--用 ebpf 构建用户空间数据的桥梁</title>
        <published>2022-11-04T18:00:00+08:00</published>
        <updated>2022-11-04T18:00:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/hei-mo-fa-ebpf-dui-yong-hu-kong-jian-shu-ju-de-xie-ru/"/>
        <id>https://liyan-ah.github.io/hei-mo-fa-ebpf-dui-yong-hu-kong-jian-shu-ju-de-xie-ru/</id>
        
        <summary type="html">&lt;p&gt;在之前的示例中，仅涉及到&lt;code&gt;ebpf&lt;&#x2F;code&gt;对用户空间数据的读取。工程性较强的如：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liyan-ah.github.io&#x2F;2022&#x2F;10&#x2F;21&#x2F;ebpf%E9%87%87%E9%9B%86mysql%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E5%8F%8Aebpf%E5%AF%B9%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E7%9A%84%E6%80%9D%E8%80%83&#x2F;&quot;&gt;ebpf采集mysql请求信息及ebpf对应用安全的思考&lt;&#x2F;a&gt;也仅是通过&lt;code&gt;urpobe&lt;&#x2F;code&gt;采集用户空间的数据。本文介绍点&lt;code&gt;ebpf&lt;&#x2F;code&gt;的“黑魔法”：将用户空间数据的读取、用户空间数据的写入结合起来，成为用户空间数据交互的桥梁。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>ebpf采集mysql请求信息及ebpf对应用安全的思考</title>
        <published>2022-10-21T19:48:00+08:00</published>
        <updated>2022-10-21T19:48:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/ebpfcai-ji-mysqlqing-qiu-xin-xi-ji-ebpfdui-ying-yong-an-quan-de-si-kao/"/>
        <id>https://liyan-ah.github.io/ebpfcai-ji-mysqlqing-qiu-xin-xi-ji-ebpfdui-ying-yong-an-quan-de-si-kao/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文笔者继续介绍&lt;code&gt;ebpf&lt;&#x2F;code&gt; 的应用：使用&lt;code&gt;bpftrace&lt;&#x2F;code&gt;采集&lt;code&gt;mysql&lt;&#x2F;code&gt;连接信息，包括数据库地址、&lt;code&gt;db_name&lt;&#x2F;code&gt;、&lt;code&gt;user_name&lt;&#x2F;code&gt;。在展示采集操作的同时，附上对&lt;code&gt;ebpf&lt;&#x2F;code&gt;对云时代应用安全的一些思考。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;mu-biao&quot;&gt;目标&lt;&#x2F;h1&gt;
&lt;p&gt;使用&lt;code&gt;bpftrace&lt;&#x2F;code&gt;对一个运行中进程的&lt;code&gt;mysql&lt;&#x2F;code&gt;请求进行采集，目标采集内容包括数据库地址、&lt;code&gt;db_name&lt;&#x2F;code&gt;、&lt;code&gt;user_name&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>x86_64 寄存器传参方式</title>
        <published>2022-08-31T19:51:00+08:00</published>
        <updated>2022-08-31T19:51:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/x86-64-chuan-can-fang-shi/"/>
        <id>https://liyan-ah.github.io/x86-64-chuan-can-fang-shi/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/x86-64-chuan-can-fang-shi/">&lt;blockquote&gt;
&lt;p&gt;x86_64 架构下，寄存器传参时，仅 arg1-arg6 会通过寄存器进行，arg7+ 的参数，将会放到栈上进行。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;yan-zheng-dai-ma&quot;&gt;验证代码&lt;&#x2F;h1&gt;
&lt;pre&gt;&lt;code&gt;# 环境
├── arg.bt
├── arg_test
└── hello.c
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;&#x2F;&#x2F; hello.c, gcc -o arg_test hello.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

void print_arg(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6,
               int arg7, int arg8){
    printf(&amp;quot;%d, %d, %d, %d, %d, %d, %d, %d
&amp;quot;, arg1, arg2, arg3, arg4, arg5,
           arg6, arg7, arg8);
    return;
}

int main(){
    print_arg(1,2,3,4,5,6,7,8);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;&#x2F;&#x2F; arg.bt
#!&#x2F;bin&#x2F;bpftrace

uprobe:.&#x2F;arg_test:print_arg
{
    printf(&amp;quot;== enter print_arg
&amp;quot;);
    printf(&amp;quot;arg1: %d
&amp;quot;, arg0);
    printf(&amp;quot;arg2: %d
&amp;quot;, arg1);
    printf(&amp;quot;arg3: %d
&amp;quot;, arg2);
    printf(&amp;quot;arg4: %d
&amp;quot;, arg3);
    printf(&amp;quot;arg5: %d
&amp;quot;, arg4);
    printf(&amp;quot;arg6: %d
&amp;quot;, arg5);
    printf(&amp;quot;arg7: %d
&amp;quot;, sarg0);
    printf(&amp;quot;arg8: %d
&amp;quot;, sarg1);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;zhi-xing-jie-guo&quot;&gt;执行结果&lt;&#x2F;h1&gt;
&lt;pre&gt;&lt;code&gt;sudo bpftrace arg.bt
Attaching 1 probe...
== enter print_arg
arg1: 1
arg2: 2
arg3: 3
arg4: 4
arg5: 5
arg6: 6
arg7: 7
arg8: 8

.&#x2F;arg_test
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;can-zhao&quot;&gt;参照&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;wiki.cdot.senecacollege.ca&#x2F;wiki&#x2F;X86_64_Register_and_Instruction_Quick_Start&quot;&gt;X86 64 Register and Instruction Quick Start&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>bpftrace 无侵入遍历golang链表</title>
        <published>2022-07-22T21:48:00+08:00</published>
        <updated>2022-07-22T21:48:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/bpftrace-zhui-zong-uprobe/"/>
        <id>https://liyan-ah.github.io/bpftrace-zhui-zong-uprobe/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;bpftrace&lt;&#x2F;code&gt; 基于 &lt;code&gt;bcc&lt;&#x2F;code&gt; 进行开发的工具，语法简洁、功能强大。用其分析&lt;code&gt;Linux&lt;&#x2F;code&gt; 环境下的程序会很方便。本文构造了一个入参为链表头节点的函数使用场景，通过使用&lt;code&gt;bpftrace&lt;&#x2F;code&gt;无侵入遍历链表成员的方式，介绍&lt;code&gt;bpftrace&lt;&#x2F;code&gt; &lt;code&gt;attach uprobe&lt;&#x2F;code&gt; 的使用。更多使用说明见:&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;iovisor&#x2F;bpftrace&#x2F;blob&#x2F;master&#x2F;docs&#x2F;reference_guide.md&quot;&gt;bpftrace官网使用文档&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>让emacs在保存文件时自动格式化代码</title>
        <published>2022-07-15T20:34:00+08:00</published>
        <updated>2022-07-15T20:34:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/rang-emacszai-bao-cun-wen-jian-shi-zi-dong-ge-shi-hua-dai-ma/"/>
        <id>https://liyan-ah.github.io/rang-emacszai-bao-cun-wen-jian-shi-zi-dong-ge-shi-hua-dai-ma/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liam.page&#x2F;&quot;&gt;liam&lt;&#x2F;a&gt;同学在&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;liam.page&#x2F;2020&#x2F;11&#x2F;04&#x2F;Vim-auto-format-codes-on-save&#x2F;&quot;&gt;让 Vim 在保存文件时自动格式化代码&lt;&#x2F;a&gt;一文中展示了保存时自动化格式代码的&lt;code&gt;vim&lt;&#x2F;code&gt;配置。作为&lt;code&gt;emacs&lt;&#x2F;code&gt;用户，自然有自己的解决方案。以下呈现。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>golang 常见类型字节数</title>
        <published>2022-06-06T14:36:00+08:00</published>
        <updated>2022-06-06T14:36:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/golang-chang-jian-lei-xing-zi-jie-shu/"/>
        <id>https://liyan-ah.github.io/golang-chang-jian-lei-xing-zi-jie-shu/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ebpf&lt;&#x2F;code&gt; 分析&lt;code&gt;golang&lt;&#x2F;code&gt;程序时，离不开对参数大小的判断。这里列出来一些基本类型的大小，并通过汇编对应验证函数的方式来肯定判断结果。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;xin-xi&quot;&gt;信息&lt;&#x2F;h1&gt;
&lt;p&gt;这里列出基本类型及其作为参数传递时，占用的空间大小如下表。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;&#x2F;th&gt;&lt;th&gt;长度&lt;&#x2F;th&gt;&lt;th&gt;说明&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;指针&lt;&#x2F;td&gt;&lt;td&gt;8B&lt;&#x2F;td&gt;&lt;td&gt;64位机为 8Byte, 32位机位4Byte&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;context&lt;&#x2F;td&gt;&lt;td&gt;16B&lt;&#x2F;td&gt;&lt;td&gt;interface 类型。其中，前8B是类型信息，后8B是对象的指针信息&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;interface&lt;&#x2F;td&gt;&lt;td&gt;16B&lt;&#x2F;td&gt;&lt;td&gt;2 个指针，详见&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;draveness.me&#x2F;golang&#x2F;docs&#x2F;part2-foundation&#x2F;ch04-basic&#x2F;golang-interface&#x2F;&quot;&gt;draveness-go-interface&lt;&#x2F;a&gt;，或者 runtime&#x2F;runtime2.go iface&#x2F;eface 定义&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;int64&lt;&#x2F;td&gt;&lt;td&gt;8B&lt;&#x2F;td&gt;&lt;td&gt;-&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;int&lt;&#x2F;td&gt;&lt;td&gt;8B&lt;&#x2F;td&gt;&lt;td&gt;64位机为 8Byte, 32位机位4Byte&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;string&lt;&#x2F;td&gt;&lt;td&gt;16B&lt;&#x2F;td&gt;&lt;td&gt;8B 地址 + 8B string长度&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;slice&lt;&#x2F;td&gt;&lt;td&gt;24B&lt;&#x2F;td&gt;&lt;td&gt;8B地址 + 8B slice 成员数量 + 8B slice capability&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;func&lt;&#x2F;td&gt;&lt;td&gt;8B&lt;&#x2F;td&gt;&lt;td&gt;func 作为函数参数时，传递的是 func 的地址&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;需要注意的是，作为函数参数传递时，golang会对参数按照 8B 进行对齐。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>golang proto3 使用</title>
        <published>2022-05-19T17:53:00+08:00</published>
        <updated>2022-05-19T17:53:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/golang-proto3-shi-yong/"/>
        <id>https://liyan-ah.github.io/golang-proto3-shi-yong/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一直都比较赞赏&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;developers.google.com&#x2F;protocol-buffers&#x2F;docs&#x2F;proto3&quot;&gt;&lt;code&gt;protocol buffer&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;。由于其表现性强、压缩比高，可以把很多结构都写到&lt;code&gt;proto&lt;&#x2F;code&gt;文件中，同时添加很多的注释。当需要进行进行数据存储时，使用&lt;code&gt;proto&lt;&#x2F;code&gt;序列化结果替代&lt;code&gt;json&lt;&#x2F;code&gt;，可以省去很多的冗余字段。本篇找了一些&lt;code&gt;golang&lt;&#x2F;code&gt;中&lt;code&gt;protocol buffer&lt;&#x2F;code&gt;的使用示例，以及&lt;code&gt;protocol&lt;&#x2F;code&gt;对象与&lt;code&gt;json&lt;&#x2F;code&gt;对象互相转换的示例。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>challenges of bpf tracing go</title>
        <published>2022-04-19T14:33:00+08:00</published>
        <updated>2022-04-19T14:33:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/challenges-of-bpf-tracing-go/"/>
        <id>https://liyan-ah.github.io/challenges-of-bpf-tracing-go/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/challenges-of-bpf-tracing-go/">&lt;blockquote&gt;
&lt;p&gt;goroutine 开销为 2KB（最少），对比线程 2MB 的开销，有明显的优势。当goroutine 栈资源不足时，runtime 会将整个 goroutine stack 拷贝、重新分配空间。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Instead of using a thread for every goroutine, Go multiplexes goroutines across multiple threads (&quot;M:N scheduling&quot;). So instead of each thread having a default 2MB stack, each goroutine has a tiny 2KB stack that&#x27;s managed by the runtime instead of the operating system. When the program needs to grow the stack for a goroutine and there&#x27;s not enough room, the runtime copies the entire goroutine&#x27;s stack to another place in memory where it has enough room to expand.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.0x74696d.com&#x2F;posts&#x2F;challenges-of-bpf-tracing-go&#x2F;&quot;&gt;Challenges of BPF Tracing Go&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>centos 安装docker并构建golang镜像</title>
        <published>2022-03-04T15:00:00+08:00</published>
        <updated>2022-03-04T15:00:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/centos-an-zhuang-dockerbing-gou-jian-golangjing-xiang/"/>
        <id>https://liyan-ah.github.io/centos-an-zhuang-dockerbing-gou-jian-golangjing-xiang/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;工作需要（抛弃了kubectl搞一套环境的方法），需要在centos8上构建一套docker镜像并运行golang程序。这里记录下docker安装及golang程序打包镜像的过程。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>eBPF及其对可观测的意义【译文】</title>
        <published>2022-03-02T16:34:00+08:00</published>
        <updated>2022-03-02T16:34:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/ebpfji-qi-dui-ke-guan-ce-de-yi-yi-yi-wen/"/>
        <id>https://liyan-ah.github.io/ebpfji-qi-dui-ke-guan-ce-de-yi-yi-yi-wen/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近在做 eBPF 的技术调研。看到很多对 eBPF 的介绍。为了加强对内容的理解，笔者选择了其中的一篇尝试翻译。本着便于笔者自己理解的角度，很多内容加入了自己的一些理解，因此并不能算是严格意义上的“翻译”。文章涉及了 eBPF 的介绍、优势、不足，算是一篇 eBPF 的很好的介绍。现在把它贴上来，算是纪念自己的第一篇“译文”。&lt;br &#x2F;&gt;
原文地址：&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;newrelic.com&#x2F;blog&#x2F;best-practices&#x2F;what-is-ebpf&quot;&gt;What Is eBPF and Why Does It Matter for Observability?&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>centos 构建 local-k8s</title>
        <published>2022-02-24T17:27:00+08:00</published>
        <updated>2022-02-24T17:27:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/centos-gou-jian-k8s-ji-qun/"/>
        <id>https://liyan-ah.github.io/centos-gou-jian-k8s-ji-qun/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;工作原因，需要安装一个 local-k8s。中间碰了很多坑，做个记录。
环境：Linux test 4.18.0-193.el8.x86_64&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>Mac 绘图工具推荐</title>
        <published>2022-02-16T10:51:00+08:00</published>
        <updated>2022-02-16T10:51:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/mac-hui-tu-gong-ju-tui-jian/"/>
        <id>https://liyan-ah.github.io/mac-hui-tu-gong-ju-tui-jian/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/mac-hui-tu-gong-ju-tui-jian/">&lt;p&gt;之前办公一直在&lt;code&gt;Windows&lt;&#x2F;code&gt;系统中，诸如流程图、部署图等图表使用的是&lt;code&gt;visio&lt;&#x2F;code&gt;。迁移到&lt;code&gt;Mac&lt;&#x2F;code&gt;上后，&lt;code&gt;visio&lt;&#x2F;code&gt;便不能使用了。转战到&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.sketch.com&#x2F;&quot;&gt;&lt;code&gt;sketch&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; 上，用着颇为顺手，无奈试用期到了之后，就无法使用了。评估了下使用需求及产品价格，只能启用。&lt;br &#x2F;&gt;
目前在使用&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;draw.io&#x2F;&quot;&gt;&lt;code&gt;draw.io&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; 进行日常绘图，开源、跨平台、免费、使用流畅，可以在线使用或者客户端使用。基本满足日常需求。用着还是比较好的。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>ELK-docker 实践</title>
        <published>2022-01-04T00:06:00+08:00</published>
        <updated>2022-01-04T00:06:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/elk-docker-shi-jian/"/>
        <id>https://liyan-ah.github.io/elk-docker-shi-jian/</id>
        
        <summary type="html">&lt;h1 id=&quot;elk-docker-bu-shu-shi-jian&quot;&gt;ELK docker 部署实践&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要对 ELK 套件中的 filebeat, logstash, elasticsearch 的安装进行实践，以及简单运行。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>Quic协议</title>
        <published>2021-11-09T21:11:00+08:00</published>
        <updated>2021-11-09T21:11:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/quicxie-yi/"/>
        <id>https://liyan-ah.github.io/quicxie-yi/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Quic 协议作为应用层的协议，在无线、弱网场景下的移动通信领域有广阔的应用场景。本文简单记录一些 Quic 的知识点，同时附上介绍的详细文章；&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>emacs-若干语言 lsp 配置备注</title>
        <published>2021-10-12T20:26:00+08:00</published>
        <updated>2021-10-12T20:26:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/emacs-ruo-gan-yu-yan-lsp-pei-zhi-bei-zhu/"/>
        <id>https://liyan-ah.github.io/emacs-ruo-gan-yu-yan-lsp-pei-zhi-bei-zhu/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;微软推出的&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;microsoft.github.io&#x2F;language-server-protocol&#x2F;#:~:text=Language%20Server%20Protocol.%20The%20Language%20Server%20Protocol%20%28LSP%29,is%20to%20support%20rich%20code%20navigation%20in%20&quot;&gt;language server protol&lt;&#x2F;a&gt; 确实提升了文本编辑器的使用体验。就 &lt;code&gt;emacs&lt;&#x2F;code&gt; 的使用而言，配合各个语言的 lsp 实现，能够减少配置语言开发环境的难度。这里记录一下使用 &lt;code&gt;emacs&lt;&#x2F;code&gt; 中的 rust, golang, python, c&#x2F;c++ lsp 配置&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>redisgo 连接报错</title>
        <published>2021-08-18T17:26:00+08:00</published>
        <updated>2021-08-18T17:26:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/redisgo-lian-jie-bao-cuo/"/>
        <id>https://liyan-ah.github.io/redisgo-lian-jie-bao-cuo/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/redisgo-lian-jie-bao-cuo/">&lt;blockquote&gt;
&lt;p&gt;记一次&lt;code&gt;redisgo&lt;&#x2F;code&gt;库使用时，连接远程&lt;code&gt;redis&lt;&#x2F;code&gt;服务写数据报错的问题。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;redis&lt;&#x2F;code&gt;写数据时，出现报错&lt;code&gt;write: broken pipe&lt;&#x2F;code&gt;及&lt;code&gt;write: connection reset by peer&lt;&#x2F;code&gt;。看着都是网络的问题，使用&lt;code&gt;redis-cli&lt;&#x2F;code&gt;可以登陆并且执行查询等操作。经过排查，是写的数据量过大，导致写数据持续时间过长，排查的思路是猜想-&amp;gt;验证&lt;code&gt;@A@&lt;&#x2F;code&gt;。&lt;br &#x2F;&gt;
对于多个数据可以进行拆分。对于单个完整的数据，还没有太好的拆分思路（或许基于 &lt;code&gt;pb&lt;&#x2F;code&gt; 进行压缩，会是个好方式？）&lt;&#x2F;p&gt;
&lt;h1 id=&quot;can-kao-wen-zhang&quot;&gt;参考文章&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.csdn.net&#x2F;xieganyu3460&#x2F;article&#x2F;details&#x2F;82884346&quot;&gt;python redis读写报错：Broken Pipe Error Redis&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>PHP-7.1升级至7.4兼容性</title>
        <published>2021-08-02T20:34:48+08:00</published>
        <updated>2021-08-02T20:34:48+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/php-7-1sheng-ji-zhi-7-4jian-rong-xing/"/>
        <id>https://liyan-ah.github.io/php-7-1sheng-ji-zhi-7-4jian-rong-xing/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;php作为&lt;del&gt;动不动搞个大事情&lt;&#x2F;del&gt;世界上最好的语言,&lt;del&gt;经常&lt;&#x2F;del&gt;偶尔会出现由于版本升级导致的不兼容问题。笔者在工作中遇到了&lt;code&gt;php7.1&lt;&#x2F;code&gt;升级到&lt;code&gt;php7.4&lt;&#x2F;code&gt;导致的&lt;code&gt;each&lt;&#x2F;code&gt;弃用、&lt;code&gt;mcrypt&lt;&#x2F;code&gt;库启动导致的不兼容。在这里备注下兼容方式。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>go-simplejson 插入数组</title>
        <published>2021-07-22T17:58:00+08:00</published>
        <updated>2021-07-22T17:58:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/go-simplejson-cha-ru-shu-zu/"/>
        <id>https://liyan-ah.github.io/go-simplejson-cha-ru-shu-zu/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;bitly&#x2F;go-simplejson&quot;&gt;go-simplejson&lt;&#x2F;a&gt;是go lang语言中操作json非常方便的开源库。最近使用simplejson进行数据插入操作时遇到了问题，经过排查后最终解决。现记录如下。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>http及websocket性能对比</title>
        <published>2021-07-15T19:29:10+08:00</published>
        <updated>2021-07-15T19:29:10+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/httpji-websocketxing-neng-dui-bi/"/>
        <id>https://liyan-ah.github.io/httpji-websocketxing-neng-dui-bi/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从过往的经历中来看，使用websocket作为http协议的替代似乎是一种潮流。websocket以其小包头、全双工的优势，弥补了http协议的性能上的缺陷。对于长链接需求，完全可以在初始化时创建websocket连接，在业务交互时直接进行通信，使得通信过程更加流畅。相信在基于Quic的http3协议走向成熟应用前，websocket在性能上都具有优势。本文以golang语言为基础，构造场景进行两种协议的性能对比。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>golang GMP</title>
        <published>2021-04-15T21:39:29+08:00</published>
        <updated>2021-04-15T21:39:29+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/golang-gmp/"/>
        <id>https://liyan-ah.github.io/golang-gmp/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写点东西还是难，果然还是搬运工来的轻松些。今天搬运点Golang的&lt;code&gt;GMP&lt;&#x2F;code&gt;模型看看。最近在准备一篇&lt;code&gt;Golang&lt;&#x2F;code&gt;的&lt;code&gt;GC&lt;&#x2F;code&gt;实践。慢慢搞吧。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;qian-yan&quot;&gt;前言&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;code&gt;Golang&lt;&#x2F;code&gt;作为语言层面支持并发的语言，使用&lt;code&gt;go&lt;&#x2F;code&gt;可以让搬砖体验飞起。但是从直觉来说，事情并没有这么简单：从操作系统层面来说，进程和线程是操作系统认可的并行机制。协程以及&lt;code&gt;Golang&lt;&#x2F;code&gt;的所谓&lt;em&gt;纤程&lt;&#x2F;em&gt;是期望一堆程序员期望将操作系统的工作拿过来，以满足一些优化的效果。所以诸如&lt;code&gt;Python&lt;&#x2F;code&gt;的协程以及&lt;code&gt;Golang&lt;&#x2F;code&gt;的纤程，总是能够对应到操作系统认可的执行单元上。对于&lt;code&gt;Python&lt;&#x2F;code&gt;的协程还好理解一些，是严格运行在自己的线程里的，只是语言层面实现了线程内的上下文切换优化。所以对于&lt;code&gt;CPU&lt;&#x2F;code&gt;密集型的操作，仅使用协程是无法达到优化效果的：这种场景下&lt;code&gt;Python&lt;&#x2F;code&gt;会推荐多进程。相比起来，&lt;code&gt;Golang&lt;&#x2F;code&gt;的&lt;code&gt;go&lt;&#x2F;code&gt;野心更大一些：期望给用户以&lt;code&gt;go&lt;&#x2F;code&gt;作为接口，在语言内实现与操作系统调度单元的交互。&lt;code&gt;Golang&lt;&#x2F;code&gt;里实际的调度模型是&lt;code&gt;GMP&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>golang 封装</title>
        <published>2021-04-08T21:16:00+08:00</published>
        <updated>2021-04-08T21:16:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/golang-ji-cheng/"/>
        <id>https://liyan-ah.github.io/golang-ji-cheng/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;golang作为一种高级语言，实现了面向对象语言的封装、继承、多态的特性。本文简要介绍下golang面向对象的这些特性。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>ratelimit服务流量限制</title>
        <published>2021-02-07T17:30:00+08:00</published>
        <updated>2021-02-07T17:30:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/ratelimitfu-wu-liu-liang-xian-zhi/"/>
        <id>https://liyan-ah.github.io/ratelimitfu-wu-liu-liang-xian-zhi/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在日常的工作中，固定QPS或者固定并发数是常用的两个衡量系统容量时采用的流量控制手段。本文以&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;chai2010.cn&#x2F;advanced-go-programming-book&#x2F;&quot;&gt;Go语言高级编程&lt;&#x2F;a&gt; 服务流量限制的内容为开端，对服务流量限制进行展开描述，同时对&lt;code&gt;Jmeter&lt;&#x2F;code&gt;及&lt;code&gt;golang ratelimit&lt;&#x2F;code&gt;中的流量限制方法进行描述。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;起因&lt;&#x2F;li&gt;
&lt;li&gt;漏桶法&lt;&#x2F;li&gt;
&lt;li&gt;令牌桶法&lt;&#x2F;li&gt;
&lt;li&gt;Jmeter中流量吞吐控制&lt;&#x2F;li&gt;
&lt;li&gt;golang ratelimit&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>org-mode使用备注</title>
        <published>2021-01-11T21:49:00+08:00</published>
        <updated>2021-01-11T21:49:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/org-modeshi-yong-bei-zhu/"/>
        <id>https://liyan-ah.github.io/org-modeshi-yong-bei-zhu/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/org-modeshi-yong-bei-zhu/">&lt;blockquote&gt;
&lt;p&gt;org-mode agenda界面变更任务状态、添加备注、添加日记（每日总结）、编辑记录&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;以下操作均在&lt;code&gt;org-agenda&lt;&#x2F;code&gt;中的&lt;code&gt;agenda for current week or day&lt;&#x2F;code&gt;视图下快速编辑：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作&lt;&#x2F;th&gt;&lt;th&gt;快捷键&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;变更任务状态&lt;&#x2F;td&gt;&lt;td&gt;t&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;添加备注&lt;&#x2F;td&gt;&lt;td&gt;z&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;添加日记&lt;&#x2F;td&gt;&lt;td&gt;i&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;编辑note&lt;&#x2F;td&gt;&lt;td&gt;z&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;重建agenda&lt;&#x2F;td&gt;&lt;td&gt;r&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;打开日历&lt;&#x2F;td&gt;&lt;td&gt;a&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;下周任务列表&lt;&#x2F;td&gt;&lt;td&gt;f&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;上周任务列表&lt;&#x2F;td&gt;&lt;td&gt;b&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;打开任务所在原始文件&lt;&#x2F;td&gt;&lt;td&gt;enter&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
</content>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>emacs! start org-mode! --org-mode使用备注</title>
        <published>2021-01-10T20:30:00+08:00</published>
        <updated>2021-01-10T20:30:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/org-modshi-yong-bei-zhu/"/>
        <id>https://liyan-ah.github.io/org-modshi-yong-bei-zhu/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;为了更好的&lt;code&gt;live in emacs&lt;&#x2F;code&gt;，一款合适的日程管理工具总是需要的。在挣扎了若干次后，最终还是把&lt;code&gt;org-mode&lt;&#x2F;code&gt;这一优秀的日程管理工具捡起来了。本文简单记录下使用的方法。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;org-modejie-shao&quot;&gt;org-mode介绍&lt;&#x2F;h1&gt;
&lt;p&gt;在&lt;code&gt;神的编辑器emacs&lt;&#x2F;code&gt;的传说中，往往有&lt;code&gt;org-mode&lt;&#x2F;code&gt;的身影。虽然按照(org官网)&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;orgmode.org&#x2F;&quot;&gt;orgmode&lt;&#x2F;a&gt;官网的描述，&lt;code&gt;org-mode&lt;&#x2F;code&gt;并不仅限于在&lt;code&gt;emacs&lt;&#x2F;code&gt;中使用，如&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;57800574&quot;&gt;开始使用 Org 模式吧，在没有 Emacs 的情况下&lt;&#x2F;a&gt;这篇文章就详细讲解了在&lt;code&gt;vscode&lt;&#x2F;code&gt;中使用&lt;code&gt;org-mode&lt;&#x2F;code&gt;的方式，但是配合&lt;code&gt;emacs&lt;&#x2F;code&gt;的万物皆系于&lt;code&gt;kbd&lt;&#x2F;code&gt;之上的使用习惯，&lt;code&gt;org-mode&lt;&#x2F;code&gt;确实能够发挥最大的功能。&lt;br &#x2F;&gt;
&lt;code&gt;org-mode&lt;&#x2F;code&gt;的基本功能包括设置待办事项、设置待办的标签、查看日历、查看某一天的待办及进度。基本上，满足了对优秀日程管理工具的所有想象。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>elscreen标签背景颜色</title>
        <published>2020-12-23T19:23:00+08:00</published>
        <updated>2020-12-23T19:23:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/elscreenbiao-qian-bei-jing-yan-se/"/>
        <id>https://liyan-ah.github.io/elscreenbiao-qian-bei-jing-yan-se/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;使用&lt;code&gt;emacs&lt;&#x2F;code&gt;过程中，配合&lt;code&gt;evil&lt;&#x2F;code&gt;使用，按照&lt;code&gt;tab&lt;&#x2F;code&gt;的划分，将编辑、浏览、&lt;code&gt;leetcode&lt;&#x2F;code&gt;等任务划分到不同的&lt;code&gt;tab&lt;&#x2F;code&gt;便于切换及管理。美中不足的是，模拟标签的&lt;code&gt;elscreen&lt;&#x2F;code&gt;默认将其他标签的颜色设置成&lt;code&gt;:background blue  :foreground black&lt;&#x2F;code&gt;的配色，每次切换任务时，都需要重复确认需要跳转到哪个标签，就比较麻烦了。查找了一下重置&lt;code&gt;face-attribute&lt;&#x2F;code&gt;的方法，备注下。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;在初始文件的最后添加：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;;; 选中标签设置为绿底黑字，其他标签为黄底黑字
(set-face-attribute &amp;#39;elscreen-tab-other-screen-face nil
                    :background &amp;quot;yellow&amp;quot; :foreground &amp;quot;black&amp;quot;)
(set-face-attribute &amp;#39;elscreen-tab-current-screen-face nil
                    :background &amp;quot;green&amp;quot; :foreground &amp;quot;black&amp;quot;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>Mac使用备注</title>
        <published>2020-12-10T19:40:00+08:00</published>
        <updated>2020-12-10T19:40:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/macshi-yong-bei-zhu/"/>
        <id>https://liyan-ah.github.io/macshi-yong-bei-zhu/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近开始使用Mac了。在使用过程中，发现了一些&lt;code&gt;Mac OS&lt;&#x2F;code&gt;和&lt;code&gt;Centos&lt;&#x2F;code&gt;体验上不同的地方。在这里做一下备注。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;bu-fen-linuxzhi-ling-que-shi&quot;&gt;部分Linux指令缺失&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;Mac OS&lt;&#x2F;code&gt;并没有实现所有的&lt;code&gt;Linux&lt;&#x2F;code&gt;下的指令，如&lt;code&gt;realpath&lt;&#x2F;code&gt;这里就需要单独安装一些扩展包了：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;brew install coreutils&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>find匹配文件名</title>
        <published>2020-11-12T21:44:28+08:00</published>
        <updated>2020-11-12T21:44:28+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/findpi-pei-wen-jian-ming/"/>
        <id>https://liyan-ah.github.io/findpi-pei-wen-jian-ming/</id>
        
        <summary type="html">&lt;p&gt;目录内容：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;text  text.bak
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;希望从中找到&lt;code&gt;text.bak&lt;&#x2F;code&gt;。使用&lt;code&gt;find&lt;&#x2F;code&gt;实现。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>sed使用备注</title>
        <published>2020-11-12T16:36:51+08:00</published>
        <updated>2020-11-12T16:36:51+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/sedshi-yong-bei-zhu/"/>
        <id>https://liyan-ah.github.io/sedshi-yong-bei-zhu/</id>
        
        <summary type="html">&lt;h2 id=&quot;sedgong-neng-jie-shao&quot;&gt;sed功能介绍&lt;&#x2F;h2&gt;
&lt;p&gt;先看下官方的介绍&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sed  is a stream editor. A stream editor is used to perform basic text transformations on an input stream (a file or input from a pipeline).&lt;br &#x2F;&gt;
While in some ways similar to an editor which permits scripted edits (such as ed), sed works by making only one pass over the  input(s),  and&lt;br &#x2F;&gt;
is consequently more efficient.  But it is sed’s ability to filter text in a pipeline which particularly distinguishes it from other types of&lt;br &#x2F;&gt;
editors.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;大概的意思，是面向流的文本编辑工具。一般用来对文件中的文本进行替换等操作。&lt;br &#x2F;&gt;
以下备注一些常用的操作方式了。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>c++插件管理--pluma&lt;实践&gt;</title>
        <published>2020-10-29T21:19:00+08:00</published>
        <updated>2020-10-29T21:19:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/c-cha-jian-guan-li-pluma/"/>
        <id>https://liyan-ah.github.io/c-cha-jian-guan-li-pluma/</id>
        
        <summary type="html">&lt;p&gt;最近研究了一下&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;pluma-framework.sourceforge.net&#x2F;&quot;&gt;pluma&lt;&#x2F;a&gt;的使用。发现官网上的简单示例对于刚入门的人来说还是麻烦了些（而且还有语法错误）。&lt;br &#x2F;&gt;
下面重新整理了一个例子，作为备注。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>python调试方法（其一）</title>
        <published>2019-07-17T22:51:00+08:00</published>
        <updated>2019-07-17T22:51:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/pythondiao-shi-fang-fa-qi-yi/"/>
        <id>https://liyan-ah.github.io/pythondiao-shi-fang-fa-qi-yi/</id>
        
        <summary type="html">&lt;p&gt;&amp;lt;一&amp;gt; 这里记录一些python调试的方法：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# coding=UTF-8
&amp;#39;&amp;#39;&amp;#39; python debug method 1
use print function to get output informatino
&amp;#39;&amp;#39;&amp;#39;
DEBUG = True

def _debug_(*args, **kwds):
	&amp;#39;&amp;#39;&amp;#39; depends on DEBUG value, print some function &amp;#39;&amp;#39;&amp;#39;
    global DEBUG
    if DEBUG:
    	print(args, kwds)

if __name__ == &amp;quot;__main__&amp;quot;:
	_debug_(&amp;quot;this is a test&amp;quot;)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;最常见的调试方法了。&lt;code&gt;print&lt;&#x2F;code&gt;可以依据需求调整为其他的方式（&lt;code&gt;logging&lt;&#x2F;code&gt;输出日志或者直接输出到文件中均可）。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>shell-访问字符串同名变量</title>
        <published>2019-06-04T21:53:00+08:00</published>
        <updated>2019-06-04T21:53:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/shell-fang-wen-zi-fu-chuan-tong-ming-bian-liang/"/>
        <id>https://liyan-ah.github.io/shell-fang-wen-zi-fu-chuan-tong-ming-bian-liang/</id>
        
        <summary type="html">&lt;p&gt;考虑以下场景：&lt;br &#x2F;&gt;
期望通过给定的变量名称&lt;code&gt;var_str&lt;&#x2F;code&gt;，打印出该名称对应的变量值&lt;code&gt;${var_str}&lt;&#x2F;code&gt;。使用指令&lt;code&gt;eval&lt;&#x2F;code&gt;可以很方便的实现：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;var_str=&amp;quot;1213&amp;quot;;
ned_param_name=&amp;quot;var_str&amp;quot;;
eval echo &amp;#39;$&amp;#39;&amp;quot;${ned_param_name}&amp;quot;;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出结果为&lt;code&gt;1213&lt;&#x2F;code&gt;;&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>lisp-do循环</title>
        <published>2019-06-03T22:42:00+08:00</published>
        <updated>2019-06-03T22:42:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/lisp-doxun-huan/"/>
        <id>https://liyan-ah.github.io/lisp-doxun-huan/</id>
        
        <summary type="html">&lt;p&gt;lisp中，do循环形象如下:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;(do (variable-definition*)
    (end-test-form result-form*)
    statement*);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>lisp-let变量声明</title>
        <published>2019-05-30T22:51:00+08:00</published>
        <updated>2019-05-30T22:51:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/lisp-letbian-liang-sheng-ming/"/>
        <id>https://liyan-ah.github.io/lisp-letbian-liang-sheng-ming/</id>
        
        <summary type="html">&lt;p&gt;lisp声明、使用变量的一种方法，是使用&lt;code&gt;let&lt;&#x2F;code&gt;语句。&lt;br &#x2F;&gt;
形如：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;;(let ((variable declare1) (variable declare2) (...))
;  (varaible used here));
(defun foo(x)
  (format t &amp;quot;Parameter: ~a~%&amp;quot; x)
  (let ((x 2))
    (format t &amp;quot;Outer LET: ~a~%&amp;quot; x)
    (let ((x 3))
      (format t &amp;quot;Inner LET: ~a~%&amp;quot; x))
    (format t &amp;quot;Outer LET: ~a~%&amp;quot; x))
  (format t &amp;quot;Parameter: ~a~%&amp;quot; x));

(foo 10);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>lisp-lambda函数</title>
        <published>2019-05-29T23:28:00+08:00</published>
        <updated>2019-05-29T23:28:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/lisp-lambdahan-shu/"/>
        <id>https://liyan-ah.github.io/lisp-lambdahan-shu/</id>
        
        <summary type="html">&lt;p&gt;lisp中的lambda表达式，显然和python中的很相似。&lt;br &#x2F;&gt;
参照《实用common lisp编程》：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;;按照 min max, 步长step为参数的fn计算的长度输出 *
(defun plot (fn min max step)
  (loop for i from min to max by step do
        (loop repeat (funcall fn i) do (format t &amp;quot;*&amp;quot;))
        (format t &amp;quot;~%&amp;quot;)))

(plot #&amp;#39;exp 0 4 1&#x2F;2);
(plot #&amp;#39;(lambda (x) (* 2 x)) 0 10 1);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>clisp编译</title>
        <published>2019-05-28T22:16:00+08:00</published>
        <updated>2019-05-28T22:16:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/clispbian-yi/"/>
        <id>https://liyan-ah.github.io/clispbian-yi/</id>
        
        <summary type="html">&lt;p&gt;目前，lisp的开发环境基本上被&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;common-lisp.net&#x2F;project&#x2F;lispbox&#x2F;&quot;&gt;lispbox&lt;&#x2F;a&gt;所垄断。所以本文来说一&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;clisp.sourceforge.io&#x2F;&quot;&gt;CLISP&lt;&#x2F;a&gt;，C语言实现的LISP解释器的安装。&lt;&#x2F;p&gt;</summary>
        
    </entry>
    <entry xml:lang="zh-CN">
        <title>lisp-hello world</title>
        <published>2019-05-28T21:52:00+08:00</published>
        <updated>2019-05-28T21:52:00+08:00</updated>
        
        <author>
          <name>
            
              李岩
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://liyan-ah.github.io/lisp-hello-world/"/>
        <id>https://liyan-ah.github.io/lisp-hello-world/</id>
        
        <content type="html" xml:base="https://liyan-ah.github.io/lisp-hello-world/">&lt;p&gt;lisp语言的基本表达式为S-表达式。这与受&lt;a rel=&quot;noopener nofollow noreferrer external&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ALGOL&quot;&gt;Algol&lt;&#x2F;a&gt;语言影响的C系语言有很大的不同。显然，这很有趣：&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;;the bellow is hello world function in lisp
  (defun hello-world()
    &amp;quot;hello world function in lisp&amp;quot;
    (format t &amp;quot;hello, world!&amp;quot;));```
由&amp;lt;code&amp;gt;()&amp;lt;&#x2F;code&amp;gt;所包围的内容，为*列表*，其余内容为原子。显然，lisp表达式有很多列表表示（List Processing)。&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
</feed>
